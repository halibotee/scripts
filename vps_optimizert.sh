#!/bin/bash
# 适用于低配vps的全面优化和提速，包括 CPU和内存优化、进程精简、安全加固、网络优化、开启BBR+FQ等。
# Generated by github.com/halibotee

set -euo pipefail
IFS=$'\n\t'

export FORCE_YES=0
if [ "${1:-}" = "-y" ] || [ "${1:-}" = "--yes" ]; then
    FORCE_YES=1
fi

SCRIPT_VERSION="1.3.3"
BACKUP_DIR="/etc/vps_optimizert_backup"
LOG_FILE="/var/log/vps_optimizert.log"
ACTION_LOG="${BACKUP_DIR}/actions.log"
export DEBIAN_FRONTEND=noninteractive

declare -ga PKG_CMD_INSTALL
declare -ga PKG_CMD_REMOVE
declare -ga PKG_CMD_CHECK
declare -ga PKG_CMD_UPDATE

FN_TRIM_SERVICES_LIST=(
"unattended-upgrades.service"
"motd-news.service"
"man-db.timer"
"sysstat.service"
"whoopsie.service"
"apport.service"
"snapd.service"
"snapd.socket"
"avahi-daemon.service"
"bluetooth.service"
"cups.service"
"cups-browsed.service"
"ModemManager.service"
"ssh-askpass.service"
"e2scrub_reap.timer"
"packagekit.service"
"thermald.service"
"qemu-guest-agent.service"
"atop.service"
"atopacctd.service"
"rc-local.service"
)

FN_NETWORK_SERVICES_LIST=(
"xray"
"hysteria2"
"hysteria"
"udp2raw"
"kcptun"
"ax-xray@*"
"ax-hysteria2@*"
"ax-udp2raw@*"
"ax-kcptun@*"
"xray@*"
"hysteria2@*"
"udp2raw@*"
"kcptun@*"
)

mkdir -p "$BACKUP_DIR"
touch "$LOG_FILE"
> "$LOG_FILE"
touch "$ACTION_LOG"

fn_log() {
    if [ -z "${LOG_Y_RECORDED:-}" ]; then
        if [ $FORCE_YES -eq 1 ]; then
            local ts=$(date '+%F %T')
            printf '%s [%s] %s\n' "$ts" "警告" "非交互模式 (-y) 已激活。将自动同意所有提示。" >> "$LOG_FILE"
        fi
        export LOG_Y_RECORDED=1
    fi
    
local level="$1"; shift
local msg="$*"
local ts
ts=$(date '+%F %T')
printf '%s [%s] %s\n' "$ts" "$level" "$msg" >> "$LOG_FILE"
}

fn_log_action() {
    local action="$1"
    local value="$2"
    echo "${action}:${value}" >> "$ACTION_LOG"
    fn_log "调试" "记录操作: ${action}:${value}"
}

fn_check_if_optimized() {
    if [ ! -f "$ACTION_LOG" ]; then
        return 1
    fi
    
    local action_count
    action_count=$(grep -vc -E '(^#|^$)' "$ACTION_LOG" 2>/dev/null || true)
    
    if [ "${action_count:-0}" -gt 0 ]; then
        return 0
    else
        return 1
    fi
}


fn_check_root() {
if [ "$EUID" -ne 0 ]; then
echo "错误: 本脚本必须以 root 权限运行。"
fn_log "错误" "本脚本必须以 root 权限运行。"
exit 1
fi
}

fn_check_pkg_lock() {
    if [ "$OS_ID" = "debian" ] || [ "$OS_ID" = "ubuntu" ]; then
        if fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; then
            fn_log "警告" "检测到 APT/DPKG 锁。"
            return 1
        fi
    elif [ "$OS_ID" = "fedora" ] || [ "$OS_ID" = "rhel" ] || [ "$OS_ID" = "centos" ] || [ "$OS_ID" = "almalinux" ] || [ "$OS_ID" = "rocky" ]; then
        if [ -f /var/cache/dnf/metadata_lock.pid ] && pgrep -F /var/cache/dnf/metadata_lock.pid >/dev/null 2>&1; then
            fn_log "警告" "检测到 DNF 锁。"
            return 1
        fi
    fi
    return 0
}

fn_wait_for_pkg_lock() {
    local max_wait=120
    local count=0
    fn_log "信息" "检查包管理器锁..."
    while ! fn_check_pkg_lock; do
        if [ "$count" -ge "$max_wait" ]; then
            fn_log "错误" "等待包管理器锁超时 (120 秒)。操作可能失败。"
            return 1
        fi
        fn_log "警告" "检测到包管理器锁，等待 5 秒... ($count/$max_wait)"
        sleep 5
        count=$((count + 5))
    done
    fn_log "信息" "包管理器锁已释放。"
    return 0
}

fn_detect_os() {
    
    if [ -f /etc/os-release ]; then
        source /etc/os-release
        OS_PRETTY="${PRETTY_NAME:-unknown}"
        OS_ID="${ID:-unknown}"
        OS_VER="${VERSION_ID:-unknown}"
        echo "检测到操作系统: $OS_PRETTY"
        fn_log "信息" "检测到操作系统: $OS_PRETTY"
    else
        echo "错误: 无法检测到操作系统 (/etc/os-release 不存在)。"
        fn_log "错误" "无法检测到操作系统 (/etc/os-release 不存在)。"
        exit 1
    fi

    case "$OS_ID" in
        debian|ubuntu)
            PKG_CMD_INSTALL=("apt-get" "install" "-y")
            PKG_CMD_REMOVE=("apt-get" "remove" "-y" "--purge")
            PKG_CMD_CHECK=("dpkg" "-s")
            PKG_CMD_UPDATE=("apt-get" "update")
            ;;
        fedora|rhel|centos|almalinux|rocky)
            PKG_CMD_INSTALL=("dnf" "install" "-y")
            PKG_CMD_REMOVE=("dnf" "remove" "-y")
            PKG_CMD_CHECK=("rpm" "-q")
            PKG_CMD_UPDATE=("dnf" "check-update" "--quiet")
            ;;
        *)
            echo "错误: 不支持的操作系统 $OS_ID。"
            fn_log "错误" "不支持的操作系统 $OS_ID。"
            exit 1
            ;;
    esac

    MEM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}' || echo 0)
    MEM_MB=$(( MEM_KB / 1024 ))
    echo "物理内存: ${MEM_MB} MB"
    fn_log "信息" "物理内存: ${MEM_MB} MB"
    if ! command -v systemctl >/dev/null 2>&1; then
        echo "错误: 未找到 Systemd。本脚本需要 systemd。"
        fn_log "错误" "未找到 Systemd。本脚本需要 systemd。"
        exit 1
    fi
}

fn_backup_state() {
fn_log "信息" "正在创建备份于 $BACKUP_DIR ..."
mkdir -p "$BACKUP_DIR" || { fn_log "错误" "无法创建 $BACKUP_DIR"; return 1; }
cp -an /etc/fstab "${BACKUP_DIR}/fstab.bak" 2>/dev/null || true
cp -an /etc/systemd/resolved.conf "${BACKUP_DIR}/resolved.conf.bak" 2>/dev/null || true
cp -an /etc/sysctl.conf "${BACKUP_DIR}/sysctl.conf.bak" 2>/dev/null || true
cp -ran /etc/sysctl.d "${BACKUP_DIR}/sysctl.d.bak" 2>/dev/null || true
cp -ran /etc/systemd/journald.conf.d "${BACKUP_DIR}/journald.conf.d.bak" 2>/dev/null || true
[ -f /etc/selinux/config ] && cp -an /etc/selinux/config "${BACKUP_DIR}/selinux.config.bak" 2>/dev/null || true
sysctl -n net.ipv4.tcp_congestion_control > "${BACKUP_DIR}/sysctl_con_algo.bak" 2>/dev/null || true
sysctl -n net.core.default_qdisc > "${BACKUP_DIR}/sysctl_q_algo.bak" 2>/dev/null || true

systemctl list-unit-files --type=service --state=enabled | awk '/enabled/ {print $1}' > "${BACKUP_DIR}/enabled_services.before.txt" 2>/dev/null || true

echo "# vps_optimizert action log ($(date))" > "$ACTION_LOG"

fn_log "信息" "备份完成。"
return 0
}

fn_fix_apt_sources_if_needed() {
fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
fn_log "信息" "检查包管理器源健康状况..."

if [ "$OS_ID" = "debian" ] || [ "$OS_ID" = "ubuntu" ]; then
    mkdir -p /etc/apt/apt.conf.d
    cat > /etc/apt/apt.conf.d/99-force-ipv4 <<'EOF'
Acquire::ForceIPv4 "true";
EOF
    fn_log "调试" "已创建 /etc/apt/apt.conf.d/99-force-ipv4 (强制 APT 使用 IPv4)"
    fn_log_action "CREATE_FILE" "/etc/apt/apt.conf.d/99-force-ipv4"
fi

if "${PKG_CMD_UPDATE[@]}"; then
fn_log "成功" "包管理器源正常。"
return 0
else
fn_log "警告" "包管理器 update 失败。将尝试保守替换 sources.list (仅限 Debian/Ubuntu)"

if [ "$OS_ID" = "debian" ] || [ "$OS_ID" = "ubuntu" ]; then
    if command -v lsb_release >/dev/null 2>&1; then
        codename=$(lsb_release -cs)
    else
        codename=$(grep VERSION_CODENAME /etc/os-release 2>/dev/null | cut -d= -f2 || true)
    fi
    if [ -z "${codename:-}" ]; then
        fn_log "错误" "无法确定发行版代号，跳过自动替换源。"
        return 1
    fi
    cp -an /etc/apt/sources.list "${BACKUP_DIR}/apt.sources.list.bak" 2>/dev/null || true
    
    if [ "$OS_ID" = "debian" ]; then
cat > /etc/apt/sources.list <<EOF
deb http://deb.debian.org/debian/ $codename main contrib non-free non-free-firmware
deb http://deb.debian.org/debian/ $codename-updates main contrib non-free non-free-firmware
deb http://security.debian.org/debian-security/ $codename-security main contrib non-free non-free-firmware
EOF
    elif [ "$OS_ID" = "ubuntu" ]; then
cat > /etc/apt/sources.list <<EOF
deb http://archive.ubuntu.com/ubuntu/ $codename main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ $codename-updates main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ $codename-security main restricted universe multiverse
EOF
    fi
else
    fn_log "错误" "此操作系统不支持自动替换源。"
    return 1
fi

if "${PKG_CMD_UPDATE[@]}"; then
    fn_log "成功" "APT 源替换并刷新成功。"
    return 0
else
    local update_cmd_str="${PKG_CMD_UPDATE[@]}"
    fn_log "错误" "替换源后 ${update_cmd_str} 仍然失败。"
    echo "-----------------------------------------------------"
    echo "[错误] 致命错误: 'apt update' 彻底失败。"
    echo "       请检查 DNS (例如 /etc/resolv.conf) 和网络连接。"
    echo "-----------------------------------------------------"
    return 1
fi
fi
}

fn_handle_selinux() {
    fn_log "信息" "检查 SELinux 状态..."
    
    if command -v getenforce >/dev/null 2>&1; then
        local selinux_status
        selinux_status=$(getenforce)

        if [ "$selinux_status" != "Disabled" ]; then
            fn_log "警告" "检测到 SELinux 状态为: $selinux_status"
            echo "-----------------------------------------------------"
            echo "警告: 检测到 SELinux 状态为: $selinux_status"
            echo "SELinux 会导致性能问题并可能与优化冲突。"
            
            local selinux_choice="n"
            if [ $FORCE_YES -eq 1 ]; then
                selinux_choice="y"
                echo "非交互模式: 自动同意禁用 SELinux。"
                fn_log "信息" "非交互模式: 自动同意禁用 SELinux。"
            else
                read -rp "是否要将其永久禁用 (推荐)? (y/n): " selinux_choice || true
            fi
            
            if [ "$selinux_choice" = "y" ] || [ "$selinux_choice" = "Y" ]; then
                echo "正在禁用 SELinux..."
                fn_log "信息" "正在禁用 SELinux..."
                setenforce 0 2>/dev/null || fn_log "警告" "setenforce 0 失败 (可能无权限或已禁用)。"
                if [ -f /etc/selinux/config ]; then
                    sed -i.bak 's/^SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config
                    fn_log_action "MODIFY_FILE" "/etc/selinux/config"
                    echo "SELinux 已永久禁用。需要重启生效。"
                    fn_log "成功" "SELinux 已永久禁用。需要重启生效。"
                else
                    echo "错误: 未找到 /etc/selinux/config，无法永久禁用。"
                    fn_log "错误" "未找到 /etc/selinux/config，无法永久禁用。"
                fi
            else
                echo "跳过禁用 SELinux。"
                fn_log "警告" "跳过禁用 SELinux。这可能导致后续步骤失败。"
            fi
        else
             fn_log "信息" "SELinux 状态: Disabled (良好)。"
             return 2
        fi
    else
        fn_log "信息" "未检测到 SELinux (正常)。"
        return 2
    fi
    return 0
}

fn_setup_fail2ban() {
    fn_log "信息" "配置 Fail2ban..."
    
    if systemctl is-active fail2ban >/dev/null 2>&1; then
        fn_log "信息" "Fail2ban 已安装并激活，跳过。"
        return 2
    fi
    
    if "${PKG_CMD_CHECK[@]}" fail2ban >/dev/null 2>&1; then
        fn_log "信息" "Fail2ban 已安装 (但未运行)。"
    else
        fn_log "信息" "正在安装 Fail2ban..."
        fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
        "${PKG_CMD_INSTALL[@]}" fail2ban >>"$LOG_FILE" 2>&1 || { 
            fn_log "警告" "Fail2ban 安装失败。"; 
            return 1; 
        }
        fn_log_action "INSTALL_PKG" "fail2ban"
        fn_log "信息" "Fail2ban 安装完成。"
    fi
    
    fn_log "信息" "配置 Fail2ban backend 为 systemd (以修复 sshd jail 冲突)..."
    
    mkdir -p /etc/fail2ban/jail.d
    local conf_file="/etc/fail2ban/jail.d/99-vps_optimizert-systemd.conf"
    cat > "$conf_file" <<'EOF'
[DEFAULT]
backend = systemd

[sshd]
backend = systemd
EOF
    fn_log_action "CREATE_FILE" "$conf_file"
    fn_log "调试" "已创建 /etc/fail2ban/jail.d/99-vps_optimizert-systemd.conf"
    
    (systemctl enable --now fail2ban) >> "$LOG_FILE" 2>&1
    
    if systemctl is-active fail2ban >/dev/null 2>&1; then
        fn_log "成功" "Fail2ban 已激活。"
        return 0
    else
        fn_log "错误" "Fail2ban 启动失败 (即使在应用 systemd backend 修复后)。"
        return 1
    fi
}

fn_setup_journald_volatile() {
local journal_storage
journal_storage=$(systemd-analyze cat-config systemd/journald.conf | grep -i '^Storage=' | tail -n 1 | cut -d= -f2 2>/dev/null || echo "disk")
if [ "$journal_storage" == "volatile" ]; then
    fn_log "信息" "journald 已是 volatile 模式，跳过。"
    return 2
fi

fn_log "信息" "配置 journald 为 volatile (内存) 模式 (RuntimeMaxUse=16M)..."
mkdir -p /etc/systemd/journald.conf.d
local conf_file="/etc/systemd/journald.conf.d/10-volatile.conf"
cat > "$conf_file" <<'EOF'
[Journal]
Storage=volatile
RuntimeMaxUse=16M
MaxRetentionSec=1month
EOF
fn_log_action "CREATE_FILE" "$conf_file"
systemctl restart systemd-journald >/dev/null 2>&1 || true
fn_log "成功" "journald 已配置为 volatile 模式。"
return 0
}

fn_setup_sysctl_extreme() {
local skipped=false
local conf_file="/etc/sysctl.d/99-vps_optimizert.conf"
if [ -f "$conf_file" ]; then
    fn_log "信息" "sysctl 配置文件 $conf_file 已存在，跳过写入。"
    skipped=true
else
    fn_log "信息" "应用 sysctl 极限网络调优 (高性能/高并发，开启BBR+FQ，优化UDP)..."
    cat > "$conf_file" <<'EOF'
# Extreme Network Optimization for VPS
# -----------------------------------------------------------------------------
# File System Limits
fs.file-max = 1000000
fs.inotify.max_user_instances = 8192

# Core Network Buffers (Aggressive)
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.core.rmem_default = 67108864
net.core.wmem_default = 67108864
net.core.optmem_max = 65536
net.core.netdev_max_backlog = 250000
net.core.somaxconn = 65535

# TCP Tuning
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 6
net.ipv4.ip_local_port_range = 10000 65000
net.ipv4.tcp_max_syn_backlog = 8192
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_slow_start_after_idle = 0

# Advanced TCP
net.ipv4.tcp_notsent_lowat = 16384
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_ecn = 1
net.ipv4.tcp_ecn_fallback = 1
net.ipv4.tcp_frto = 0

# UDP Tuning (Critical for Hysteria2/QUIC)
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192

# Congestion Control
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# Virtual Memory (Prefer RAM)
vm.swappiness = 1
vm.vfs_cache_pressure = 50

# IPv6 (Disable by default for stability/leak prevention)
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
EOF
    fn_log_action "CREATE_FILE" "$conf_file"
    fn_log "成功" "sysctl 极限优化配置文件 $conf_file 已创建。"
fi

sysctl --system >/dev/null 2>/dev/null || fn_log "警告" "sysctl 应用时出现警告。"
fn_log "信息" "sysctl --system 已执行。"

if [ "$skipped" == "true" ]; then
    return 2
fi
return 0
}

fn_trim_services_auto() {
fn_log "信息" "系统服务精简: 自动屏蔽非必要服务..."
local masked_count=0
local services_to_trim=("${FN_TRIM_SERVICES_LIST[@]}")

if systemctl list-unit-files "rsyslog.service" >/dev/null 2>&1; then
services_to_trim+=("rsyslog.service")
fi

for svc in "${services_to_trim[@]}"; do
if systemctl list-unit-files "$svc" >/dev/null 2>&1; then
    local svc_status
    svc_status=$(systemctl is-enabled "$svc" 2>/dev/null || echo "not-found")
    
    if [[ "$svc_status" == *"masked"* ]]; then
        fn_log "调试" "服务 $svc 已被屏蔽，跳过。"
    elif [[ "$svc_status" == "not-found" ]]; then
        fn_log "调试" "服务 $svc 不存在，跳过。"
    else
        fn_log "信息" "  正在屏蔽 (mask) $svc"
        (systemctl mask --now "$svc") >> "$LOG_FILE" 2>&1 || true
        fn_log_action "MASK_SERVICE" "$svc"
        masked_count=$((masked_count + 1))
    fi
else
    fn_log "调试" "服务 $svc 不存在，跳过。"
fi
done

if [ "$masked_count" -eq 0 ]; then
fn_log "信息" "未检测到需要新屏蔽的系统服务。"
return 2
else
fn_log "成功" "系统服务精简完成 (共屏蔽 ${masked_count} 个新服务)。"
fi
return 0
}

_fn_cleanup_fallback_swap() {
    local fallback_swap="/swapfile_zram"
    
    if [ ! -f "$fallback_swap" ]; then
        return 0
    fi

    if swapon -s | grep -q "$fallback_swap"; then
        fn_log "信息" "ZRAM 已激活，正在自动清理不再需要的回退 swapfile..."
        (swapoff "$fallback_swap") >> "$LOG_FILE" 2>&1 || true
        (rm -f "$fallback_swap") >> "$LOG_FILE" 2>&1 || true
        fn_log "成功" "已自动清理回退 swapfile: $fallback_swap"
    
    elif [ -f "$fallback_swap" ]; then
         fn_log "调试" "检测到未激活的回退 swapfile，正在清理..."
         (rm -f "$fallback_swap") >> "$LOG_FILE" 2>&1 || true
    fi
    return 0
}

fn_setup_zram_adaptive() {
    fn_log "信息" "启用 ZRAM (切换到 zram-tools 方案)..."

    if systemctl is-active zramswap.service >/dev/null 2>&1; then
        fn_log "信息" "ZRAM (zram-tools) 已激活，跳过。"
        _fn_cleanup_fallback_swap
        return 2
    fi
    
    if "${PKG_CMD_CHECK[@]}" systemd-zram-generator >/dev/null 2>&1; then
        fn_log "信息" "检测到冲突的 systemd-zram-generator，正在卸载..."
        fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
        "${PKG_CMD_REMOVE[@]}" systemd-zram-generator >>"$LOG_FILE" 2>&1 || true
        fn_log_action "UNINSTALL_PKG" "systemd-zram-generator"
    fi
    
    if "${PKG_CMD_CHECK[@]}" zram-tools >/dev/null 2>&1; then
        fn_log "信息" "ZRAM (zram-tools) 已安装。"
    else
        fn_log "信息" "正在安装 ZRAM (zram-tools)..."
        fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
        "${PKG_CMD_INSTALL[@]}" zram-tools >>"$LOG_FILE" 2>&1 || { 
            fn_log "警告" "zram-tools 安装失败"; 
            fn_setup_zram_fallback "zram-tools 安装失败"; 
            return 1; 
        }
        fn_log_action "INSTALL_PKG" "zram-tools"
        fn_log "信息" "ZRAM (zram-tools) 安装完成。"
    fi

    mem_mb="$MEM_MB"
    local zram_percent=100
    fn_log "信息" "ZRAM 目标大小: ${zram_percent}% 物理内存 (高风险设置)"

    local old_conf_file="/etc/systemd/zram-generator.conf"
    if [ -f "$old_conf_file" ]; then
        rm -f "$old_conf_file"
        fn_log "调试" "已移除旧的 zram-generator.conf"
    fi

    local conf_file="/etc/default/zramswap"
    cat > "$conf_file" <<EOF
# Configuration for zram-tools
ALGO=lz4
PERCENT=${zram_percent}
PRIORITY=100
EOF
    fn_log_action "CREATE_FILE" "$conf_file"
    fn_log "调试" "已写入 $conf_file"

    modprobe zram || true
    fn_log "调试" "已执行 modprobe zram"
    
    (systemctl restart zramswap.service) >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "已重启 zramswap.service (尝试 1)，等待 3 秒..."
    sleep 3

    if [ -b /dev/zram0 ] && swapon -s | grep -q 'zram'; then
        fn_log "成功" "ZRAM (zram-tools) 已激活 (尝试 1 成功)"
        (swapon -s) >> "$LOG_FILE" 2>&1
        systemctl enable zramswap.service >/dev/null 2>&1 || true
        _fn_cleanup_fallback_swap
        return 0
    fi

    fn_log "警告" "ZRAM 激活失败 (尝试 1)，将尝试清理内核缓存后重试..."
    (sync && echo 3 > /proc/sys/vm/drop_caches) 2>/dev/null || true
    fn_log "调试" "已清理内核缓存，等待 2 秒..."
    sleep 2

    (systemctl restart zramswap.service) >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "已重启 zramswap.service (尝试 2)，等待 3 秒..."
    sleep 3

    if [ -b /dev/zram0 ] && swapon -s | grep -q 'zram'; then
        fn_log "成功" "ZRAM (zram-tools) 已激活 (尝试 2 成功)"
        (swapon -s) >> "$LOG_FILE" 2>&1
        systemctl enable zramswap.service >/dev/null 2>&1 || true
        _fn_cleanup_fallback_swap
        return 0
    else
        fn_log "错误" "ZRAM (zram-tools) 激活失败 (尝试 2 仍失败)，使用 swapfile 回退"
        fn_log "警告" "100% 内存分配失败。这在低内存 VPS 上是常见情况 (os error 12)。"
        fn_setup_zram_fallback "ZRAM 激活失败"
        return 1
    fi
}

fn_setup_zram_fallback() {
    local reason="$1"
    fn_log "警告" "$reason, 使用 swapfile 回退"

    local swapfile="/swapfile_zram"
    local swapsize_mb=$(( MEM_MB < 512 ? MEM_MB : 512 ))
    
    if [ -f "$swapfile" ]; then
        fn_log "调试" "检测到旧的 swapfile，正在移除..."
        swapoff "$swapfile" 2>/dev/null || true
        rm -f "$swapfile" 2>/dev/null || true
    fi

    fn_log "调试" "创建 swapfile: $swapfile (大小: ${swapsize_mb}M)"
    (fallocate -l "${swapsize_mb}M" "$swapfile" || dd if=/dev/zero of="$swapfile" bs=1M count="$swapsize_mb") >> "$LOG_FILE" 2>&1
    fn_log_action "CREATE_FILE" "$swapfile"
    
    chmod 600 "$swapfile"
    (mkswap "$swapfile") >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "mkswap $swapfile"
    
    (swapon "$swapfile") >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "swapon $swapfile"
    
    if swapon -s | grep -q "$(basename "$swapfile")"; then
        fn_log "成功" "Swapfile 回退启用 (${swapsize_mb} MB)"
        (swapon -s) >> "$LOG_FILE" 2>&1
    else
        fn_log "错误" "Swapfile 回退启用失败。"
    fi
}

fn_prioritize_network_services_auto() {
local changes_made=0

local services_list_str
local IFS=','
services_list_str="${FN_NETWORK_SERVICES_LIST[*]}"
fn_log "信息" "正在搜索匹配的网络代理服务 (${services_list_str})..."

local found_names=()
for pattern in "${FN_NETWORK_SERVICES_LIST[@]}"; do
    while read -r service_file; do
        [ -z "$service_file" ] && continue
        
        local base_name="${service_file%.service}" 
        found_names+=("$base_name")
        
    done < <(systemctl list-unit-files --type=service --no-legend "${pattern}.service" 2>/dev/null | awk '{print $1}')
done

local detected_svcs=()
mapfile -t detected_svcs < <(printf "%s\n" "${found_names[@]}" | sort -u)


if [ ${#detected_svcs[@]} -eq 0 ]; then
fn_log "信息" "未检测到网络代理服务，无需优化。"
return 2
fi

local detected_svcs_str
IFS=','
detected_svcs_str="${detected_svcs[*]}"
fn_log "信息" "检测到: ${detected_svcs_str}。开始应用服务优化..."

for svc in "${detected_svcs[@]}"; do
    local conf_file="/etc/systemd/system/${svc}.service.d/90-vps_optimizert.conf"
    if [ -f "$conf_file" ]; then
        fn_log "调试" "配置文件 $conf_file 已存在，跳过 $svc。"
        continue
    fi
    
    fn_log "调试" "为 $svc 设置 RealTime 调度, Nice=-19, Limits."
    
    local svc_conf_dir="/etc/systemd/system/${svc}.service.d"
    mkdir -p "$svc_conf_dir"
    cat > "$conf_file" <<EOF
[Service]
# Extreme Performance Tuning
Nice=-19
CPUSchedulingPolicy=fifo
CPUSchedulingPriority=10
LimitNOFILE=1000000
LimitNPROC=1000000
EOF
    fn_log_action "CREATE_FILE" "$conf_file"
    changes_made=1
done

if [ "$changes_made" -eq 0 ]; then
     fn_log "信息" "网络代理服务均已配置，无需刷新。"
     return 2
fi

if [ "$changes_made" -eq 1 ]; then
    fn_log "调试" "重载 systemd daemon..."
    (systemctl daemon-reload) >> "$LOG_FILE" 2>&1
fi
fn_log "成功" "网络服务优化成功 (${detected_svcs_str})。"
return 0
}

fn_restore_all() {
    echo "[任务] 开始执行撤销优化..."
    fn_log "警告" "开始执行撤销优化... 将从 $ACTION_LOG 恢复。"

    local log_restored=false
    if [ -f "$ACTION_LOG" ] && [ $(grep -vc '^#' "$ACTION_LOG") -gt 0 ]; then
        echo "[成功] 检测到操作日志: $ACTION_LOG (共 $(grep -vc '^#' "$ACTION_LOG") 条操作)。将执行日志反向撤销..."
        fn_log "信息" "检测到有效操作日志，将执行反向撤销。"
        log_restored=true
    else
        echo "[失败] 未找到操作日志或日志为空: $ACTION_LOG。将仅使用备份文件和强制清理。"
        fn_log "错误" "未找到 $ACTION_LOG 或其为空，无法执行日志反向撤销。"
    fi

    echo "[任务]   正在停用 ZRAM 和 Swap..."
    (systemctl disable --now zramswap.service) >> "$LOG_FILE" 2>&1 || true
    swapoff -a >/dev/null 2>&1 || true
    modprobe -r zram >/dev/null 2>&1 || true
    
    if [ "$log_restored" = "true" ]; then
        tac "$ACTION_LOG" | while read -r line; do
            [ -z "$line" ] && continue
            [[ "$line" == \#* ]] && continue
            
            local action=$(echo "$line" | cut -d: -f1)
            local value=$(echo "$line" | cut -d: -f2-)

            case "$action" in
                MASK_SERVICE)
                    echo "[日志撤销] Unmasking $value"
                    fn_log "信息" "[日志撤销] Unmasking $value"
                    (systemctl unmask "$value") >> "$LOG_FILE" 2>&1 || true
                    ;;
                CREATE_FILE)
                    echo "[日志撤销] Removing file/dir $value"
                    fn_log "信息" "[日志撤销] Removing file/dir $value"
                    rm -rf "$value"
                    if [[ "$value" == *.service.d/*.conf ]]; then
                        rmdir "$(dirname "$value")" 2>/dev/null || true
                    fi
                    ;;
                INSTALL_PKG)
                    echo "[日志撤销] Purging package $value"
                    fn_log "信息" "[日志撤销] Purging package $value"
                    if [ ${#PKG_CMD_REMOVE[@]} -gt 0 ]; then
                        fn_wait_for_pkg_lock || fn_log "警告" "包管理器锁等待失败，跳过卸载 $value"
                        ("${PKG_CMD_REMOVE[@]}" "$value") >> "$LOG_FILE" 2>&1
                    fi
                    ;;
                UNINSTALL_PKG) 
                    echo "[日志撤销] Re-installing package $value"
                    fn_log "信息" "[日志撤销] Re-installing package $value"
                    if [ ${#PKG_CMD_INSTALL[@]} -gt 0 ]; then
                        fn_wait_for_pkg_lock || fn_log "警告" "包管理器锁等待失败，跳过安装 $value"
                        ("${PKG_CMD_INSTALL[@]}" "$value") >> "$LOG_FILE" 2>&1
                    fi
                    ;;
                MODIFY_FILE)
                    if [ -f "${value}.bak" ]; then
                        echo "[日志撤销] Restoring $value from ${value}.bak"
                        fn_log "信息" "[日志撤销] Restoring $value from ${value}.bak"
                        mv "${value}.bak" "$value" >> "$LOG_FILE" 2>&1
                    else
                        echo "[日志跳过] 未找到 ${value}.bak，无法恢复 $value"
                        fn_log "警告" "未找到 ${value}.bak，无法恢复 $value"
                    fi
                    ;;
                *)
                    fn_log "警告" "未知的撤销操作: $action"
                    ;;
            esac
        done
        
    fi

    echo "[任务]   正在恢复核心备份文件..."
    
    echo "[任务]     恢复 sysctl..."
    [ -f "${BACKUP_DIR}/sysctl.conf.bak" ] && cp -an "${BACKUP_DIR}/sysctl.conf.bak" /etc/sysctl.conf 2>/dev/null && fn_log "信息" "恢复 /etc/sysctl.conf" || true
    [ -d "${BACKUP_DIR}/sysctl.d.bak" ] && cp -ar "${BACKUP_DIR}/sysctl.d.bak" /etc/sysctl.d/ 2>/dev/null && fn_log "信息" "恢复 /etc/sysctl.d/" || true
    
    cat > /etc/sysctl.d/98-bbr-retention.conf <<'EOF'
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
EOF
    sysctl --system >/dev/null 2>/dev/null || true

    echo "[任务]     恢复 journald..."
    [ -d "${BACKUP_DIR}/journald.conf.d.bak" ] && rm -rf /etc/systemd/journald.conf.d/ && cp -ar "${BACKUP_DIR}/journald.conf.d.bak" /etc/systemd/journald.conf.d/ 2>/dev/null && fn_log "信息" "恢复 journald.conf.d" || true
    systemctl restart systemd-journald >/dev/null 2>/dev/null || true
    
    echo "[任务]     恢复 fstab..."
    [ -f "${BACKUP_DIR}/fstab.bak" ] && cp -an "${BACKUP_DIR}/fstab.bak" /etc/fstab 2>/dev/null && fn_log "信息" "恢复 /etc/fstab" || true
    
    echo "[任务]   正在执行强制配置清理 (确保无残留 vps_optimizert 配置)..."
    
    local files_to_clean=(
        "/etc/sysctl.d/99-vps_optimizert.conf"
        "/etc/apt/apt.conf.d/99-force-ipv4"
        "/etc/systemd/journald.conf.d/10-volatile.conf"
        "/etc/fail2ban/jail.d/99-vps_optimizert-systemd.conf"
        "/etc/default/zramswap"
        "/swapfile_zram"
    )
    
    for f in "${files_to_clean[@]}"; do
        if [ -f "$f" ]; then
            echo "[清理] 移除文件 $f"
            rm -f "$f"
            fn_log "信息" "[清理] 移除 $f"
        fi
    done

    echo "[任务]   正在清理网络服务 drop-in 配置..."
    find /etc/systemd/system/ -type d -name "*.service.d" 2>/dev/null | while read -r dropin_dir; do
        if [ -f "${dropin_dir}/90-vps_optimizert.conf" ]; then
            echo "[清理] 移除配置目录 $dropin_dir"
            rm -rf "$dropin_dir"
            fn_log "信息" "[清理] 移除网络服务配置目录 $dropin_dir"
        fi
    done
    
    echo "[任务]   正在恢复之前启用的服务 (来自 enabled_services.before.txt)..."
    if [ -f "${BACKUP_DIR}/enabled_services.before.txt" ]; then
        while read -r s; do 
            [ -z "$s" ] && continue
            (systemctl enable "$s") >> "$LOG_FILE" 2>&1 || true; 
        done < "${BACKUP_DIR}/enabled_services.before.txt"
    else
        echo "[跳过] 未找到 enabled_services.before.txt，跳过服务启用恢复。"
        fn_log "警告" "未找到 enabled_services.before.txt，跳过服务启用恢复。"
    fi

    (systemctl daemon-reload) >> "$LOG_FILE" 2>&1
    rm -f "$ACTION_LOG"
    
    echo "[完成] 撤销优化完成。"
    fn_log "成功" "撤销优化完成。"
}

fn_show_status_report() {
    if [ "${1:-}" != "noclear" ]; then
        clear
    fi
    
    echo "==================== 系统优化状态 ===================="
    [ -f /etc/os-release ] && source /etc/os-release
    printf "系统: %s\n" "${PRETTY_NAME:-unknown}"
    printf "内存: %s MB\n" "$MEM_MB"
    printf "内核: %s\n" "$(uname -r)"
    echo "------------------------------------------------------"

    fn_print_line() {
        local name="$1"
        local status="$2"
        local success_msg="$3"
        local fail_msg="$4"
        local details="${5:-}"
        local status_msg="$fail_msg"
        [ "$status" == "true" ] && status_msg="$success_msg"
        local details_str=""
        [ -n "$details" ] && details_str="$details"
        printf "  %-30s %-15s %s\n" "$name" "$status_msg" "$details_str"
    }

    local sysctl_conf_file="/etc/sysctl.d/99-vps_optimizert.conf"
    local sysctl_status="false"
    local bbr_status="false"
    [ -f "$sysctl_conf_file" ] && sysctl_status="true"
    
    if [ "$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null)" == "bbr" ] && \
       [ "$(sysctl -n net.core.default_qdisc 2>/dev/null)" == "fq" ]; then
        bbr_status="true"
    fi
    local bbr_details=""
    [ "$bbr_status" == "true" ] && bbr_details="(已启用BBR+FQ)"
    
    fn_print_line "网络调优 (BBR)" "$bbr_status" "[ 已启用 ]" "[ 未启用 ]" "$bbr_details"
    
    local swappiness_details=""
    [ "$sysctl_status" == "true" ] && swappiness_details="(当前: $(sysctl -n vm.swappiness 2>/dev/null))"
    fn_print_line "Swappiness (10)" "$sysctl_status" "[ 已优化 ]" "[ 未优化 ]" "$swappiness_details"

    local vfs_details=""
    [ "$sysctl_status" == "true" ] && vfs_details="(当前: $(sysctl -n vm.vfs_cache_pressure 2>/dev/null))"
    fn_print_line "VFS 缓存压力 (100)" "$sysctl_status" "[ 已优化 ]" "[ 未优化 ]" "$vfs_details"

    local ipv6_details=""
    if [ "$sysctl_status" == "true" ]; then
        if [ "$(sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null)" == "1" ]; then
            ipv6_details="(已禁用)"
        else
            ipv6_details="(当前: $(sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null))"
        fi
    fi
    fn_print_line "禁用IPv6" "$sysctl_status" "[ 已优化 ]" "[ 未优化 ]" "$ipv6_details"


    local selinux_line="SELinux"
    local selinux_status="false"
    local selinux_details="(未检测到)"
    if command -v getenforce >/dev/null 2>&1; then
        local selinux_state
        selinux_state=$(getenforce)
        if [ "$selinux_state" == "Disabled" ]; then
            selinux_status="true"
            selinux_details="(已禁用)"
        else
            selinux_status="false"
            selinux_details="(状态: $selinux_state)"
        fi
    else
        selinux_status="false"
        selinux_details="(未检测到)"
    fi
    fn_print_line "$selinux_line" "$selinux_status" "[ 已优化 ]" "[ 未优化 ]" "$selinux_details"

    local f2b_line="Fail2ban"
    local f2b_status="false"
    local f2b_success_msg="[ 已优化 ]"
    local f2b_fail_msg="[ 未激活 ]"
    local f2b_details="(未安装)"
    if systemctl is-active fail2ban >/dev/null 2>&1; then
        f2b_status="true"
        f2b_details="(已激活)"
    elif "${PKG_CMD_CHECK[@]}" fail2ban >/dev/null 2>&1; then
        f2b_status="false"
        f2b_details="(已安装/未运行)"
    fi
    fn_print_line "$f2b_line" "$f2b_status" "$f2b_success_msg" "$f2b_fail_msg" "$f2b_details"

    local journal_storage
    journal_storage=$(systemd-analyze cat-config systemd/journald.conf | grep -i '^Storage=' | tail -n 1 | cut -d= -f2 2>/dev/null || echo "disk")
    local journal_status="false"
    local journal_details="(模式: ${journal_storage:-disk})"
    if [ -f /etc/systemd/journald.conf.d/10-volatile.conf ] && [ "$journal_storage" == "volatile" ]; then
        journal_status="true"
        journal_details="(模式: 仅内存, 上限: 16M)"
    elif [ "$journal_storage" == "volatile" ]; then
        journal_status="true"
        journal_details="(模式: 仅内存, 未知配置)"
    fi
    fn_print_line "Journald 日志存储模式" "$journal_status" "[ 已优化 ]" "[ 未优化 ]" "$journal_details"

    local masked_count=0
    local services_to_check=("${FN_TRIM_SERVICES_LIST[@]}" "rsyslog.service")
    
    for svc in "${services_to_check[@]}"; do
        local svc_status
        svc_status=$(systemctl is-enabled "$svc" 2>/dev/null || echo "not-found")
        if [[ "$svc_status" == *"masked"* ]]; then
            masked_count=$((masked_count + 1))
        fi
    done
    local trim_status="false"
    local trim_details="(未屏蔽服务)"
    if [ "$masked_count" -gt 0 ]; then
        trim_status="true"
        trim_details="(已屏蔽 $masked_count 个服务)"
    fi
    fn_print_line "系统服务精简" "$trim_status" "[ 已优化 ]" "[ 未优化 ]" "$trim_details"

    local zram_status="false"
    local zram_details="(未激活)"
    
    if systemctl is-active zramswap.service >/dev/null 2>&1 && swapon -s | grep -q 'zram'; then
        zram_status="true"
        local free_swap_line
        free_swap_line=$(free -h --si | grep '^Swap:')
        local swap_total
        swap_total=$(echo "$free_swap_line" | awk '{print $2}')
        local swap_used
        swap_used=$(echo "$free_swap_line" | awk '{print $3}')
        zram_details="(已激活 ZRAM: $swap_total, 已用: $swap_used)"
    elif swapon -s | grep -q 'swapfile_zram'; then
        zram_status="true"
        local free_swap_line
        free_swap_line=$(free -h --si | grep '^Swap:')
        local swap_total
        swap_total=$(echo "$free_swap_line" | awk '{print $2}')
        local swap_used
        swap_used=$(echo "$free_swap_line" | awk '{print $3}')
        zram_details="(已激活 Swapfile: $swap_total, 已用: $swap_used)"
    fi
    fn_print_line "ZRAM/Swap" "$zram_status" "[ 已优化 ]" "[ 未激活 ]" "$zram_details"

    
    local found_names=()
    for pattern in "${FN_NETWORK_SERVICES_LIST[@]}"; do
        while read -r service_file; do
            [ -z "$service_file" ] && continue
            local base_name="${service_file%.service}" 
            found_names+=("$base_name")
        done < <(systemctl list-unit-files --type=service --no-legend "${pattern}.service" 2>/dev/null | awk '{print $1}')
    done
    local detected_svcs=()
    mapfile -t detected_svcs < <(printf "%s\n" "${found_names[@]}" | sort -u)

    local drop_in_found=()
    for svc in "${detected_svcs[@]}"; do 
        if [ -f "/etc/systemd/system/${svc}.service.d/90-vps_optimizert.conf" ]; then
            drop_in_found+=("$svc")
        fi
    done
    
    local net_prio_status="false"
    local net_prio_details="(未检测到网络代理服务)"
    
    if [ ${#detected_svcs[@]} -gt 0 ]; then
        if [ ${#drop_in_found[@]} -gt 0 ]; then
            net_prio_status="true"
            local IFS=','
            net_prio_details="(已配置: ${drop_in_found[*]})"
        else
            net_prio_status="false"
            local IFS=','
            net_prio_details="(检测到: ${detected_svcs[*]}; 未配置)"
        fi
    fi
    
    fn_print_line "网络服务优化" "$net_prio_status" "[ 已配置 ]" "[ 未优化 ]" "$net_prio_details"

    echo "======================================================"
}

fn_tune_network_interface() {
    fn_log "信息" "正在优化网络接口队列长度..."
    local default_iface
    default_iface=$(ip route | grep default | awk '{print $5}' | head -n1)
    
    if [ -z "$default_iface" ]; then
        fn_log "警告" "无法检测到默认网络接口，跳过接口优化。"
        return 2
    fi
    
    fn_log "信息" "检测到默认接口: $default_iface"
    
    # Set txqueuelen
    if ip link set dev "$default_iface" txqueuelen 10000; then
        fn_log "成功" "已设置 $default_iface txqueuelen = 10000"
    else
        fn_log "警告" "设置 $default_iface txqueuelen 失败。"
    fi
    
    # Optional: Disable offloading if ethtool exists (often helps with virtualization latency)
    if command -v ethtool >/dev/null 2>&1; then
        ethtool -K "$default_iface" gso off gro off >/dev/null 2>&1 || true
        fn_log "信息" "尝试禁用 GSO/GRO (ethtool)。"
    fi
    
    return 0
}

fn_set_system_limits() {
    fn_log "信息" "设置系统级资源限制 (limits.conf)..."
    local limits_file="/etc/security/limits.conf"
    
    if grep -q "vps_optimizert" "$limits_file"; then
        fn_log "信息" "limits.conf 已包含优化配置，跳过。"
        return 2
    fi
    
    cp "$limits_file" "${BACKUP_DIR}/limits.conf.bak" 2>/dev/null || true
    
    cat >> "$limits_file" <<EOF

# Added by vps_optimizert
* soft nofile 1000000
* hard nofile 1000000
* soft nproc 1000000
* hard nproc 1000000
root soft nofile 1000000
root hard nofile 1000000
root soft nproc 1000000
root hard nproc 1000000
EOF
    fn_log_action "MODIFY_FILE" "$limits_file"
    fn_log "成功" "已更新 /etc/security/limits.conf"
    return 0
}

fn_optimize_auto() {
    local result
    
    if fn_check_if_optimized; then
        echo "-----------------------------------------------------"
        echo "[错误] 检测到系统已被优化。"
        echo "操作日志: $ACTION_LOG (已包含内容)"
        echo ""
        echo "为防止覆盖现有配置和日志，操作已停止。"
        echo " * 如果您想重新优化，请先运行 [选项 2] 撤销优化。"
        echo "-----------------------------------------------------"
        fn_log "错误" "检测到已优化，fn_optimize_auto 已停止。"
        return 1
    fi

    echo "[任务 1 ] ：创建备份文件..."
    result=0
    fn_backup_state || result=$?
    if [ $result -ne 0 ]; then
        echo "[失败] 备份文件创建失败，退出优化。"
        fn_log "错误" "fn_backup_state 失败，退出。"
        return 1
    fi
    echo "[完成] 备份文件创建成功: $BACKUP_DIR"
    echo "--------------"
    
    echo "[任务 2 ] ：检查包管理器源..."
    result=0
    fn_fix_apt_sources_if_needed || result=$?
    if [ $result -ne 0 ]; then
        echo "[失败] 包管理器源检查失败。请检查日志。"
        fn_log "错误" "fn_fix_apt_sources_if_needed 失败。"
    else
        echo "[完成] 包管理器源检查通过。"
    fi
    echo "--------------"

    echo "[任务 3 ] ：检查 SELinux 状态..."
    result=0
    fn_handle_selinux || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] SELinux 检查完成 (已操作)。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] SELinux 状态良好或未检测到。"
    fi
    echo "--------------"
    
    echo "[任务 4 ] ：配置 Journald (日志)..."
    result=0
    fn_setup_journald_volatile || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] Journald 已配置为内存模式。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 检测到已优化，跳过。"
    fi
    echo "--------------"

    echo "[任务 5 ] ：应用 sysctl 极限网络调优..."
    result=0
    fn_setup_sysctl_extreme || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] sysctl (BBR+FQ+UDP) 极限配置文件已创建并应用。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 检测到已优化，跳过。"
    fi
    echo "--------------"

    echo "[任务 5.1 ] ：优化网络接口..."
    result=0
    fn_tune_network_interface || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 网络接口队列已优化。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 无法检测接口或已优化。"
    fi
    echo "--------------"

    echo "[任务 5.2 ] ：设置系统资源限制..."
    result=0
    fn_set_system_limits || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 系统资源限制 (limits.conf) 已更新。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 已存在配置，跳过。"
    fi
    echo "--------------"

    echo "[任务 6 ] ：配置 ZRAM..."
    result=0
    fn_setup_zram_adaptive || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] ZRAM 配置成功。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 检测到已优化，跳过。"
    else
        echo "[警告] ZRAM 配置失败，已启用 swapfile 回退。"
    fi
    echo "--------------"

    echo "[任务 7 ] ：配置 Fail2ban..."
    result=0
    fn_setup_fail2ban || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] Fail2ban 配置成功。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 检测到已优化，跳过。"
    else
        echo "[警告] Fail2ban 配置失败。请检查日志。"
    fi
    echo "--------------"

    echo "[任务 8 ] ：优化网络代理服务..."
    result=0
    fn_prioritize_network_services_auto || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 网络代理服务优化完成。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 未检测到服务或服务均已配置。"
    fi
    echo "--------------"
    
    echo "[任务 9 ] ：精简系统服务..."
    result=0
    fn_trim_services_auto || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 系统服务精简完成。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 未检测到需要新屏蔽的服务。"
    fi
    echo "--------------"
    
    echo ""
    echo "系统优化完成。请重启系统以完全生效。"
    fn_log "成功" "系统优化完成。请重启系统以完全生效。"
    fn_show_status_report "noclear"
}

fn_get_detected_services_string() {
    local detected_svcs=()
    for svc in "${FN_NETWORK_SERVICES_LIST[@]}"; do
        if systemctl list-unit-files --quiet "${svc}.service"; then
            detected_svcs+=("$svc")
        fi
    done
    
    if [ ${#detected_svcs[@]} -gt 0 ]; then
        local IFS=','
        echo " (检测到: ${detected_svcs[*]})"
    else
        echo ""
    fi
}

fn_show_menu() {
    clear
    
    echo "==============================================="
    echo " VPS 自动优化脚本 (vps_optimizert)"
    echo " 版本: $SCRIPT_VERSION"
    echo " 备份目录: $BACKUP_DIR"
    echo " 日志文件: $LOG_FILE"
    echo "==============================================="
    echo " 1) 执行系统优化 (全自动)"
    echo " 2) 撤销优化 (保留BBR)"
    echo " 3) 优化网络代理服务"
    echo " 4) 显示系统优化状态"
    echo " 0) 退出"
    echo "===============================================
"
    read -rp "请选择: " CH || true
    case "$CH" in
        1) 
            fn_optimize_auto || true 
            read -rp "按回车返回主菜单..." dummy || true
            ;;
        2) 
            fn_restore_all || true 
            read -rp "撤销完成。按回车返回主菜单..." dummy || true
            ;;
        3)
            echo "[任务] 正在优化网络代理服务..."
            result=0
            fn_prioritize_network_services_auto || result=$?
            if [ $result -eq 0 ]; then
                echo "[完成] 优化完成。"
            elif [ $result -eq 2 ]; then
                echo "[跳过] 未检测到服务或服务均已配置。"
            fi
            read -rp "按回车返回菜单..." dummy || true
            ;;
        4)
            fn_show_status_report
            read -rp "按回车返回菜单..." dummy || true 
            ;;
        0) 
            echo "退出。"
            fn_log "信息" "退出。"; exit 0 
            ;;
        *) 
            echo "错误: 无效选项。"
            fn_log "错误" "无效选项。"; sleep 1;
            ;;
    esac
    fn_show_menu
}

fn_check_root
fn_detect_os

fn_show_menu
