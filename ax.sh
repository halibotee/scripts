#!/bin/bash
# X-ray（Vless、SS）、Hysteria2, UDP2RAW 、 KCPTUN 实例管理脚本
# wget --no-check-certificate -O ax.sh "https://raw.githubusercontent.com/halibotee/scripts/main/ax.sh" && chmod +x ax.sh && ./ax.sh
# Generated by Halibotee

# --- 1. 核心全局变量与脚本版本 ---
SCRIPT_VERSION="7.0.0" # 脚本版本号
KCP_UDP_INSTALL_DIR="/etc/kcptun-udp2raw" # KCPTUN 和 UDP2RAW 的安装目录
HY2_INSTALL_DIR="/etc/hysteria2"         # Hysteria2 的安装目录
XRAY_INSTALL_DIR="/etc/xray"             # Xray 的安装目录
XRAY_SERVICE_NAME="ax_xray"              # Xray 服务的唯一名称，避免冲突

# --- 2. Systemd 模板文件路径 ---
KCPTUN_TEMPLATE_FILE="/etc/systemd/system/kcptun@.service"
UDP2RAW_TEMPLATE_FILE="/etc/systemd/system/udp2raw@.service"
HY2_TEMPLATE_FILE="/etc/systemd/system/hysteria2@.service"
XRAY_TEMPLATE_FILE="/etc/systemd/system/${XRAY_SERVICE_NAME}@.service"

# --- 3. 网络与服务默认配置 ---
PUBLIC_IP=""                     # 存储获取到的公网 IP，留空自动获取
DEFAULT_LISTEN_ADDR="0.0.0.0"    # 默认的全局监听地址
DEFAULT_TARGET_ADDR="127.0.0.1"  # KCP/UDP 默认的目标(回环)地址
RANDOM_PORT_MIN=10000            # 随机端口的最小值
RANDOM_PORT_MAX=65535            # 随机端口的最大值
PUBLIC_IP_SERVICE_1="ip.sb"      # 获取公网 IP 的首选服务
PUBLIC_IP_SERVICE_2="ipinfo.io/ip" # 获取公网 IP 的备选服务

# --- 4. Hysteria2 (HY2) 专属配置 ---
HY2_SNI="bing.com" # Hysteria2 使用的 SNI (用于自签名证书和客户端)
HY2_CERT_PATH="/etc/ssl/private/${HY2_SNI}.crt" # 证书路径
HY2_KEY_PATH="/etc/ssl/private/${HY2_SNI}.key"  # 密钥路径
HY2_MASQUERADE_URL="https://www.bing.com"   # 伪装流量的目标 URL
HY2_CLIENT_INSECURE="1" # Hysteria2 客户端是否跳过证书验证 (1为是)

# --- 5. Xray VLESS 专属配置 ---
XRAY_REALITY_DEFAULT_SNI="www.apple.com" # VLESS+Reality 默认 SNI
XRAY_REALITY_DEFAULT_FP="chrome"       # VLESS+Reality 默认指纹
XRAY_REALITY_DEFAULT_TARGET="www.apple.com:443" # VLESS+Reality 默认回落目标
XRAY_REALITY_DEFAULT_FLOW="xtls-rprx-vision" # VLESS+Reality 默认 flow
KCPTUN_DEFAULT_MODE="fast3"      # KCPTUN 默认的加速模式
SS_DEFAULT_METHOD="2022-blake3-aes-256-gcm" # Shadowsocks 默认加密方式

# --- 6. WARP 分流配置 ---
DEFAULT_WARP_SOCKS_ADDR="127.0.0.1" # WARP SOCKS5 服务的默认监听地址
DEFAULT_WARP_SOCKS_PORT="40000"   # WARP SOCKS5 服务的默认端口
WARP_GEOSITE_LIST_JSON='"geosite:google", "geosite:openai", "geosite:perplexity","ip-api.com"'
WARP_GEOSITE_LIST_YAML='- warp(suffix:ip-api.com)
    - warp(geosite:google)
    - warp(geoip:google)
    - warp(suffix:google.com)
    - warp(geosite:openai)
    - warp(suffix:openai.com)
    - warp(suffix:chatgpt.com)
    - warp(geosite:perplexity)
    - warp(suffix:perplexity.com)'

# --- 7. Github 软件源配置 ---
KCPTUN_REPO="xtaci/kcptun"
UDP2RAW_REPO="wangyu-/udp2raw"
HY2_REPO="apernet/hysteria"
XRAY_REPO="XTLS/Xray-core"
GITHUB_API_URL="https://api.github.com/repos"
GITHUB_URL="https://github.com"

# --- 8. 客户端默认参数配置 ---
CLIENT_KCPTUN_LISTEN_ADDR="127.0.0.1:1091"
CLIENT_UDP2RAW_LISTEN_ADDR="127.0.0.1:1093"
CLIENT_VLESS_UDP2RAW_LISTEN_ADDR="127.0.0.1:1094"
# [NEW] 3-Chain SS+KCP+UDP 客户端本地端口
CLIENT_SS_3_CHAIN_KCP_TARGET="127.0.0.1:1095" # KCP 目标 (UDP2RAW 监听)
CLIENT_SS_3_CHAIN_SS_TARGET="127.0.0.1:1096"  # SS 目标 (KCP 监听)

UDP2RAW_COMMON_ARGS="--raw-mode faketcp --cipher-mode xor --auth-mode crc32 --seq-mode 4 -a --keep-rule --fifo --fix-gro"
UDP2RAW_CLIENT_BASE_ARGS="-c ${UDP2RAW_COMMON_ARGS}"

# --- 9. 配置文件模板 (JSON / YAML / CONF) ---

# KCPTUN_CONFIG 模板
read -r -d '' KCPTUN_CONFIG_JSON_TEMPLATE <<'EOM'
{
    "listen": "__LISTEN__", "target": "__TARGET__", "key": "__KEY__", "crypt": "aes-128", "mode": "__MODE__", "smuxver": 2, "mtu": 1350, "sndwnd": 256, "rcvwnd": 2048, "datashard": 10, "parityshard": 3, "dscp": 46, "nocomp": true, "acknodelay": false, "nodelay": 1, "interval": 20, "resend": 2, "nc": 1, "sockbuf": 16777217, "smuxbuf": 16777217, "streambuf": 4194304, "keepalive": 5, "autoexpire": 600, "quiet": false, "tcp": false
}
EOM

# UDP2RAW Config 模板 
read -r -d '' UDP2RAW_CONFIG_TEMPLATE <<'EOM'
-s
-l __LISTEN_ADDR__
-r __TARGET_ADDR__
-k __PASSWORD__
--raw-mode faketcp
--cipher-mode xor
--auth-mode crc32
--seq-mode 4
-a
--keep-rule
--fifo
--fix-gro
EOM

# HYSTERIA2 CONFIG 模板
read -r -d '' HYSTERIA2_CONFIG_YAML_TEMPLATE <<'EOM'
listen: __LISTEN__
tls:
  cert: __CERT_PATH__
  key: __KEY_PATH__
auth:
  type: password
  password: __PASSWORD__
masquerade:
  type: proxy
  proxy:
    url: __MASQUERADE_URL__
    rewriteHost: true
ignoreClientBandwidth: true
sniff:
  enable: true
  timeout: 2s
  rewriteDomain: true
  tcpPorts: 80,443,8000-9000
  __UDP_SNIFF_CONFIG__
__OUTBOUNDS_AND_ACL__
EOM

# Hysteria2 WARP 分流模板 
read -r -d '' HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK <<'EOM'
outbounds:
  - name: warp
    type: socks5
    socks5:
      addr: __WARP_SOCKS5_ADDR__
      udp: false
acl:
  inline:
    __WARP_GEOSITE_LIST_YAML__
    - direct(all)
EOM
HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_GEOSITE_LIST_YAML__/$WARP_GEOSITE_LIST_YAML}"

# Hysteria2 直连模板
read -r -d '' HYSTERIA2_DIRECT_ACL_BLOCK <<'EOM'
acl:
  inline:
    - direct(all)
EOM

# Xray VLESS+Reality 模板
read -r -d '' XRAY_VLESS_REALITY_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [
        {
            "listen": null,
            "port": __LISTEN_PORT__,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "__UUID__",
                        "flow": "__REALITY_FLOW__"
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "fingerprint": "__FINGERPRINT__",
                    "target": "__TARGET__",
                    "xver": 0,
                    "serverNames": [
                        "__SNI__"
                    ],
                    "privateKey": "__PRIVATE_KEY__",
                    "publicKey": "__PUBLIC_KEY__",
                    "minClientVer": "",
                    "maxClientVer": "",
                    "maxTimeDiff": 60000,
                    "shortIds": [
                        "__SHORT_ID__"
                    ]
                },
                "tcpSettings": {
                    "header": {
                        "type": "none"
                    }
                }
            },
            "tag": "inbound-__LISTEN_PORT__",
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls",
                    "quic"
                ]
            }
        }
    ],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# Xray VLESS+mKCP 模板
read -r -d '' XRAY_VLESS_MKCP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "vless",
        "settings": {
            "clients": [{ "id": "__UUID__" }],
            "decryption": "none"
        },
        "streamSettings": {
            "network": "kcp",
            "kcpSettings": {
                "mtu": 1200, "tti": 30, "uplinkCapacity": 25, "downlinkCapacity": 100, "congestion": true, "readBufferSize": 4, "writeBufferSize": 4,
                "header": { "type": "wechat-video" },
                "seed": "__MKCP_SEED__"
            }
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# [NEW] Xray Shadowsocks (TCP/UDP) 模板 (用于 KCPTUN / UDP2RAW 串联)
read -r -d '' XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "shadowsocks",
        "settings": {
            "method": "__SS_METHOD__",
            "password": "__SS_PASSWORD__",
            "network": "tcp,udp"
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# Xray WARP 分流模板
read -r -d '' XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "socks", "tag": "warp", "settings": { "servers": [{ "address": "__WARP_SOCKS5_ADDR__", "port": __WARP_SOCKS5_PORT__ }] } },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
        { "type": "field", "outboundTag": "warp", "domain": [ __WARP_GEOSITE_LIST_JSON__ ] },
        { "type": "field", "outboundTag": "block", "domain": [ "geosite:category-ads-all" ] }
    ]
}
EOM
XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK="${XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK//__WARP_GEOSITE_LIST_JSON__/$WARP_GEOSITE_LIST_JSON}"

# Xray 直连模板
read -r -d '' XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": { "rules": [ { "type": "field", "outboundTag": "direct", "network": "tcp,udp" } ] }
EOM


# --- 10. 辅助工具函数 (颜色、日志、检查等) ---

# 绿色
green(){ echo -e "\033[0;32m$1\033[0m"; }
# 红色
red(){ echo -e "\033[0;31m$1\033[0m"; }
# 黄色 (橙色)
yellow(){ echo -e "\033[0;33m$1\033[0m"; }
# 青色
cyan(){ echo -e "\033[0;36m$1\033[0m"; }
# 粗体 (默认色)
bold(){ echo -e "\033[1m$1\033[0m"; }
# 淡化 (灰色)
dim(){ echo -e "\033[2m$1\033[0m"; }
# 日志格式
log(){ echo -e "[$(date '+%H:%M:%S')] $(bold "$1")"; }
# 检查是否已安装任何实例
is_installed(){ ls "$KCP_UDP_INSTALL_DIR"/*.{conf,json} >/dev/null 2>&1 || ls "$HY2_INSTALL_DIR"/*.yaml >/dev/null 2>&1 || ls "$XRAY_INSTALL_DIR"/*.json >/dev/null 2>&1; }

# 获取公网 IP 地址
get_public_ip() {
    if [[ -n "$PUBLIC_IP" ]]; then echo "$PUBLIC_IP"; return; fi
    PUBLIC_IP=$(curl -s4m2 $PUBLIC_IP_SERVICE_1 || curl -s4m2 $PUBLIC_IP_SERVICE_2)
    if [[ -z "$PUBLIC_IP" ]]; then PUBLIC_IP="127.0.0.1"; yellow "获取公网 IP 失败，将使用 127.0.0.1 作为备用。" >&2; fi
    echo "$PUBLIC_IP"
}

# 安装脚本所需的核心依赖
install_dependencies(){
    local packages_to_install=()
    ! command -v curl &>/dev/null && packages_to_install+=("curl")
    ! command -v wget &>/dev/null && packages_to_install+=("wget")
    ! command -v tar &>/dev/null && packages_to_install+=("tar")
    ! command -v unzip &>/dev/null && packages_to_install+=("unzip")
    ! command -v nano &>/dev/null && packages_to_install+=("nano")
    ! command -v iptables &>/dev/null && packages_to_install+=("iptables")
    ! command -v uuidgen &>/dev/null && packages_to_install+=("uuid-runtime")
    ! command -v openssl &>/dev/null && packages_to_install+=("openssl")
    ! command -v jq &>/dev/null && packages_to_install+=("jq")
    if [ ${#packages_to_install[@]} -gt 0 ]; then
        log "更新软件包列表并安装核心依赖: ${packages_to_install[*]}..."
        (apt-get update && apt-get install -y "${packages_to_install[@]}") >/dev/null 2>&1
    fi
}

# 带重试功能的下载函数
download_with_retry(){
    local url=$1 output=$2 retries=3 timeout=15
    for ((i=1; i<=retries; i++)); do
        log "下载 ($i/$retries)：$url"
        curl -L --connect-timeout 5 --max-time $timeout -o "$output" "$url" && return 0
        yellow "下载失败，正在重试..."
    done
    red "下载失败超过 $retries 次，请检查网络。"
    return 1
}

# 查找一个未被占用的随机端口
find_available_port() {
    local port
    while true; do
        port=$(( RANDOM % (RANDOM_PORT_MAX - RANDOM_PORT_MIN + 1) + RANDOM_PORT_MIN ))
        ! ss -tuln | grep -q ":${port} " && echo "$port" && return
    done
}

# 生成强密码 (UUID)
generate_strong_password() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    else
        log "uuidgen 未找到，生成备用 UUID..." >&2
        hexdump -n 16 -v -e '4/4 "%08x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 6/6 "%012x"' /dev/urandom | head -c 36
    fi
}

# 生成 Hysteria2 所需的自签名证书
generate_self_signed_cert() {
    if [[ -s "$HY2_CERT_PATH" && -s "$HY2_KEY_PATH" ]]; then return; fi
    log "正在为 ${HY2_SNI} 生成自签名证书..."
    mkdir -p "$(dirname "$HY2_KEY_PATH")"
    openssl ecparam -name prime256v1 -genkey -noout -out "$HY2_KEY_PATH"
    chmod 600 "$HY2_KEY_PATH"
    if [[ $? -ne 0 ]]; then red "错误: openssl ecparam 命令执行失败。"; exit 1; fi
    openssl req -new -x509 -days 36500 -key "$HY2_KEY_PATH" -out "$HY2_CERT_PATH" -subj "/CN=${HY2_SNI}" -nodes
    if [[ $? -ne 0 ]]; then red "错误: openssl req 命令执行失败。"; exit 1; fi
    if [[ ! -s "$HY2_CERT_PATH" || ! -s "$HY2_KEY_PATH" ]]; then red "错误: 证书文件生成失败或为空！"; exit 1; fi
    green "证书生成完毕。"
}

# 处理密码输入，支持自动生成和保存上次输入
handle_password_input() {
    local service_type=$1; local pass_file; local last_pass=""
    case "$service_type" in
        kcptun|udp2raw) mkdir -p "$KCP_UDP_INSTALL_DIR"; pass_file="$KCP_UDP_INSTALL_DIR/last_${service_type}_pass.txt" ;;
        hysteria2) mkdir -p "$HY2_INSTALL_DIR"; pass_file="$HY2_INSTALL_DIR/last_hy2_pass.txt" ;;
        xray_mkcp) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_xray_mkcp_seed.txt" ;;
        shadowsocks) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_ss_pass.txt" ;;
    esac
    if [[ -f "$pass_file" ]]; then last_pass=$(cat "$pass_file"); fi
    local display_pass=${last_pass:-"无"}
    local prompt_text="请输入密码"

    # [新] 为 SS-2022 提供特定提示
    if [[ "$service_type" == "shadowsocks" ]]; then
         yellow "注意: SS-2022 (如 $SS_DEFAULT_METHOD) 必须使用 Base64 密钥。" >&2
         prompt_text="请输入 Base64 密钥"
    elif [[ "$service_type" == "xray_mkcp" ]]; then
         prompt_text="请输入 mKCP Seed"
    fi

    read -p "${prompt_text} (原有: ${display_pass}, 回车自动生成): " password

    if [[ -z "$password" ]]; then
        # [新] 修正 SS-2022 自动生成逻辑
        if [[ "$service_type" == "shadowsocks" ]]; then
            # SS-2022 requires specific key length
            local key_length=32 # 默认 32 字节 (用于 256-gcm)
            if [[ "$SS_DEFAULT_METHOD" == *"128-gcm"* ]]; then
                key_length=16 # 16 字节 (用于 128-gcm)
            fi
            
            if ! command -v openssl &>/dev/null; then
                red "错误: openssl 命令未找到，无法生成 SS-2022 密钥！" >&2
                return 1
            fi
            password=$(openssl rand -base64 $key_length)
            green "已为您自动生成 SS-2022 Base64 密钥: $password" >&2
        else
            # [原] 其他服务的逻辑
            password=$(generate_strong_password)
            green "已为您自动生成随机密码: $password" >&2
        fi
    else
        # [新] 警告手动输入的 SS-2022 密码
        if [[ "$service_type" == "shadowsocks" ]]; then
            yellow "警告: 已使用您输入的 '$password'。" >&2
            yellow "如果 Xray 启动失败，请检查这是否是有效的 Base64 密钥。" >&2
        fi
    fi

    echo "$password" > "$pass_file"
    chmod 600 "$pass_file" # [新] 增加文件权限保护
    echo "$password"
}

# 查找下一个可用的实例 ID (数字)
find_next_available_id() {
    local type=$1; local dir file_prefix file_ext; local i=1
    case "$type" in
        hysteria2) dir="$HY2_INSTALL_DIR"; file_prefix="hy2"; file_ext="yaml";;
        udp2raw) dir="$KCP_UDP_INSTALL_DIR"; file_prefix="udp2raw"; file_ext="conf";;
        kcptun) dir="$KCP_UDP_INSTALL_DIR"; file_prefix="kcptun"; file_ext="json";;
        xray) dir="$XRAY_INSTALL_DIR"; file_prefix="xray"; file_ext="json";;
    esac
    while true; do
        if [[ ! -f "$dir/${file_prefix}_${i}.${file_ext}" && ! -f "$dir/${file_prefix}_c${i}.${file_ext}" && ! -f "$dir/${file_prefix}_vc${i}.${file_ext}" && ! -f "$dir/${file_prefix}_s3c${i}.${file_ext}" ]]; then
            echo "$i"; return
        fi
        i=$((i + 1))
    done
}

# --- 11. 核心程序下载函数 (REFACTORED: 移除 /bin 子目录) ---

# 从 Github API 获取最新版本标签
# get_latest_github_tag() {
#    local repo_name=$1
#    curl -s "$GITHUB_API_URL/$repo_name/releases/latest" | grep '"tag_name":' | head -1 | cut -d '"' -f 4
# }

get_latest_github_tag() {
    local repo_name=$1
    # 使用 jq -r .tag_name 来安全、准确地获取标签名
    curl -s "$GITHUB_API_URL/$repo_name/releases/latest" | jq -r .tag_name
}


# 下载 KCPTUN 和 UDP2RAW (REFACTORED: 安装到根目录)
download_kcp_udp_binaries(){
    KCPTUN_LATEST=$(get_latest_github_tag "$KCPTUN_REPO")
    UDP2RAW_LATEST=$(get_latest_github_tag "$UDP2RAW_REPO")
    if [[ -z "$KCPTUN_LATEST" || -z "$UDP2RAW_LATEST" ]]; then red "获取 KCPTUN/UDP2RAW 版本号失败。"; return 1; fi
    mkdir -p "$KCP_UDP_INSTALL_DIR"
    log "下载 KCPTUN ($KCPTUN_LATEST)..."
    download_with_retry "$GITHUB_URL/$KCPTUN_REPO/releases/download/${KCPTUN_LATEST}/kcptun-linux-amd64-$(echo $KCPTUN_LATEST | sed 's/v//').tar.gz" /tmp/kcptun.tar.gz && \
    tar -xzf /tmp/kcptun.tar.gz -C "$KCP_UDP_INSTALL_DIR" server_linux_amd64 && mv "$KCP_UDP_INSTALL_DIR/server_linux_amd64" "$KCP_UDP_INSTALL_DIR/kcptun_server" || { red "KCPTUN 解压或移动失败。"; return 1; }
    log "下载 UDP2RAW ($UDP2RAW_LATEST)..."
    download_with_retry "$GITHUB_URL/$UDP2RAW_REPO/releases/download/${UDP2RAW_LATEST}/udp2raw_binaries.tar.gz" /tmp/udp2raw.tar.gz && \
    tar -xzf /tmp/udp2raw.tar.gz -C "$KCP_UDP_INSTALL_DIR" udp2raw_amd64 && mv "$KCP_UDP_INSTALL_DIR/udp2raw_amd64" "$KCP_UDP_INSTALL_DIR/udp2raw" || { red "UDP2RAW 解压或移动失败。"; return 1; }
    chmod +x "$KCP_UDP_INSTALL_DIR/kcptun_server" "$KCP_UDP_INSTALL_DIR/udp2raw"
}

# 下载 Hysteria2 (REFACTORED: 安装到根目录)
download_hysteria2_binary(){
    HY2_LATEST=$(get_latest_github_tag "$HY2_REPO")
    if [[ -z "$HY2_LATEST" ]]; then red "获取 Hysteria2 版本号失败。"; return 1; fi
    mkdir -p "$HY2_INSTALL_DIR"
    log "下载 Hysteria2 ($HY2_LATEST)..."
    local hy2_url="$GITHUB_URL/$HY2_REPO/releases/download/${HY2_LATEST}/hysteria-linux-amd64"
    download_with_retry "$hy2_url" "$HY2_INSTALL_DIR/hysteria" || { red "Hysteria2 下载失败。"; return 1; }
    chmod +x "$HY2_INSTALL_DIR/hysteria"
}

# 下载 Xray-core (REFACTORED: 安装到根目录, 增加 dat 文件权限)
download_xray_binary(){
    XRAY_LATEST=$(get_latest_github_tag "$XRAY_REPO")
    if [[ -z "$XRAY_LATEST" ]]; then red "获取 Xray-core 版本号失败。"; return 1; fi
    mkdir -p "$XRAY_INSTALL_DIR"
    log "下载 Xray-core ($XRAY_LATEST)..."
    local xray_url="$GITHUB_URL/$XRAY_REPO/releases/download/${XRAY_LATEST}/Xray-linux-64.zip"
    download_with_retry "$xray_url" /tmp/xray.zip || { red "Xray-core 下载失败。"; return 1; }
    unzip -o /tmp/xray.zip -d "$XRAY_INSTALL_DIR" xray geoip.dat geosite.dat || { red "Xray-core 解压失败。"; return 1; }
    chmod +x "$XRAY_INSTALL_DIR/xray"
    
    # [REFACTORED] 复制 geo dat 文件到 Hysteria2 根目录
    log "正在复制 geoip.dat / geosite.dat 到 Hysteria2 目录..."
    # 使用 -n (no-clobber) 选项，确保只在目标文件不存在时才复制
    cp -n "$XRAY_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    cp -n "$XRAY_INSTALL_DIR/geosite.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    # [NEW] 确保 Hysteria2 可以读取 .dat 文件
    chmod 644 "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat" 2>/dev/null
}

# --- 12. Systemd 与服务状态管理 (REFACTORED: 修复 ExecStart 路径) ---

# 确保所有 Systemd 模板文件都存在
ensure_template_files() {
    local changed=0
    if [[ ! -f "$KCPTUN_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$KCPTUN_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=KCPTUN Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$KCP_UDP_INSTALL_DIR/kcptun_server -c $KCP_UDP_INSTALL_DIR/kcptun_%i.json
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$UDP2RAW_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$UDP2RAW_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=UDP2RAW Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$KCP_UDP_INSTALL_DIR/udp2raw --conf-file $KCP_UDP_INSTALL_DIR/udp2raw_%i.conf
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$HY2_TEMPLATE_FILE" ]]; then
        changed=1
        generate_self_signed_cert
        cat > "$HY2_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Hysteria2 Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$HY2_INSTALL_DIR/hysteria -c $HY2_INSTALL_DIR/hy2_%i.yaml server
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$XRAY_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$XRAY_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Xray Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$XRAY_INSTALL_DIR/xray -c $XRAY_INSTALL_DIR/xray_%i.json
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ $changed -eq 1 ]]; then systemctl daemon-reload; fi
}

# 从配置文件中提取监听地址和端口
get_listen_info_from_conf() {
    local conf_path=$1
    if [[ ! -f "$conf_path" ]]; then echo "配置文件不存在"; return; fi

    if [[ "$conf_path" == *".json" ]]; then
        if grep -q '"smuxver"' "$conf_path" 2>/dev/null; then
            grep -Po '(?<="listen": ")[^"]+' "$conf_path"
        else
            local listen=$(jq -r '.inbounds[0].listen // "0.0.0.0"' "$conf_path" 2>/dev/null)
            local port=$(jq -r '.inbounds[0].port // 0' "$conf_path" 2>/dev/null)
            if [[ "$listen" == "null" || "$port" == "0" ]]; then echo "JSON解析错误"; else echo "${listen}:${port}"; fi
        fi
    elif [[ "$conf_path" == *".conf" ]]; then
        grep -Po '(?<=-l )[^ ]+' "$conf_path"
    elif [[ "$conf_path" == *".yaml" ]]; then
        local raw_listen=$(grep -Po '(?<=listen: ).*' "$conf_path" | tr -d '[:space:]')
        if [[ "$raw_listen" == :* ]]; then echo "0.0.0.0$raw_listen"; else echo "$raw_listen"; fi
    fi
}

# 从配置文件中检查 WARP 是否启用
get_warp_status_from_conf() {
    local conf_path=$1
    if [[ "$conf_path" == *".yaml" ]]; then
        if grep -q "name: warp" "$conf_path" 2>/dev/null; then echo "已启用WARP"; else echo "未启用WARP"; fi
    elif [[ "$conf_path" == *".json" ]]; then
        if jq -e '.outbounds[] | select(.tag == "warp")' "$conf_path" >/dev/null 2>&1; then echo "已启用WARP"; else echo "未启用WARP"; fi
    else
        echo ""
    fi
}

# 获取单个服务的运行状态字符串 (绿色或黄色)
get_service_status_string() {
    local service_name=$1
    if systemctl is-active --quiet "$service_name"; then echo "运行中"; else echo "未运行"; fi
}

# 获取串联实例的组合状态 (颜色, 状态1, 状态2)
get_chain_status_tuple() {
    local chain_type=$1 chain_id=$2
    local service1_name="" service2_name=""
    if [[ "$chain_type" == "hy2" ]]; then
        service1_name="hysteria2@${chain_id}.service"
        service2_name="udp2raw@${chain_id}.service"
    else # vless
        service1_name="${XRAY_SERVICE_NAME}@${chain_id}.service"
        service2_name="udp2raw@${chain_id}.service"
    fi
    
    local s1_active=false s2_active=false status_color="yellow"
    if systemctl is-active --quiet "$service1_name"; then s1_active=true; fi
    if systemctl is-active --quiet "$service2_name"; then s2_active=true; fi
    if $s1_active && $s2_active; then status_color="cyan"; fi
    
    echo "$status_color $(get_service_status_string "$service1_name") $(get_service_status_string "$service2_name")"
}

# [NEW] 获取 3 组件串联实例的组合状态 (颜色, 状态1, 状态2, 状态3)
get_3_chain_status_tuple() {
    local chain_id=$1 # e.g., s3c1
    local service1_name="${XRAY_SERVICE_NAME}@${chain_id}.service" # SS
    local service2_name="kcptun@${chain_id}.service"        # KCPTUN
    local service3_name="udp2raw@${chain_id}.service"        # UDP2RAW
    
    local s1_active=false s2_active=false s3_active=false status_color="yellow"
    if systemctl is-active --quiet "$service1_name"; then s1_active=true; fi
    if systemctl is-active --quiet "$service2_name"; then s2_active=true; fi
    if systemctl is-active --quiet "$service3_name"; then s3_active=true; fi
    
    if $s1_active && $s2_active && $s3_active; then status_color="cyan"; fi
    
    echo "$status_color $(get_service_status_string "$service1_name") $(get_service_status_string "$service2_name") $(get_service_status_string "$service3_name")"
}


# 显示单个实例的状态行 
display_instance_status_line() {
    local type=$1 id=$2 prefix=$3; local full_id="$id"; local line
    case "$type" in
        "hy2_chain")
            full_id="c${id}"
            read -r color hy2_status udp_status <<< "$(get_chain_status_tuple "hy2" "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$KCP_UDP_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$HY2_INSTALL_DIR/hy2_${full_id}.yaml")
            line="$($color "${prefix}Hysteria2 [${hy2_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "vless_chain")
            full_id="vc${id}"
            read -r color xray_status udp_status <<< "$(get_chain_status_tuple "vless" "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$KCP_UDP_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}VLESS_mKCP [${xray_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "ss_3_chain_chain")
            full_id="s3c${id}"
            read -r color s1_status s2_status s3_status <<< "$(get_3_chain_status_tuple "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$KCP_UDP_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}SS [${s1_status}] + KCP [${s2_status}] + UDP2RAW [${s3_status}] ${udp_info} (${warp_status})")"
            ;;
        "hysteria2"|"udp2raw"|"kcptun"|"xray_reality"|"xray_mkcp"|"xray_ss")
            local conf_file service_prefix title; local color_func="yellow"
            case "$type" in
                hysteria2) conf_file="$HY2_INSTALL_DIR/hy2_${id}.yaml"; service_prefix="hysteria2"; title="Hysteria2";;
                udp2raw) conf_file="$KCP_UDP_INSTALL_DIR/udp2raw_${id}.conf"; service_prefix="udp2raw"; title="UDP2RAW";;
                kcptun) conf_file="$KCP_UDP_INSTALL_DIR/kcptun_${id}.json"; service_prefix="kcptun"; title="KCPTUN";;
                xray_reality) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="${XRAY_SERVICE_NAME}"; title="VLESS+Reality";;
                xray_mkcp) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="${XRAY_SERVICE_NAME}"; title="VLESS+mKCP";;
                xray_ss) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="${XRAY_SERVICE_NAME}"; title="Shadowsocks";;
            esac
            local status_info=$(get_listen_info_from_conf "$conf_file")
            local status_str=$(get_service_status_string "${service_prefix}@${id}.service")
            local extra_info=""
            if [[ "$type" == "hysteria2" || "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then
                extra_info=" ($(get_warp_status_from_conf "$conf_file"))"
            fi
            if [[ "$status_str" == "运行中" ]]; then color_func="cyan"; fi
            line="$($color_func "${prefix}${title} [${status_str}] ${status_info}${extra_info}")"
            ;;
    esac
    echo -e "$line"
}

# 内部函数：获取指定目录下的所有实例 ID
get_instances() {
    local dir=$1 pattern=$2
    ls -1 "$dir"/$pattern 2>/dev/null | sed -E "s/.*_([a-zA-Z0-9]+)\\..*/\1/" | sort -V
}

# 获取 *独立* 实例的 ID 列表 (过滤掉串联实例)
get_standalone_instances() {
    local type_lowercase=$1
    local dir="" pattern=""
    local standalone_instances=()
    
    case "$type_lowercase" in
        "hysteria2") dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml";;
        "xray_reality") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_mkcp") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_ss") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "udp2raw") dir="$KCP_UDP_INSTALL_DIR"; pattern="udp2raw_*.conf";;
        "kcptun") dir="$KCP_UDP_INSTALL_DIR"; pattern="kcptun_*.json";;
    esac

    local all_instances=$(get_instances "$dir" "$pattern")
    for i in $all_instances; do
        if [[ "$type_lowercase" == "xray_reality" ]]; then
            grep -q '"security": "reality"' "$dir/xray_${i}.json" 2>/dev/null && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_mkcp" ]]; then
            grep -q '"network": "kcp"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^(vc|s3c)[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_ss" ]]; then
            grep -q '"protocol": "shadowsocks"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^s3c[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ ! "$i" =~ ^(c|vc|s3c)[0-9]+$ ]]; then
            standalone_instances+=($i)
        fi
    done
    echo "${standalone_instances[@]}"
}


# --- 13. (独立) 实例管理菜单与操作 (REFACTORED: 修复 xray 调用路径) ---

# 管理单个独立实例的子菜单
manage_instance_menu() {
    local type=$1 id=$2 service=$3 conf=$4
    while true; do
        clear; echo "=================================="; echo "      管理 ${type^^} 实例 $(dim "$id")"; echo "=================================="
        echo "状态：$(get_service_status_string "$service") $(dim "$(get_listen_info_from_conf "$conf")")"
        if [[ "$type" == "hysteria2" ]]; then cyan "订阅链接: $(generate_hy2_subscription_link $id)"; fi
        if [[ "$type" == "xray_reality" ]]; then cyan "分享链接: $(generate_xray_reality_link $id)"; fi
        if [[ "$type" == "xray_mkcp" ]]; then cyan "分享链接: $(generate_xray_mkcp_link $id)"; fi
        if [[ "$type" == "xray_ss" ]]; then cyan "分享链接: $(generate_xray_ss_link $id)"; fi
        echo "----------------------------------"; echo "1) 启动/重启"; echo "2) 停止"; echo "3) 查看实时日志"; echo "4) 编辑配置"; echo "5) 删除此实例"; echo "6) 查看客户端配置"; echo "0) 返回"
        read -p "请选择 [0-6]: " choice
        case $choice in
            1) log "正在启动/重启..."; systemctl restart "$service"; green "操作完成！";;
            2) log "正在停止..."; systemctl stop "$service"; green "操作完成！";;
            3) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪日志... (按 Ctrl+C 仅退出日志)"
                sleep 1
                local current_trap=$(trap -p SIGINT) # 保存当前 trap
                trap ':' SIGINT
                journalctl -u "$service" -f --since "1 hour ago"
                eval "$current_trap" # 恢复 trap
                ;;
            4) nano "$conf"; log "重启实例以应用配置..."; systemctl restart "$service"; green "配置已更新！";;
            5) read -p "确认彻底删除实例 ${id}？[y/N]: " confirm; if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then log "停止并删除..."; systemctl stop "$service"; systemctl disable "$service" >/dev/null 2>&1; rm -f "$conf"; systemctl daemon-reload; green "实例 ${id} 已删除！"; break; fi;;
            6) clear; echo "--- ${type^^} 客户端配置 (实例 $id) ---"
               case "$type" in
                   "hysteria2") cyan "订阅链接: $(generate_hy2_subscription_link "$id")" ;;
                   "udp2raw") view_udp2raw_client_config "$id" ;;
                   "kcptun") view_kcptun_client_config "$id" ;;
                   "xray_reality") cyan "分享链接: $(generate_xray_reality_link "$id")" ;;
                   "xray_mkcp") cyan "分享链接: $(generate_xray_mkcp_link "$id")" ;;
                   "xray_ss") cyan "分享链接: $(generate_xray_ss_link "$id")" ;;
               esac
               read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$choice" == "1" || "$choice" == "2" || "$choice" == "4" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}

# 创建一个新的独立实例 (hy2, udp2raw, kcptun)
create_new_instance() {
    local type=$1; local next_id; local INSTALL_DIR SERVICE_PREFIX FILE_EXT TITLE CONFIG_TEMPLATE SYSTEMD_SERVICE_NAME
    declare -A replacements

    case "$type" in
        hysteria2) TITLE="Hysteria2"; INSTALL_DIR="$HY2_INSTALL_DIR"; SERVICE_PREFIX="hy2"; SYSTEMD_SERVICE_NAME="hysteria2"; FILE_EXT="yaml"; CONFIG_TEMPLATE="$HYSTERIA2_CONFIG_YAML_TEMPLATE" ;;
        udp2raw) TITLE="UDP2RAW"; INSTALL_DIR="$KCP_UDP_INSTALL_DIR"; SERVICE_PREFIX="udp2raw"; SYSTEMD_SERVICE_NAME="udp2raw"; FILE_EXT="conf"; CONFIG_TEMPLATE="$UDP2RAW_CONFIG_TEMPLATE" ;;
        kcptun) TITLE="KCPTUN"; INSTALL_DIR="$KCP_UDP_INSTALL_DIR"; SERVICE_PREFIX="kcptun"; SYSTEMD_SERVICE_NAME="kcptun"; FILE_EXT="json"; CONFIG_TEMPLATE="$KCPTUN_CONFIG_JSON_TEMPLATE" ;;
        *) red "内部错误: 无效的实例类型 '$type'"; return 1 ;;
    esac

    log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
    green "新实例将被创建为: ${SYSTEMD_SERVICE_NAME}@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"

    local listen_addr="$DEFAULT_LISTEN_ADDR"; local listen_port
    if [[ "$type" == "hysteria2" ]]; then
        read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
        replacements["__LISTEN__"]=":${listen_port}"
    else
        read -p "请输入监听地址 (默认: $DEFAULT_LISTEN_ADDR): " listen_addr_input; listen_addr=${listen_addr_input:-$listen_addr}
        read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
        replacements["__LISTEN_ADDR__"]="${listen_addr}:${listen_port}"; replacements["__LISTEN__"]="${listen_addr}:${listen_port}"
    fi

    if [[ "$type" == "udp2raw" || "$type" == "kcptun" ]]; then
        read -p "请输入目标地址 (默认: $DEFAULT_TARGET_ADDR): " target_host; target_host=${target_host:-$DEFAULT_TARGET_ADDR}
        read -p "请输入目标端口 (留空则随机生成): " target_port; if [[ -z "$target_port" ]]; then target_port=$(find_available_port); green "已为您随机选择目标端口: $target_port"; fi
        replacements["__TARGET_ADDR__"]="${target_host}:${target_port}"; replacements["__TARGET__"]="${target_host}:${target_port}"
    fi
    if [[ "$type" == "kcptun" ]]; then 
        read -p "请输入加速模式 (默认: $KCPTUN_DEFAULT_MODE): " mode; mode=${mode:-$KCPTUN_DEFAULT_MODE}; replacements["__MODE__"]="$mode"; 
    fi

    if [[ "$type" == "hysteria2" ]]; then
        read -p "是否启用 WARP SOCKS5 分流 (默认禁用)？[y/N]: " enable_warp
        if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
            read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
            local current_warp_addr="${DEFAULT_WARP_SOCKS_ADDR}:${warp_port}"; replacements["__OUTBOUNDS_AND_ACL__"]="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_SOCKS5_ADDR__/${current_warp_addr}}"
            green "已启用 WARP SOCKS5 分流 (地址: ${current_warp_addr})。"
        else
            replacements["__OUTBOUNDS_AND_ACL__"]="${HYSTERIA2_DIRECT_ACL_BLOCK}"; yellow "已禁用 WARP SOCKS5 分流。"
        fi
        replacements["__CERT_PATH__"]="$HY2_CERT_PATH"; replacements["__KEY_PATH__"]="$HY2_KEY_PATH";
        replacements["__MASQUERADE_URL__"]="$HY2_MASQUERADE_URL"; replacements["__UDP_SNIFF_CONFIG__"]=""
    fi
    
    local password=$(handle_password_input "$type")
    if [[ "$type" == "kcptun" ]]; then replacements["__KEY__"]="$password"; else replacements["__PASSWORD__"]="$password"; fi
    
    log "生成配置文件..."; local temp_config="$CONFIG_TEMPLATE"; local conf_path="${INSTALL_DIR}/${SERVICE_PREFIX}_${next_id}.${FILE_EXT}"
    for placeholder in "${!replacements[@]}"; do temp_config="${temp_config//${placeholder}/${replacements[${placeholder}]}}"; done
    echo "$temp_config" > "$conf_path"

    sync; log "启动服务..."; systemctl enable --now "${SYSTEMD_SERVICE_NAME}@${next_id}.service"; sleep 1; green "实例 ${next_id} 已启动！"; echo
    case "$type" in
        hysteria2) local sub_link=""; local retries=5; for ((i=1; i<=retries; i++)); do sub_link=$(generate_hy2_subscription_link $next_id); if [[ "$sub_link" != "N/A" ]]; then break; fi; sleep 0.5; done; cyan "订阅链接: $sub_link";;
        udp2raw) view_udp2raw_client_config "$next_id" ;;
        kcptun) view_kcptun_client_config "$next_id" ;;
    esac
}

# 创建一个新的 Xray 实例 (Reality 或 mKCP) (REFACTORED: 修复 xray 调用路径)
create_new_xray_instance() {
    local type=$1; local next_id;
    next_id=$(find_next_available_id "xray")
    
    declare -A replacements
    local temp_config=""
    local title=""

    if [[ "$type" == "xray_reality" ]]; then
        title="VLESS+Reality"
        temp_config="$XRAY_VLESS_REALITY_TEMPLATE"
        log "启动一个新的 ${title} 实例 (ID: ${next_id})..."
        
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"
        
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        
        log "正在生成 Reality 密钥对..."

        # 生成可复现的 Reality 种子（32位 hex）
        local reality_key_seed=$(echo -n "${uuid}" | sha256sum | awk '{print $1}' | head -c 32)

        # 生成 Reality 密钥对
        # local tmp_key=$($XRAY_INSTALL_DIR/xray x25519 -i <<< "${reality_key_seed}")
        local tmp_key=$($XRAY_INSTALL_DIR/xray x25519)

        # 提取私钥和公钥（更稳健的提取方式）
        local private_key=$(awk -F': ' '/Private/{print $2}' <<< "${tmp_key}")
        local public_key=$(awk -F': ' '/Public/{print $2}' <<< "${tmp_key}")

        # 验证结果
        if [[ -z "$private_key" || -z "$public_key" ]]; then
            red "错误: 无法生成或解析 Reality 密钥对！"
            log "Xray 命令输入种子: $reality_key_seed"
            log "Xray 命令输出: $tmp_key"
            return 1
        fi

        # 替换模板变量
        replacements["__PRIVATE_KEY__"]="$private_key"
        replacements["__PUBLIC_KEY__"]="$public_key"
                
        green "已使用默认 Reality 参数: SNI=${XRAY_REALITY_DEFAULT_SNI}, Target=${XRAY_REALITY_DEFAULT_TARGET}, Fingerprint=${XRAY_REALITY_DEFAULT_FP}"
        replacements["__SNI__"]="$XRAY_REALITY_DEFAULT_SNI"
        replacements["__TARGET__"]="$XRAY_REALITY_DEFAULT_TARGET"
        replacements["__FINGERPRINT__"]="$XRAY_REALITY_DEFAULT_FP"
        replacements["__REALITY_FLOW__"]="$XRAY_REALITY_DEFAULT_FLOW"
        
        local short_id=$(openssl rand -hex 8); replacements["__SHORT_ID__"]="$short_id"
    
    elif [[ "$type" == "xray_mkcp" ]]; then
        title="VLESS+mKCP"
        temp_config="$XRAY_VLESS_MKCP_TEMPLATE"
        log "启动一个新的 ${title} 实例 (ID: ${next_id})..."
        
        read -p "请输入监听 IP (默认: $DEFAULT_LISTEN_ADDR): " listen_addr; listen_addr=${listen_addr:-$DEFAULT_LISTEN_ADDR}; replacements["__LISTEN_ADDR__"]="$listen_addr"
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"
        
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        local mkcp_seed=$(handle_password_input "xray_mkcp"); replacements["__MKCP_SEED__"]="$mkcp_seed"
    
    elif [[ "$type" == "xray_ss" ]]; then
        title="Shadowsocks"
        temp_config="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE"
        log "启动一个新的 ${title} 实例 (ID: ${next_id})..."

        read -p "请输入监听 IP (默认: $DEFAULT_LISTEN_ADDR): " listen_addr; listen_addr=${listen_addr:-$DEFAULT_LISTEN_ADDR}; replacements["__LISTEN_ADDR__"]="$listen_addr"
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"

        read -p "请输入加密方式 (默认: $SS_DEFAULT_METHOD): " ss_method; ss_method=${ss_method:-$SS_DEFAULT_METHOD}; replacements["__SS_METHOD__"]="$ss_method"
        local ss_password=$(handle_password_input "shadowsocks"); replacements["__SS_PASSWORD__"]="$ss_password"
    fi

    read -p "是否启用 WARP SOCKS5 分流 (默认禁用)？[y/N]: " enable_warp
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # [新] 自动使用默认地址
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        local warp_config=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
        warp_config=${warp_config/__WARP_SOCKS5_ADDR__/$warp_addr}
        warp_config=${warp_config/__WARP_SOCKS5_PORT__/$warp_port}
        replacements["__OUTBOUNDS_AND_ROUTING__"]="$warp_config"
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        replacements["__OUTBOUNDS_AND_ROUTING__"]="$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK"
        yellow "已禁用 WARP SOCKS5 分流。"
    fi

    log "生成配置文件..."; local conf_path="${XRAY_INSTALL_DIR}/xray_${next_id}.json"
    for placeholder in "${!replacements[@]}"; do
        temp_config="${temp_config//${placeholder}/${replacements[${placeholder}]}}"
    done
    echo "$temp_config" > "$conf_path"

    # sync; log "启动服务..."; systemctl enable --now "${XRAY_SERVICE_NAME}${XRAY_SERVICE_NAME}@${next_id}.service"; sleep 1;
    sync; log "启动服务..."; systemctl enable --now "${XRAY_SERVICE_NAME}@${next_id}.service"; sleep 1;
    if ! systemctl is-active --quiet "${XRAY_SERVICE_NAME}@${next_id}.service"; then
        red "实例 ${next_id} 启动失败！请检查配置或日志。"
    else
        green "实例 ${next_id} 已启动！"; echo
        if [[ "$type" == "xray_reality" ]]; then
            cyan "分享链接: $(generate_xray_reality_link "$next_id")"
        elif [[ "$type" == "xray_mkcp" ]]; then
            cyan "分享链接: $(generate_xray_mkcp_link "$next_id")"
        elif [[ "$type" == "xray_ss" ]]; then
            cyan "分享链接: $(generate_xray_ss_link "$next_id")"
        fi
    fi
}

# --- 14. 客户端配置查看器 ---

# 生成 Hysteria2 订阅链接
generate_hy2_subscription_link() {
    local id=$1; local conf="$HY2_INSTALL_DIR/hy2_${id}.yaml"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local password=$(grep -Po '(?<=password: ).*' "$conf" | tr -d '[:space:]'); local port_info=$(get_listen_info_from_conf "$conf"); local port=$(echo "$port_info" | awk -F':' '{print $NF}'); local ip=$(get_public_ip)
    echo "hysteria2://${password}@${ip}:${port}?sni=${HY2_SNI}&insecure=${HY2_CLIENT_INSECURE}#hy2_${ip}_${id}"
}

# 生成 VLESS+Reality 分享链接
generate_xray_reality_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local sni=$(jq -r '.inbounds[0].streamSettings.realitySettings.serverNames[0]' "$conf")
    local pbk=$(jq -r '.inbounds[0].streamSettings.realitySettings.publicKey' "$conf")
    local sid=$(jq -r '.inbounds[0].streamSettings.realitySettings.shortIds[0]' "$conf")
    local flow=$(jq -r '.inbounds[0].settings.clients[0].flow' "$conf")
    local fp=$(jq -r '.inbounds[0].streamSettings.realitySettings.fingerprint' "$conf")

    local link="vless://${uuid}@${ip}:${port}?type=tcp&security=reality&sni=${sni}&pbk=${pbk}&flow=${flow}&sid=${sid}&fp=${fp}#Xray_Reality_${ip}_${id}"
    echo "$link"
}

# 生成 VLESS+mKCP 分享链接
generate_xray_mkcp_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$conf")
    local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$conf")
    
    local link="vless://${uuid}@${ip}:${port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}#Xray_mKCP_${ip}_${id}"
    echo "$link"
}

# [NEW] 生成 Shadowsocks 分享链接
generate_xray_ss_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port_info=$(get_listen_info_from_conf "$conf")
    local port=$(echo "$port_info" | awk -F':' '{print $NF}')
    local password=$(jq -r '.inbounds[0].settings.password' "$conf")
    local method=$(jq -r '.inbounds[0].settings.method' "$conf")
    
    # Base64 encode: method:password
    local user_info=$(echo -n "${method}:${password}" | base64 | tr -d '\n' | sed 's/=*$//') # Remove padding
    
    local link="ss://${user_info}@${ip}:${port}#SS_${ip}_${id}"
    echo "$link"
}

# 查看所有 Hysteria2 独立实例的订阅链接
view_all_hy2_subscriptions() {
    local INSTANCES=$(get_standalone_instances "hysteria2"); if [[ -z "$INSTANCES" ]]; then yellow "未找到任何 Hysteria2 独立实例。"; return; fi
    cyan "--- Hysteria2 独立实例订阅链接 ---"; for id in $INSTANCES; do green "实例 ${id}: $(generate_hy2_subscription_link $id)"; done
}

# 查看 UDP2RAW 客户端配置
view_udp2raw_client_config(){
    local id=$1; local conf="$KCP_UDP_INSTALL_DIR/udp2raw_${id}.conf"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    local ip=$(get_public_ip); local port=$(get_listen_info_from_conf "$conf" | awk -F':' '{print $NF}'); local password=$(grep -Po '(?<=-k )[^ ]+' "$conf")
    
    cyan "--- UDP2RAW 实例 ${id} 客户端配置 ---";  echo
    green "${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${port} -l ${CLIENT_UDP2RAW_LISTEN_ADDR} -k ${password}"
}

# 查看 KCPTUN 客户端配置
view_kcptun_client_config(){
    local id=$1; local conf="$KCP_UDP_INSTALL_DIR/kcptun_${id}.json"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    if ! command -v jq &>/dev/null; then red "错误: jq 未安装，无法解析配置。"; return; fi
    local ip=$(get_public_ip); local server_listen=$(jq -r '.listen' "$conf"); local server_port=$(echo "$server_listen" | awk -F':' '{print $NF}'); cyan "--- KCPTUN 实例 ${id} 客户端配置 ---"; echo
    yellow "方法一: 使用 JSON 配置文件 (推荐)"; yellow "将以下内容保存为客户端的 config.json (本地监听地址 ${CLIENT_KCPTUN_LISTEN_ADDR} 可自行修改):"; green "$(jq --arg listen "${CLIENT_KCPTUN_LISTEN_ADDR}" --arg target "${ip}:${server_port}" '.listen = $listen | .target = $target' "$conf")"; echo
    yellow "方法二: 使用命令行参数"; yellow "在客户端使用以下命令行参数 (本地监听地址 ${CLIENT_KCPTUN_LISTEN_ADDR} 可自行修改):";local args="--listen ${CLIENT_KCPTUN_LISTEN_ADDR} --target ${ip}:${server_port}"
    for key in $(jq -r 'keys_unsorted | .[]' "$conf"); do if [[ "$key" != "listen" && "$key" != "target" ]]; then local value=$(jq -r --arg k "$key" '.[$k]' "$conf"); args+=" --${key} ${value}"; fi; done; green "$args"; echo
}

# --- 15. 组件串联实例管理 (SS+KCP+UDP) ---

# [NEW] 获取 3 组件串联实例ID列表 (ss_3_chain)
get_chain_instances_3() {
    local instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances2=$(ls -1 "$KCP_UDP_INSTALL_DIR"/kcptun_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances3=$(ls -1 "$KCP_UDP_INSTALL_DIR"/udp2raw_s3c*.conf 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    echo "$instances1 $instances2 $instances3" | tr ' ' '\n' | sort -un
}

# 查看 3 组件串联实例的客户端配置
view_chain_client_config_3() {
    local id_num=$1
    local id="s3c${id_num}"
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${id}.json"
    local kcptun_conf_path="$KCP_UDP_INSTALL_DIR/kcptun_${id}.json"
    local udp2raw_conf_path="$KCP_UDP_INSTALL_DIR/udp2raw_${id}.conf"
    
    if [[ ! -f "$ss_conf_path" || ! -f "$kcptun_conf_path" || ! -f "$udp2raw_conf_path" ]]; then
        red "串联实例 ${id} 的配置文件不完整。"; return
    fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf_path" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf_path")
    local kcptun_password=$(jq -r '.key' "$kcptun_conf_path")
    local ss_method=$(jq -r '.inbounds[0].settings.method' "$ss_conf_path")
    local ss_password=$(jq -r '.inbounds[0].settings.password' "$ss_conf_path")
    
    cyan "--- SS+KCP+UDP 实例 ${id} 客户端配置 ---"; echo
    
    yellow "步骤 1: 运行 UDP2RAW (客户端)"
    yellow " (它会监听 ${CLIENT_SS_3_CHAIN_KCP_TARGET}, 作为 KCPTUN 的目标)"
    local client_args_udp2raw="${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${udp2raw_port} -l ${CLIENT_SS_3_CHAIN_KCP_TARGET} -k ${udp2raw_password}"
    green "$client_args_udp2raw"; echo
    
    yellow "步骤 2: 运行 KCPTUN (客户端)"
    yellow " (它会监听 ${CLIENT_SS_3_CHAIN_SS_TARGET}, 作为 SS 的目标)"
    # green "$(jq --arg listen "${CLIENT_SS_3_CHAIN_SS_TARGET}" --arg target "${CLIENT_SS_3_CHAIN_KCP_TARGET}" '.listen = $listen | .target = $target' "$kcptun_conf_path")"; echo

    local kcp_args="--listen ${CLIENT_SS_3_CHAIN_SS_TARGET} --target ${CLIENT_SS_3_CHAIN_KCP_TARGET}"
    # 解析 JSON 并将所有其他键附加为参数
    for key in $(jq -r 'keys_unsorted | .[]' "$kcptun_conf_path"); do
        if [[ "$key" != "listen" && "$key" != "target" ]]; then
            local value=$(jq -r --arg k "$key" '.[$k]' "$kcptun_conf_path")
            kcp_args+=" --${key} ${value}"
        fi
    done
    green "$kcp_args"; echo
    
    yellow "步骤 3: SS 客户端配置 (指向本地 KCPTUN)"
    local ss_user_info=$(echo -n "${ss_method}:${ss_password}" | base64 | tr -d '\n' | sed 's/=*$//')
    local ss_host=$(echo "$CLIENT_SS_3_CHAIN_SS_TARGET" | cut -d: -f1)
    local ss_port=$(echo "$CLIENT_SS_3_CHAIN_SS_TARGET" | cut -d: -f2)
    local sub_link="ss://${ss_user_info}@${ss_host}:${ss_port}#SS_3_Chain_${ip}_${id}"
    green "$sub_link"; echo
    
    echo
    yellow "[SS+KCPTUN+UDP2RAW] 合并订阅链接 (复制以下整行):"
    green "${sub_link} && KCPTUN://${kcp_args} && UDP2RAW://${client_args_udp2raw}"
    echo
}

# 启动一个新的 3 组件串联实例 (SS+KCP+UDP)
start_new_chain_instance_3() {
    local i=1
    while true; do if [[ ! -f "$XRAY_INSTALL_DIR/xray_s3c${i}.json" ]]; then break; fi; i=$((i + 1)); done
    
    local chain_id="s3c${i}"
    log "启动一个新的 SS+KCP+UDP 串联实例 (全自动)..."
    green "新串联实例将被创建为: ${chain_id}"
    
    read -p "请输入对外监听端口 (UDP2RAW) (留空则随机): " udp2raw_listen_port
    if [[ -z "$udp2raw_listen_port" ]]; then 
        udp2raw_listen_port=$(find_available_port); 
        green "已自动选择对外端口 (UDP2RAW): $udp2raw_listen_port"
    else
        green "已指定对外端口 (UDP2RAW): $udp2raw_listen_port"
    fi
    
    local kcptun_listen_port=$(find_available_port); green "已自动选择内联端口 (KCPTUN): $kcptun_listen_port"
    local ss_listen_port=$(find_available_port); green "已自动选择内联端口 (SS): $ss_listen_port"
    
    log "正在自动生成所有密码..."
    local udp2raw_password=$(generate_strong_password)
    green "已自动生成 UDP2RAW 密码: $udp2raw_password"
    
    local kcptun_password=$(generate_strong_password)
    green "已自动生成 KCPTUN 密码: $kcptun_password"

    if ! command -v openssl &>/dev/null; then 
        red "错误: openssl 未安装, 无法生成 SS 密钥！"; return 1; 
    fi
    local ss_password=$(openssl rand -base64 32)
    green "已自动生成 SS-2022 Base64 密钥: $ss_password"
    
    # 1. 配置 Xray (Shadowsocks)
    local ss_config="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE"
    ss_config=${ss_config/__LISTEN_ADDR__/127.0.0.1}
    ss_config=${ss_config/__LISTEN_PORT__/$ss_listen_port}
    ss_config=${ss_config/__SS_METHOD__/$SS_DEFAULT_METHOD}
    ss_config=${ss_config/__SS_PASSWORD__/$ss_password}
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${chain_id}.json"
    
    # 2. 配置 KCPTUN
    local kcp_config="$KCPTUN_CONFIG_JSON_TEMPLATE"
    kcp_config=${kcp_config/__LISTEN__/127.0.0.1:${kcptun_listen_port}}
    kcp_config=${kcp_config/__TARGET__/127.0.0.1:${ss_listen_port}}
    kcp_config=${kcp_config/__KEY__/$kcptun_password}
    kcp_config=${kcp_config/__MODE__/$KCPTUN_DEFAULT_MODE}
    local kcp_conf_path="$KCP_UDP_INSTALL_DIR/kcptun_${chain_id}.json"
    
    # 3. 配置 UDP2RAW
    local udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    udp_config="${udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    udp_config="${udp_config//__TARGET_ADDR__/127.0.0.1:${kcptun_listen_port}}"
    udp_config="${udp_config//__PASSWORD__/${udp2raw_password}}"
    local udp_conf_path="$KCP_UDP_INSTALL_DIR/udp2raw_${chain_id}.conf"

    # 处理 WARP
    read -p "是否启用 WARP SOCKS5 分流 (默认禁用)？[y/N]: " enable_warp
    local warp_config_block=""
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # [新] 自动使用默认地址
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        
        warp_config_block=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
        warp_config_block=${warp_config_block/__WARP_SOCKS5_ADDR__/$warp_addr}
        warp_config_block=${warp_config_block/__WARP_SOCKS5_PORT__/$warp_port}
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        warp_config_block=$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK
        yellow "已禁用 WARP SOCKS5 分流。"
    fi
    ss_config=${ss_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
    
    # 写入所有配置
    log "生成配置文件..."
    echo "$ss_config" > "$ss_conf_path"
    echo "$kcp_config" > "$kcp_conf_path"
    echo "$udp_config" > "$udp_conf_path"
    
    sync; log "启动串联服务...";
    systemctl enable --now "${XRAY_SERVICE_NAME}@${chain_id}.service"
    systemctl enable --now "kcptun@${chain_id}.service"
    systemctl enable --now "udp2raw@${chain_id}.service"
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config_3 "$i"
}

# [NEW] 管理一个已存在的 3 组件串联实例
manage_chain_instance_3() {
    local id_num=$1
    local manage_id="s3c${id_num}"
    
    local service1_full="${XRAY_SERVICE_NAME}@${manage_id}.service" # SS
    local service2_full="kcptun@${manage_id}.service"        # KCP
    local service3_full="udp2raw@${manage_id}.service"        # UDP2RAW
    
    local conf1_path="$XRAY_INSTALL_DIR/xray_${manage_id}.json"
    local conf2_path="$KCP_UDP_INSTALL_DIR/kcptun_${manage_id}.json"
    local conf3_path="$KCP_UDP_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "   管理 SS+KCP+UDP $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status s3_status <<< "$(get_3_chain_status_tuple "$manage_id")"
        local udp2raw_info=$(get_listen_info_from_conf "$conf3_path")
        
        $color "状态: SS [${s1_status}] + KCP [${s2_status}] + UDP2RAW [${s3_status}] $(dim "$udp2raw_info")"

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 SS (Xray) 日志"; echo "5) 查看 KCPTUN 日志"; echo "6) 查看 UDP2RAW 日志"; echo "7) 编辑 SS (Xray) 配置文件"; echo "8) 编辑 KCPTUN 配置文件"; echo "9) 编辑 UDP2RAW 配置文件"; echo "10) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full" "$service3_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full" "$service3_full";;
            3) view_chain_client_config_3 "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) log "正在实时跟踪 SS (Xray) 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service1_full" -f; eval "$ct";;
            5) log "正在实时跟踪 KCPTUN 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service2_full" -f; eval "$ct";;
            6) log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service3_full" -f; eval "$ct";;
            7) nano "$conf1_path"; systemctl restart "$service1_full";;
            8) nano "$conf2_path"; systemctl restart "$service2_full";;
            9) nano "$conf3_path"; systemctl restart "$service3_full";;
            10) read -p "确认删除串联实例 ${manage_id}？[y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full" "$service3_full"; 
                systemctl disable "$service1_full" "$service2_full" "$service3_full" >/dev/null 2>&1; 
                rm -f "$conf1_path" "$conf2_path" "$conf3_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "7" || "$manage_choice" == "8" || "$manage_choice" == "9" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}

# [NEW] 3 组件串联实例的通用管理菜单
chain_manager_menu_3() {
    local title="SS+KCP+UDP 串联"
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances_3)
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "ss_3_chain_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的 SS+KCP+UDP。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的 SS+KCP+UDP"; echo "2) 管理一个已存在的 SS+KCP+UDP"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance_3; read -p $'\n按任意键返回...' -n1 -s;;
            2) if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi; read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num; if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then manage_chain_instance_3 "$manage_id_num"; else red "无效的实例ID！"; sleep 2; fi;;
            3) if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi; local i; for i in $INSTANCES; do view_chain_client_config_3 $i; done; read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}


# --- 16. [合并] 2 组件串联实例管理 (Hysteria2 / VLESS) ---

# 获取 2 组件串联实例ID列表 (hy2 或 vless)
get_chain_instances() {
    local chain_type=$1
    local instances1="" instances2=""
    if [[ "$chain_type" == "hy2" ]]; then
        instances1=$(ls -1 "$HY2_INSTALL_DIR"/hy2_c*.yaml 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
        instances2=$(ls -1 "$KCP_UDP_INSTALL_DIR"/udp2raw_c*.conf 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
    else # vless
        instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_vc*.json 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
        instances2=$(ls -1 "$KCP_UDP_INSTALL_DIR"/udp2raw_vc*.conf 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
    fi
    echo "$instances1 $instances2" | tr ' ' '\n' | sort -un
}

# 查看 2 组件串联实例的客户端配置
view_chain_client_config() {
    local chain_type=$1 id_num=$2
    local id_prefix="" main_conf_path="" client_listen_addr="" title=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"; client_listen_addr="$CLIENT_UDP2RAW_LISTEN_ADDR"
    else
        id_prefix="vc"; title="VLESS_mKCP"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"; client_listen_addr="$CLIENT_VLESS_UDP2RAW_LISTEN_ADDR"
    fi
    local id="${id_prefix}${id_num}"
    local udp2raw_conf="$KCP_UDP_INSTALL_DIR/udp2raw_${id}.conf"
    if [[ ! -f "$main_conf_path" || ! -f "$udp2raw_conf" ]]; then red "串联实例 ${id} 的配置文件不完整。"; return; fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf")
    
    local client_args="${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${udp2raw_port} -l ${client_listen_addr} -k ${udp2raw_password}"
    local client_udp2raw_host=$(echo "$client_listen_addr" | cut -d: -f1)
    local client_udp2raw_port=$(echo "$client_listen_addr" | cut -d: -f2)
    local sub_link=""
    local display_title=""

    if [[ "$chain_type" == "hy2" ]]; then
        display_title="[hy2+UDP2RAW]"
        local hy2_password=$(grep -Po '(?<=password: ).*' "$main_conf_path" | tr -d '[:space:]')
        sub_link="hysteria2://${hy2_password}@${client_udp2raw_host}:${client_udp2raw_port}?sni=${HY2_SNI}&insecure=${HY2_CLIENT_INSECURE}#hy2_chain_${ip}_${id}"
    else # vless
        display_title="[VLESS_mKCP+UDP2RAW]"
        local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$main_conf_path")
        local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$main_conf_path")
        local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$main_conf_path")
        sub_link="vless://${uuid}@${client_udp2raw_host}:${client_udp2raw_port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}#VLESS_Chain_${ip}_${id}"
    fi

    cyan "--- ${title} 串联实例 ${id} 客户端配置 ---"; echo
    
    yellow "1. ${title} 客户端 (指向本地):"
    green "$sub_link"; echo
    
    yellow "2. UDP2RAW 客户端 (连接公网):"
    green "$client_args"; echo
    
    yellow "$display_title 合并订阅链接 (复制以下整行):"
    green "${sub_link} && UDP2RAW://${client_args}"
    echo
}

# 启动一个新的 2 组件串联实例 (hy2 或 vless)
start_new_chain_instance() {
    local chain_type=$1
    local i=1 id_prefix="" title="" main_conf_dir="" main_conf_template=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2+UDP"; main_conf_dir="$HY2_INSTALL_DIR"; main_conf_template="$HYSTERIA2_CONFIG_YAML_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/hy2_c${i}.yaml" ]]; then break; fi; i=$((i + 1)); done
    else # vless
        id_prefix="vc"; title="VLESS_mKCP+UDP"; main_conf_dir="$XRAY_INSTALL_DIR"; main_conf_template="$XRAY_VLESS_MKCP_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/xray_vc${i}.json" ]]; then break; fi; i=$((i + 1)); done
    fi
    
    local chain_id="${id_prefix}${i}"
    log "启动一个新的 ${title} 串联实例 (全自动)..."
    green "新串联实例将被创建为: ${chain_id}"
    local udp2raw_listen_port=$(find_available_port); green "已自动选择对外端口: $udp2raw_listen_port"
    local internal_listen_port=$(find_available_port); green "已自动选择内联端口: $internal_listen_port"
    local udp2raw_password=$(generate_strong_password); echo -n "已自动生成 UDP2RAW 密码: "; green "$udp2raw_password"
    
    local main_config="$main_conf_template"
    local main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        local hy2_password=$(generate_strong_password); echo -n "已自动生成 Hysteria2 密码: "; green "$hy2_password"
        main_config="${main_config//__LISTEN__/127.0.0.1:${internal_listen_port}}"
        main_config="${main_config//__CERT_PATH__/${HY2_CERT_PATH}}"
        main_config="${main_config//__KEY_PATH__/${HY2_KEY_PATH}}"
        main_config="${main_config//__PASSWORD__/${hy2_password}}"
        main_config="${main_config//__MASQUERADE_URL__/${HY2_MASQUERADE_URL}}"
        main_config="${main_config/__UDP_SNIFF_CONFIG__/udpPorts: all}"
        main_conf_path="$main_conf_dir/hy2_${chain_id}.yaml"
    else # vless
        local uuid=$(generate_strong_password); echo -n "已自动生成 VLESS UUID: "; green "$uuid"
        local mkcp_seed=$(generate_strong_password); echo -n "已自动生成 mKCP Seed: "; green "$mkcp_seed"
        main_config=${main_config/__LISTEN_ADDR__/127.0.0.1}
        main_config=${main_config/__LISTEN_PORT__/$internal_listen_port}
        main_config=${main_config/__UUID__/$uuid}
        main_config=${main_config/__MKCP_SEED__/$mkcp_seed}
        main_conf_path="$main_conf_dir/xray_${chain_id}.json"
    fi
    
    read -p "是否启用 WARP SOCKS5 分流 (默认禁用)？[y/N]: " enable_warp
    local warp_config_block=""
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # [新] 自动使用默认地址
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        
        if [[ "$chain_type" == "hy2" ]]; then
            warp_config_block="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_SOCKS5_ADDR__/${warp_addr}:${warp_port}}"
        else # vless
            warp_config_block=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
            warp_config_block=${warp_config_block/__WARP_SOCKS5_ADDR__/$warp_addr}
            warp_config_block=${warp_config_block/__WARP_SOCKS5_PORT__/$warp_port}
        fi
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        if [[ "$chain_type" == "hy2" ]]; then
            warp_config_block=$HYSTERIA2_DIRECT_ACL_BLOCK
        else # vless
            warp_config_block=$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK
        fi
        yellow "已禁用 WARP SOCKS5 分流。"
    fi
    
    if [[ "$chain_type" == "hy2" ]]; then
        main_config=${main_config/__OUTBOUNDS_AND_ACL__/$warp_config_block}
    else # vless
        main_config=${main_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
    fi
    
    echo "$main_config" > "$main_conf_path"
    
    log "生成 UDP2RAW 配置文件: udp2raw_${chain_id}.conf..."; local temp_udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    temp_udp_config="${temp_udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    temp_udp_config="${temp_udp_config//__TARGET_ADDR__/127.0.0.1:${internal_listen_port}}"
    temp_udp_config="${temp_udp_config//__PASSWORD__/${udp2raw_password}}"
    echo "$temp_udp_config" > "$KCP_UDP_INSTALL_DIR/udp2raw_${chain_id}.conf"
    
    sync; log "启动串联服务...";
    if [[ "$chain_type" == "hy2" ]]; then
        systemctl enable --now "hysteria2@${chain_id}.service"
    else # vless
        systemctl enable --now "${XRAY_SERVICE_NAME}@${chain_id}.service"
    fi
    systemctl enable --now "udp2raw@${chain_id}.service"
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config "$chain_type" "$i"
}

# 管理一个已存在的 2 组件串联实例
manage_chain_instance() {
    local chain_type=$1 id_num=$2
    local id_prefix="" title="" service1_name="" service2_name="" main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; service1_name="hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"
    else # vless
        id_prefix="vc"; title="VLESS_mKCP"; service1_name="${XRAY_SERVICE_NAME}"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"
    fi
    
    local manage_id="${id_prefix}${id_num}"
    service2_name="udp2raw"
    local service1_full="${service1_name}@${manage_id}.service"
    local service2_full="${service2_name}@${manage_id}.service"
    local udp2raw_conf_path="$KCP_UDP_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "      管理${title}串联实例 $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status <<< "$(get_chain_status_tuple "$chain_type" "$manage_id")"
        local udp2raw_info=$(get_listen_info_from_conf "$udp2raw_conf_path")
        
        if [[ "$chain_type" == "hy2" ]]; then
            $color "状态: Hysteria2 [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        else
            $color "状态: VLESS_mKCP [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        fi

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 ${title} 日志"; echo "5) 查看 UDP2RAW 日志"; echo "6) 编辑 ${title} 配置文件 (高级)"; echo "7) 编辑 UDP2RAW 配置文件 (高级)"; echo "8) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full";;
            3) view_chain_client_config "$chain_type" "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 ${title} 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service1_full" -f
                eval "$current_trap"
                ;;
            5) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service2_full" -f
                eval "$current_trap"
                ;;
            6) nano "$main_conf_path"; systemctl restart "$service1_full";;
            7) nano "$udp2raw_conf_path"; systemctl restart "$service2_full";;
            8) read -p "确认删除串联实例 ${manage_id}？[y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full"; 
                systemctl disable "$service1_full" "$service2_full" >/dev/null 2>&1; 
                rm -f "$main_conf_path" "$udp2raw_conf_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "6" || "$manage_choice" == "7" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}


# 2 组件串联实例的通用管理菜单
chain_manager_menu() {
    local chain_type=$1
    local title=""
    if [[ "$chain_type" == "hy2" ]]; then
        title="Hysteria2+UDP一键串联"
    else # vless
        title="VLESS_mKCP+UDP一键串联"
    fi
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances "$chain_type")
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "${chain_type}_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的串联实例。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的串联实例"; echo "2) 管理一个已存在的串联实例"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance "$chain_type"; read -p $'\n按任意键返回...' -n1 -s;;
            2) if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi; read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num; if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then manage_chain_instance "$chain_type" "$manage_id_num"; else red "无效的实例ID！"; sleep 2; fi;;
            3) if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi; local i; for i in $INSTANCES; do view_chain_client_config "$chain_type" $i; done; read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# 独立实例总管理菜单 (循环)
main_manager_loop() {
    local type=$1; local title dir pattern service_prefix type_lowercase
    case $type in 
        hysteria2) title="Hysteria2 (独立)"; dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml"; service_prefix="hysteria2"; type_lowercase="hysteria2";;
        udp2raw) title="UDP2RAW (独立)"; dir="$KCP_UDP_INSTALL_DIR"; pattern="udp2raw_*.conf"; service_prefix="udp2raw"; type_lowercase="udp2raw";;
        kcptun) title="KCPTUN (独立)"; dir="$KCP_UDP_INSTALL_DIR"; pattern="kcptun_*.json"; service_prefix="kcptun"; type_lowercase="kcptun";;
        xray_reality) title="VLESS+Reality (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="${XRAY_SERVICE_NAME}"; type_lowercase="xray_reality";;
        xray_mkcp) title="VLESS+mKCP (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="${XRAY_SERVICE_NAME}"; type_lowercase="xray_mkcp";;
        xray_ss) title="Shadowsocks (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="${XRAY_SERVICE_NAME}"; type_lowercase="xray_ss";;
    esac
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "     安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#INSTANCES[@]} -gt 0 ]]; then
            echo "$(bold "--- 已存在的实例 ---")"; for i in "${INSTANCES[@]}"; do display_instance_status_line "$type_lowercase" "$i" "  "; done
        else
            yellow "当前没有已创建的 $title 实例。"
        fi

        echo "----------------------------------"; local menu_options=("1) 启动一个新的实例" "2) 管理一个已存在的实例")
        if [[ "$type" == "hysteria2" ]]; then menu_options+=("3) 查看hy2订阅地址");
        elif [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then menu_options+=("3) 查看分享链接");
        elif [[ "$type" == "udp2raw" || "$type" == "kcptun" ]]; then menu_options+=("3) 查看客户端配置"); fi
        menu_options+=("0) 返回主菜单"); for opt in "${menu_options[@]}"; do echo "$opt"; done
        read -p "请选择: " choice
        case $choice in
            1)
                if [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then create_new_xray_instance "$type_lowercase"; else create_new_instance "$type_lowercase"; fi
                read -p $'\n按任意键返回...' -n1 -s;;
            2)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi
                local manage_id; read -p "请输入您想管理的实例ID [$(echo "${INSTANCES[@]}")]: " manage_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$manage_id" ]]; then is_valid=true; break; fi; done
                if [[ "$is_valid" == true ]]; then
                    local conf_path
                    case $type in
                        hysteria2) conf_path="$dir/hy2_${manage_id}.yaml";;
                        udp2raw) conf_path="$dir/udp2raw_${manage_id}.conf";;
                        kcptun) conf_path="$dir/kcptun_${manage_id}.json";;
                        xray_reality|xray_mkcp|xray_ss) conf_path="$dir/xray_${manage_id}.json";;
                    esac
                    manage_instance_menu "$type_lowercase" "$manage_id" "${service_prefix}@${manage_id}" "$conf_path"
                else red "无效的实例ID！"; sleep 2; fi;;
            3)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi
                if [[ "$type" == "hysteria2" ]]; then view_all_hy2_subscriptions
                else
                    local view_id; read -p "请输入您想查看的实例ID [$(echo "${INSTANCES[@]}")]: " view_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$view_id" ]]; then is_valid=true; break; fi; done
                    if [[ "$is_valid" == true ]]; then
                        case "$type" in
                            udp2raw) view_udp2raw_client_config "$view_id" ;;
                            kcptun) view_kcptun_client_config "$view_id" ;;
                            xray_reality) cyan "$(generate_xray_reality_link "$view_id")" ;;
                            xray_mkcp) cyan "$(generate_xray_mkcp_link "$view_id")" ;;
                            xray_ss) cyan "$(generate_xray_ss_link "$view_id")" ;;
                        esac
                    else red "无效的实例ID！"; fi
                fi
                read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# --- 17. 全局操作 (查看全部/重启/更新/卸载) (REFACTORED: 修复卸载路径) ---

# 查看全部实例的客户端配置
view_all_configs() {
    clear; echo "=================================="; echo "        查看全部实例配置"; echo "=================================="; echo
    
    local ss_3_chain_instances=$(get_chain_instances_3); if [[ -n "$ss_3_chain_instances" ]]; then for i in $ss_3_chain_instances; do view_chain_client_config_3 "$i"; echo "----------------------------------"; done; fi
    local hy2_chain_instances=$(get_chain_instances "hy2"); if [[ -n "$hy2_chain_instances" ]]; then for i in $hy2_chain_instances; do view_chain_client_config "hy2" "$i"; echo "----------------------------------"; done; fi
    local vless_chain_instances=$(get_chain_instances "vless"); if [[ -n "$vless_chain_instances" ]]; then for i in $vless_chain_instances; do echo; view_chain_client_config "vless" "$i"; echo "----------------------------------"; done; fi
    
    local standalone_hy2=($(get_standalone_instances "hysteria2")); if [[ ${#standalone_hy2[@]} -gt 0 ]]; then echo; cyan "--- Hysteria2 (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_hy2[@]}"; do green "$(generate_hy2_subscription_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_reality=($(get_standalone_instances "xray_reality")); if [[ ${#standalone_reality[@]} -gt 0 ]]; then echo; cyan "--- VLESS+Reality (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_reality[@]}"; do green "$(generate_xray_reality_link $id)"; done; echo "----------------------------------"; fi
    local standalone_mkcp=($(get_standalone_instances "xray_mkcp")); if [[ ${#standalone_mkcp[@]} -gt 0 ]]; then echo; cyan "--- VLESS+mKCP (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_mkcp[@]}"; do green "$(generate_xray_mkcp_link $id)"; done; echo "----------------------------------"; fi
    local standalone_ss=($(get_standalone_instances "xray_ss")); if [[ ${#standalone_ss[@]} -gt 0 ]]; then echo; cyan "--- Shadowsocks (独立) 实例订阅链接 ---"; echo
    for id in "${standalone_ss[@]}"; do green "$(generate_xray_ss_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_udp2raw=($(get_standalone_instances "udp2raw")); if [[ ${#standalone_udp2raw[@]} -gt 0 ]]; then echo; for id in "${standalone_udp2raw[@]}"; do view_udp2raw_client_config "$id"; echo; done; echo "----------------------------------"; fi
    local standalone_kcptun=($(get_standalone_instances "kcptun")); if [[ ${#standalone_kcptun[@]} -gt 0 ]]; then echo; for id in "${standalone_kcptun[@]}"; do view_kcptun_client_config "$id"; echo; done; fi

    if ! is_installed; then yellow "系统中没有任何已配置的实例。"; fi
}

# 重启所有服务
restart_all_services(){ log "正在重启所有正在运行的实例..."; systemctl restart kcptun@*.service udp2raw@*.service hysteria2@*.service ${XRAY_SERVICE_NAME}@*.service 2>/dev/null; green "操作完成！"; sleep 2; }

# 检查并更新所有核心程序
check_for_updates(){ log "检查更新..."; download_kcp_udp_binaries; download_hysteria2_binary; download_xray_binary; log "所有程序已更新到最新版本，重启所有服务以应用..."; restart_all_services; sleep 2;}

# 日志函数 (假设已存在)
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

# 绿色输出函数 (假设已存在)
green() {
    echo -e "\033[32m$1\033[0m"
}

# 安装 x-ui-yg
install_x_ui_yg() {
    echo "----------------------------------------------------------------"
    # 检查 x-ui 命令是否存在
    if command -v x-ui > /dev/null 2>&1; then
        log "检测到 x-ui 已安装，直接运行 x-ui..."
        x-ui # 直接运行 x-ui 命令 (通常会显示菜单或状态)
    else
        log "x-ui 未安装，即将开始安装 x-ui-yg... (来自 yonggekkk)"
        bash <(wget -qO- https://raw.githubusercontent.com/yonggekkk/x-ui-yg/main/install.sh)
    fi
    echo "----------------------------------------------------------------"
    green "x-ui-yg 脚本执行完毕。"
    log "即将返回主菜单..."
}

# 安装 BBR (ylx2016)
install_bbr_ylx2016() {
    echo "----------------------------------------------------------------"
    # 检查 tcp.sh 脚本是否存在于当前目录
    if [ -f "tcp.sh" ]; then
        log "检测到 tcp.sh 已存在，直接运行..."
        chmod +x tcp.sh # 确保有执行权限
        ./tcp.sh
    else
        log "tcp.sh 不存在，即将开始下载并安装 BBR (ylx2016)..."
        wget -O tcp.sh "https://github.com/ylx2016/Linux-NetSpeed/raw/master/tcp.sh" && chmod +x tcp.sh && ./tcp.sh
    fi
    echo "----------------------------------------------------------------"
    green "BBR (ylx2016) 脚本执行完毕。"
    log "即将返回主菜单..."
}

# 安装 WARP (fscarmen)
install_warp_fscarmen() {
    echo "----------------------------------------------------------------"
    local warp_option=""
    local warp_extra=""
    local script_to_run="menu.sh" # 脚本名

    # 检查 menu.sh 脚本是否存在于当前目录
    if [ -f "$script_to_run" ]; then
        log "检测到 $script_to_run 已存在，直接运行..."
        chmod +x "$script_to_run" # 确保有执行权限
    else
        log "$script_to_run 不存在，即将开始下载 WARP (fscarmen)..."
        wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh
        # 检查下载是否成功
        if [ ! -f "$script_to_run" ]; then
             echo "----------------------------------------------------------------"
             echo "错误：下载 $script_to_run 失败！请检查网络或链接。"
             log "即将返回主菜单..."
             return 1 # 返回错误状态
        fi
        chmod +x "$script_to_run"
    fi

    # 询问参数 (无论脚本是已存在还是刚下载)
    read -p "请输入参数 (c - 安装 WARP Linux Client，开启 Socks5 代理模式, i - 刷新IP, 留空则不带参数): " warp_option
    if [[ -n "$warp_option" ]]; then
        read -p "请输入许可证/URL/Token (可选, 留空则不带): " warp_extra
    fi

    # 执行脚本
    log "执行 $script_to_run ..."
    if [[ -n "$warp_option" && -n "$warp_extra" ]]; then
        bash "$script_to_run" "$warp_option" "$warp_extra"
    elif [[ -n "$warp_option" ]]; then
        bash "$script_to_run" "$warp_option"
    else
        bash "$script_to_run"
    fi

    echo "----------------------------------------------------------------"
    green "WARP (fscarmen) 脚本执行完毕。"
    log "即将返回主菜单..."
}


# 卸载所有 (REFACTORED: 修复软卸载路径)
uninstall_all() {
    read -p "确认要卸载吗？[y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then 
        yellow "操作已取消。"
        return 1
    fi
    
    read -p "是否要执行彻底清理（删除所有配置文件和证书）？[y/N]: " nuke_choice
    log "开始卸载流程..."
    log "步骤 1: 停止并禁用所有相关服务..."
    systemctl stop "kcptun@*.service" "udp2raw@*.service" "hysteria2@*.service" "${XRAY_SERVICE_NAME}@*.service" "hysteria-server@*.service" 2>/dev/null
    systemctl disable "kcptun@*.service" "udp2raw@*.service" "hysteria2@*.service" "${XRAY_SERVICE_NAME}@*.service" "hysteria-server@*.service" 2>/dev/null
    green "服务已停止并禁用。"
    log "步骤 2: 删除所有 systemd 服务文件..."
    rm -f /etc/systemd/system/kcptun@.service \
          /etc/systemd/system/udp2raw@.service \
          /etc/systemd/system/hysteria2@.service \
          /etc/systemd/system/${XRAY_SERVICE_NAME}@.service \
          /etc/systemd/system/hysteria-server@.service
    green "Systemd 服务文件已删除。"
    if [[ "$nuke_choice" == "y" || "$nuke_choice" == "Y" ]]; then
        log "步骤 3: 执行彻底清理..."
        rm -rf "$KCP_UDP_INSTALL_DIR" "$HY2_INSTALL_DIR" "$XRAY_INSTALL_DIR"
        green "程序和配置文件目录已删除。"
        log "步骤 4: 删除生成的证书..."
        rm -f /etc/ssl/private/bing.com.crt /etc/ssl/private/bing.com.key
        green "自签名证书已删除。"
    else
        log "步骤 3: 执行软卸载 (仅删除二进制文件和 dat 文件)..."
        rm -f "$KCP_UDP_INSTALL_DIR/kcptun_server" "$KCP_UDP_INSTALL_DIR/udp2raw"
        rm -f "$HY2_INSTALL_DIR/hysteria" "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat"
        rm -f "$XRAY_INSTALL_DIR/xray" "$XRAY_INSTALL_DIR/geoip.dat" "$XRAY_INSTALL_DIR/geosite.dat"
        green "程序文件已删除。"
    fi
    log "步骤 5: 清理残留的二进制文件..."
    rm -f /usr/local/bin/hysteria
    green "残留二进制文件已清理。"
    log "步骤 6: 清理临时文件..."
    rm -f /tmp/kcptun.tar.gz /tmp/udp2raw.tar.gz /tmp/xray.zip
    log "步骤 7: 重载 systemd 并清理状态..."
    systemctl daemon-reload; systemctl reset-failed
    green "Systemd 已重载并清理。"
    echo; green "==== 卸载完成！ ===="; yellow "提示：依赖包 (如 curl, openssl, jq) 未被卸载。"; yellow "提示：请手动删除此脚本文件。"; sleep 3
    return 0
}

# --- 18. 脚本入口与初始化  ---

# --- 系统兼容性检查函数 ---
check_system_compatibility() {
    # 检查是否为root用户
    if [[ $EUID -ne 0 ]]; then
        red "错误: 此脚本必须以root用户身份运行"
        exit 1
    fi
    
    # 检查系统是否使用systemd
    if ! command -v systemctl &> /dev/null; then
        red "错误: 此脚本需要systemd支持，但您的系统似乎没有安装systemd"
        exit 1
    fi
    
    # 检查必要的命令是否可用
    local required_commands=("curl" "wget" "jq" "openssl")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        yellow "警告: 以下必要命令在系统中不可用:"
        for cmd in "${missing_commands[@]}"; do
            echo "  - $cmd"
        done
        yellow "将尝试在初始化过程中安装这些依赖"
    fi
}

# 首次运行检查和安装核心程序
initial_check_and_install() {
    # 添加系统兼容性检查
    check_system_compatibility
    
    install_dependencies
    local has_configs=false
    if is_installed; then has_configs=true; fi
    
    # [REFACTORED] 检查根目录下的文件
    local kcp_udp_ok=true; if [[ ! -f "$KCP_UDP_INSTALL_DIR/kcptun_server" || ! -f "$KCP_UDP_INSTALL_DIR/udp2raw" ]]; then kcp_udp_ok=false; fi
    local hy2_ok=true; if [[ ! -f "$HY2_INSTALL_DIR/hysteria" ]]; then hy2_ok=false; fi
    local xray_ok=true; if [[ ! -f "$XRAY_INSTALL_DIR/xray" ]]; then xray_ok=false; fi
    
    if [[ "$has_configs" == true && ( "$kcp_udp_ok" == false || "$hy2_ok" == false || "$xray_ok" == false ) ]]; then
        clear; yellow "检测到已存在的配置文件，但核心程序文件不完整。"; read -p "是否保留配置并仅重新安装核心程序？[Y/n]: " choice
        if [[ "$choice" != "n" && "$choice" != "N" ]]; then
            log "正在重新安装核心程序..."
            [[ "$kcp_udp_ok" == false ]] && download_kcp_udp_binaries
            [[ "$hy2_ok" == false ]] && download_hysteria2_binary
            [[ "$xray_ok" == false ]] && download_xray_binary
            green "核心程序重装完成。"; sleep 2
        else
            uninstall_all; exit 0
        fi
    elif [[ "$kcp_udp_ok" == false || "$hy2_ok" == false || "$xray_ok" == false ]]; then
        clear; yellow "首次运行或程序不完整，需要下载核心程序文件。"; log "正在自动下载所有核心程序..."
        [[ "$kcp_udp_ok" == false ]] && (download_kcp_udp_binaries || { red "KCP/UDP 下载失败，退出。"; exit 1; })
        [[ "$hy2_ok" == false ]] && (download_hysteria2_binary || { red "Hysteria2 下载失败，退出。"; exit 1; })
        [[ "$xray_ok" == false ]] && (download_xray_binary || { red "Xray-core 下载失败，退出。"; exit 1; })
        green "核心程序准备就绪。"; sleep 2
    fi
    ensure_template_files; sleep 1
}

# 主菜单状态总览 (使用粗体标题)
show_status_summary() {
    local menu_index=21; echo "--- 当前状态 (输入序号可直接管理) ---"; if ! is_installed; then yellow "未安装任何组件。"; return; fi
    
    local ss_3_chain_instances=$(get_chain_instances_3)
    if [[ -n "$ss_3_chain_instances" ]]; then
        echo "$(bold "SS+KCP+UDP 串联实例:")"
        for i in $ss_3_chain_instances; do display_instance_status_line "ss_3_chain_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="ss_3_chain_chain"; menu_index=$((menu_index + 1)); done
    fi
    local hy2_chain_instances=$(get_chain_instances "hy2")
    if [[ -n "$hy2_chain_instances" ]]; then
        echo "$(bold "Hysteria2+UDP 串联实例:")"
        for i in $hy2_chain_instances; do display_instance_status_line "hy2_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="hy2_chain"; menu_index=$((menu_index + 1)); done
    fi
    local vless_chain_instances=$(get_chain_instances "vless")
    if [[ -n "$vless_chain_instances" ]]; then
        echo "$(bold "VLESS_mKCP+UDP 串联实例:")"
        for i in $vless_chain_instances; do display_instance_status_line "vless_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="vless_chain"; menu_index=$((menu_index + 1)); done
    fi

    for type in "Hysteria2" "VLESS+Reality" "VLESS+mKCP" "Shadowsocks" "UDP2RAW" "KCPTUN"; do
        local type_lowercase=""
        case "$type" in
            "Hysteria2") type_lowercase="hysteria2";;
            "VLESS+Reality") type_lowercase="xray_reality";;
            "VLESS+mKCP") type_lowercase="xray_mkcp";;
            "Shadowsocks") type_lowercase="xray_ss";;
            "UDP2RAW") type_lowercase="udp2raw";;
            "KCPTUN") type_lowercase="kcptun";;
        esac
        
        local standalone_instances=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#standalone_instances[@]} -gt 0 ]]; then
            echo "$(bold "${type} (独立) 实例:")"
            for i in "${standalone_instances[@]}"; do
                display_instance_status_line "$type_lowercase" "$i" "$menu_index) "
                QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="$type_lowercase"; menu_index=$((menu_index + 1))
            done
        fi
    done
}

# 主菜单 
main_menu(){
    declare -A QUICK_MANAGE_MAP_ID; declare -A QUICK_MANAGE_MAP_TYPE
    while true; do
        QUICK_MANAGE_MAP_ID=(); QUICK_MANAGE_MAP_TYPE=()
        trap '' SIGINT
        clear; echo "=================================="; echo "  四合一隧道管理脚本 V$SCRIPT_VERSION"; echo "=================================="
        cyan "--- 串联管理 ---"
        echo " 1) Hysteria2+UDP2RAW 串联"
        echo " 2) VLESS_mKCP+UDP2RAW 串联"
        echo " 3) Shadowsocks+KCP+UDP 串联"
        cyan "--- 独立实例管理 ---"
        echo " 4) Hysteria2"
        echo " 5) VLESS+Reality"
        echo " 6) VLESS+mKCP"
        echo " 7) Shadowsocks"
        cyan "--- 加速管理 ---"
        echo " 8) UDP2RAW"
        echo " 9) KCPTUN"
        echo "----------------------------------"
        cyan "--- 全局操作 ---"
        echo " 10) 查看全部配置"
        echo " 11) 重启全部服务"
        echo " 12) 检查更新程序" 
        cyan "--- 工具管理 ---"
        echo " 13) 安装x-ui (yg版)"
        echo " 14) 安装BBR脚本 (ylx2016版)"
        echo " 15) 安装WARP脚本 (fscarmen版)"
        echo "----------------------------------"   
        echo " 99) 卸载"
        echo " 0) 退出"
        echo "----------------------------------"
        show_status_summary
        local num_items=${#QUICK_MANAGE_MAP_ID[@]}; local max_index=$((20 + num_items))
        echo "----------------------------------"
        local prompt="请选择 [0-15, 99"; if [[ $num_items -gt 0 ]]; then prompt+=", 21-${max_index}]"; else prompt+="]"; fi
        read -p "$prompt： " choice
        
        if [[ -n "${QUICK_MANAGE_MAP_ID[$choice]}" ]]; then
            local real_id="${QUICK_MANAGE_MAP_ID[$choice]}"; local type="${QUICK_MANAGE_MAP_TYPE[$choice]}"
            case "$type" in
                "ss_3_chain_chain") manage_chain_instance_3 "$real_id" ;;
                "hy2_chain") manage_chain_instance "hy2" "$real_id" ;;
                "vless_chain") manage_chain_instance "vless" "$real_id" ;;
                "hysteria2") manage_instance_menu "hysteria2" "$real_id" "hysteria2@${real_id}" "$HY2_INSTALL_DIR/hy2_${real_id}.yaml" ;;
                "xray_reality") manage_instance_menu "xray_reality" "$real_id" "${XRAY_SERVICE_NAME}@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "xray_mkcp") manage_instance_menu "xray_mkcp" "$real_id" "${XRAY_SERVICE_NAME}@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "xray_ss") manage_instance_menu "xray_ss" "$real_id" "${XRAY_SERVICE_NAME}@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "udp2raw") manage_instance_menu "udp2raw" "$real_id" "udp2raw@${real_id}" "$KCP_UDP_INSTALL_DIR/udp2raw_${real_id}.conf" ;;
                "kcptun") manage_instance_menu "kcptun" "$real_id" "kcptun@${real_id}" "$KCP_UDP_INSTALL_DIR/kcptun_${real_id}.json" ;;
            esac
            continue
        fi
        
        case $choice in
            1) chain_manager_menu "hy2" ;;
            2) chain_manager_menu "vless" ;;
            3) chain_manager_menu_3 ;;
            4) main_manager_loop "hysteria2" ;; 
            5) main_manager_loop "xray_reality" ;;
            6) main_manager_loop "xray_mkcp" ;; 
            7) main_manager_loop "xray_ss" ;;
            8) main_manager_loop "udp2raw" ;;
            9) main_manager_loop "kcptun" ;;
            10) view_all_configs; read -p $'\n按任意键返回...' -n1 -s;;
            11) restart_all_services ;;
            12) check_for_updates; read -p "按任意键继续..." -n1 -s ;;
            13) clear; install_x_ui_yg; read -p $'\n按任意键返回...' -n1 -s ;;
            14) clear; install_bbr_ylx2016; read -p $'\n按任意键返回...' -n1 -s ;;
            15) clear; install_warp_fscarmen; read -p $'\n按任意键返回...' -n1 -s ;;
            99) uninstall_all; if [[ $? -eq 0 ]]; then exit 0; fi ;;
            0) trap - SIGINT; exit 0 ;; 
            *) red "无效选择!"; sleep 1 ;;
        esac
    done
}

# --- 19. 脚本执行入口 ---
# 捕获 Ctrl+C 信号，以便在脚本主体执行期间优雅退出
trap 'echo -e "\n\n${yellow}操作被中断，退出脚本。${reset}"; trap - SIGINT; exit 1' SIGINT
# 初始化检查和安装
initial_check_and_install
# 显示主菜单
main_menu
