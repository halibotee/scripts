#!/bin/bash
# VPS优化脚本 
# Generated by github.com/halibotee

SCRIPT_VERSION="1.4.2"

set -euo pipefail
IFS=$'\n\t'

export FORCE_YES=0
if [ "${1:-}" = "-y" ] || [ "${1:-}" = "--yes" ]; then
    FORCE_YES=1
fi


BACKUP_DIR="/etc/vps_optimizert_backup"
LOG_FILE="/var/log/vps_optimizert.log"
ACTION_LOG="${BACKUP_DIR}/actions.log"
export DEBIAN_FRONTEND=noninteractive

# 全局变量存储网络参数
NETWORK_LATENCY=""
NETWORK_LOCAL_BW=""
NETWORK_VPS_BW=""
NETWORK_VPS_MEM=""
DISABLE_IPV6="y"

declare -ga PKG_CMD_INSTALL
declare -ga PKG_CMD_REMOVE
declare -ga PKG_CMD_CHECK
declare -ga PKG_CMD_UPDATE

FN_TRIM_SERVICES_LIST=(
"systemd-resolved.service"
"ModemManager.service"
"rpcbind.service"
"unattended-upgrades.service"
"bluetooth.service"
)

FN_NETWORK_SERVICES_LIST=(
"xray"
"hysteria2"
"hysteria"
"udp2raw"
"kcptun"
"ax-xray@*"
"ax-hysteria2@*"
"ax-udp2raw@*"
"ax-kcptun@*"
"xray@*"
"hysteria2@*"
"udp2raw@*"
"kcptun@*"
)

mkdir -p "$BACKUP_DIR"
touch "$LOG_FILE"
> "$LOG_FILE"
touch "$ACTION_LOG"

fn_log() {
    if [ -z "${LOG_Y_RECORDED:-}" ]; then
        if [ $FORCE_YES -eq 1 ]; then
            local ts=$(date '+%F %T')
            printf '%s [%s] %s\n' "$ts" "警告" "非交互模式 (-y) 已激活。将自动同意所有提示。" >> "$LOG_FILE"
        fi
        export LOG_Y_RECORDED=1
    fi
    
local level="$1"; shift
local msg="$*"
local ts
ts=$(date '+%F %T')
printf '%s [%s] %s\n' "$ts" "$level" "$msg" >> "$LOG_FILE"
}

fn_log_action() {
    local action="$1"
    local value="$2"
    echo "${action}:${value}" >> "$ACTION_LOG"
    fn_log "调试" "记录操作: ${action}:${value}"
}

fn_check_if_optimized() {
    if [ ! -f "$ACTION_LOG" ]; then
        return 1
    fi
    
    local action_count
    action_count=$(grep -vc -E '(^#|^$)' "$ACTION_LOG" 2>/dev/null || true)
    
    if [ "${action_count:-0}" -gt 0 ]; then
        return 0
    else
        return 1
    fi
}

fn_check_root() {
if [ "$EUID" -ne 0 ]; then
echo "错误: 本脚本必须以 root 权限运行。"
fn_log "错误" "本脚本必须以 root 权限运行。"
exit 1
fi
}

fn_check_pkg_lock() {
    if [ "$OS_ID" = "debian" ] || [ "$OS_ID" = "ubuntu" ]; then
        if fuser /var/lib/dpkg/lock-frontend > /dev/null 2>&1 || fuser /var/lib/dpkg/lock > /dev/null 2>&1; then
            fn_log "警告" "检测到 APT/DPKG 锁。"
            return 1
        fi
    elif [ "$OS_ID" = "fedora" ] || [ "$OS_ID" = "rhel" ] || [ "$OS_ID" = "centos" ] || [ "$OS_ID" = "almalinux" ] || [ "$OS_ID" = "rocky" ]; then
        if [ -f /var/cache/dnf/metadata_lock.pid ] && pgrep -F /var/cache/dnf/metadata_lock.pid > /dev/null 2>&1; then
            fn_log "警告" "检测到 DNF 锁。"
            return 1
        fi
    fi
    return 0
}

fn_wait_for_pkg_lock() {
    local max_wait=120
    local count=0
    fn_log "信息" "检查包管理器锁..."
    while ! fn_check_pkg_lock; do
        if [ "$count" -ge "$max_wait" ]; then
            fn_log "错误" "等待包管理器锁超时 (120 秒)。操作可能失败。"
            return 1
        fi
        fn_log "警告" "检测到包管理器锁，等待 5 秒... ($count/$max_wait)"
        sleep 5
        count=$((count + 5))
    done
    fn_log "信息" "包管理器锁已释放。"
    return 0
}

fn_detect_os() {
    
    if [ -f /etc/os-release ]; then
        source /etc/os-release
        OS_PRETTY="${PRETTY_NAME:-unknown}"
        OS_ID="${ID:-unknown}"
        OS_VER="${VERSION_ID:-unknown}"
        echo "检测到操作系统: $OS_PRETTY"
        fn_log "信息" "检测到操作系统: $OS_PRETTY"
    else
        echo "错误: 无法检测到操作系统 (/etc/os-release 不存在)。"
        fn_log "错误" "无法检测到操作系统 (/etc/os-release 不存在)。"
        exit 1
    fi

    case "$OS_ID" in
        debian|ubuntu)
            PKG_CMD_INSTALL=("apt-get" "install" "-y")
            PKG_CMD_REMOVE=("apt-get" "remove" "-y" "--purge")
            PKG_CMD_CHECK=("dpkg" "-s")
            PKG_CMD_UPDATE=("apt-get" "update")
            ;;
        fedora|rhel|centos|almalinux|rocky)
            PKG_CMD_INSTALL=("dnf" "install" "-y")
            PKG_CMD_REMOVE=("dnf" "remove" "-y")
            PKG_CMD_CHECK=("rpm" "-q")
            PKG_CMD_UPDATE=("dnf" "check-update" "--quiet")
            ;;
        *)
            echo "错误: 不支持的操作系统 $OS_ID。"
            fn_log "错误" "不支持的操作系统 $OS_ID。"
            exit 1
            ;;
    esac

    MEM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}' || echo 0)
    MEM_MB=$(( MEM_KB / 1024 ))
    echo "物理内存: ${MEM_MB} MB"
    fn_log "信息" "物理内存: ${MEM_MB} MB"
    if ! command -v systemctl > /dev/null 2>&1; then
        echo "错误: 未找到 Systemd。本脚本需要 systemd。"
        fn_log "错误" "未找到 Systemd。本脚本需要 systemd。"
        exit 1
    fi
}

fn_backup_state() {
fn_log "信息" "正在创建备份于 $BACKUP_DIR ..."
mkdir -p "$BACKUP_DIR" || { fn_log "错误" "无法创建 $BACKUP_DIR"; return 1; }
cp -an /etc/fstab "${BACKUP_DIR}/fstab.bak" 2>/dev/null || true
cp -an /etc/systemd/resolved.conf "${BACKUP_DIR}/resolved.conf.bak" 2>/dev/null || true
cp -an /etc/sysctl.conf "${BACKUP_DIR}/sysctl.conf.bak" 2>/dev/null || true
cp -ran /etc/sysctl.d "${BACKUP_DIR}/sysctl.d.bak" 2>/dev/null || true
cp -ran /etc/systemd/journald.conf.d "${BACKUP_DIR}/journald.conf.d.bak" 2>/dev/null || true
[ -f /etc/selinux/config ] && cp -an /etc/selinux/config "${BACKUP_DIR}/selinux.config.bak" 2>/dev/null || true
sysctl -n net.ipv4.tcp_congestion_control > "${BACKUP_DIR}/sysctl_con_algo.bak" 2>/dev/null || true
sysctl -n net.core.default_qdisc > "${BACKUP_DIR}/sysctl_q_algo.bak" 2>/dev/null || true

systemctl list-unit-files --type=service --state=enabled | awk '/enabled/ {print $1}' > "${BACKUP_DIR}/enabled_services.before.txt" 2>/dev/null || true

echo "# vps_optimizert action log ($(date))" > "$ACTION_LOG"

fn_log "信息" "备份完成。"
return 0
}

fn_fix_apt_sources_if_needed() {
fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
fn_log "信息" "检查包管理器源健康状况..."

if [ "$OS_ID" = "debian" ] || [ "$OS_ID" = "ubuntu" ]; then
    mkdir -p /etc/apt/apt.conf.d
    cat > /etc/apt/apt.conf.d/99-force-ipv4 <<'EOF'
Acquire::ForceIPv4 "true";
EOF
    fn_log "调试" "已创建 /etc/apt/apt.conf.d/99-force-ipv4 (强制 APT 使用 IPv4)"
    fn_log_action "CREATE_FILE" "/etc/apt/apt.conf.d/99-force-ipv4"
fi

if "${PKG_CMD_UPDATE[@]}"; then
fn_log "成功" "包管理器源正常。"
return 0
else
fn_log "警告" "包管理器 update 失败。将尝试保守替换 sources.list (仅限 Debian/Ubuntu)"

if [ "$OS_ID" = "debian" ] || [ "$OS_ID" = "ubuntu" ]; then
    if command -v lsb_release > /dev/null 2>&1; then
        codename=$(lsb_release -cs)
    else
        codename=$(grep VERSION_CODENAME /etc/os-release 2>/dev/null | cut -d= -f2 || true)
    fi
    if [ -z "${codename:-}" ]; then
        fn_log "错误" "无法确定发行版代号，跳过自动替换源。"
        return 1
    fi
    cp -an /etc/apt/sources.list "${BACKUP_DIR}/apt.sources.list.bak" 2>/dev/null || true
    
    if [ "$OS_ID" = "debian" ]; then
cat > /etc/apt/sources.list <<EOF
deb http://deb.debian.org/debian/ $codename main contrib non-free non-free-firmware
deb http://deb.debian.org/debian/ $codename-updates main contrib non-free non-free-firmware
deb http://security.debian.org/debian-security/ $codename-security main contrib non-free non-free-firmware
EOF
    elif [ "$OS_ID" = "ubuntu" ]; then
cat > /etc/apt/sources.list <<EOF
deb http://archive.ubuntu.com/ubuntu/ $codename main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ $codename-updates main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu/ $codename-security main restricted universe multiverse
EOF
    fi
else
    fn_log "错误" "此操作系统不支持自动替换源。"
    return 1
fi

if "${PKG_CMD_UPDATE[@]}"; then
    fn_log "成功" "APT 源替换并刷新成功。"
    return 0
else
    local update_cmd_str="${PKG_CMD_UPDATE[@]}"
    fn_log "错误" "替换源后 ${update_cmd_str} 仍然失败。"
    echo "-----------------------------------------------------"
    echo "[错误] 致命错误: 'apt update' 彻底失败。"
    echo "       请检查 DNS (例如 /etc/resolv.conf) 和网络连接。"
    echo "-----------------------------------------------------"
    return 1
fi
fi
}

fn_handle_selinux() {
    fn_log "信息" "检查 SELinux 状态..."
    
    if command -v getenforce > /dev/null 2>&1; then
        local selinux_status
        selinux_status=$(getenforce)

        if [ "$selinux_status" != "Disabled" ]; then
            fn_log "警告" "检测到 SELinux 状态为: $selinux_status"
            echo "-----------------------------------------------------"
            echo "警告: 检测到 SELinux 状态为: $selinux_status"
            echo "SELinux 会导致性能问题并可能与优化冲突。"
            
            local selinux_choice="n"
            if [ $FORCE_YES -eq 1 ]; then
                selinux_choice="y"
                echo "非交互模式: 自动同意禁用 SELinux。"
                fn_log "信息" "非交互模式: 自动同意禁用 SELinux。"
            else
                read -rp "是否要将其永久禁用 (推荐)? (y/n): " selinux_choice || true
            fi
            
            if [ "$selinux_choice" = "y" ] || [ "$selinux_choice" = "Y" ]; then
                echo "正在禁用 SELinux..."
                fn_log "信息" "正在禁用 SELinux..."
                setenforce 0 2>/dev/null || fn_log "警告" "setenforce 0 失败 (可能无权限或已禁用)。"
                if [ -f /etc/selinux/config ]; then
                    sed -i.bak 's/^SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config
                    fn_log_action "MODIFY_FILE" "/etc/selinux/config"
                    echo "SELinux 已永久禁用。需要重启生效。"
                    fn_log "成功" "SELinux 已永久禁用。需要重启生效。"
                else
                    echo "错误: 未找到 /etc/selinux/config，无法永久禁用。"
                    fn_log "错误" "未找到 /etc/selinux/config，无法永久禁用。"
                fi
            else
                echo "跳过禁用 SELinux。"
                fn_log "警告" "跳过禁用 SELinux。这可能导致后续步骤失败。"
            fi
        else
             fn_log "信息" "SELinux 状态: Disabled (良好)。"
             return 2
        fi
    else
        fn_log "信息" "未检测到 SELinux (正常)。"
        return 2
    fi
    return 0
}

fn_setup_fail2ban() {
    fn_log "信息" "配置 Fail2ban..."
    
    if systemctl is-active fail2ban > /dev/null 2>&1; then
        fn_log "信息" "Fail2ban 已安装并激活，跳过。"
        return 2
    fi
    
    if "${PKG_CMD_CHECK[@]}" fail2ban > /dev/null 2>&1; then
        fn_log "信息" "Fail2ban 已安装 (但未运行)。"
    else
        fn_log "信息" "正在安装 Fail2ban..."
        fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
        "${PKG_CMD_INSTALL[@]}" fail2ban >>"$LOG_FILE" 2>&1 || { 
            fn_log "警告" "Fail2ban 安装失败。"; 
            return 1; 
        }
        fn_log_action "INSTALL_PKG" "fail2ban"
        fn_log "信息" "Fail2ban 安装完成。"
    fi
    
    fn_log "信息" "配置 Fail2ban backend 为 systemd (以修复 sshd jail 冲突)..."
    
    mkdir -p /etc/fail2ban/jail.d
    local conf_file="/etc/fail2ban/jail.d/99-vps_optimizert-systemd.conf"
    cat > "$conf_file" <<'EOF'
[DEFAULT]
backend = systemd

[sshd]
backend = systemd
EOF
    fn_log_action "CREATE_FILE" "$conf_file"
    fn_log "调试" "已创建 /etc/fail2ban/jail.d/99-vps_optimizert-systemd.conf"
    
    (systemctl enable --now fail2ban) >> "$LOG_FILE" 2>&1
    
    if systemctl is-active fail2ban > /dev/null 2>&1; then
        fn_log "成功" "Fail2ban 已激活。"
        return 0
    else
        fn_log "错误" "Fail2ban 启动失败 (即使在应用 systemd backend 修复后)。"
        return 1
    fi
}

fn_setup_journald_volatile() {
local journal_storage
journal_storage=$(systemd-analyze cat-config systemd/journald.conf | grep -i '^Storage=' | tail -n 1 | cut -d= -f2 2>/dev/null || echo "disk")
if [ "$journal_storage" == "volatile" ]; then
    fn_log "信息" "journald 已是 volatile 模式，跳过。"
    return 2
fi

fn_log "信息" "配置 journald 为 volatile (内存) 模式 (RuntimeMaxUse=16M)..."
mkdir -p /etc/systemd/journald.conf.d
local conf_file="/etc/systemd/journald.conf.d/10-volatile.conf"
cat > "$conf_file" <<'EOF'
[Journal]
Storage=volatile
RuntimeMaxUse=16M
MaxRetentionSec=1month
EOF
fn_log_action "CREATE_FILE" "$conf_file"
systemctl restart systemd-journald > /dev/null 2>&1 || true
fn_log "成功" "journald 已配置为 volatile 模式。"
return 0
}


# 网络配置优化方案 (来自 tcp.sh 菜单27)
fn_setup_aggressive_network() {
    echo "[任务] 系统配置优化激进方案 - 交互式参数配置"
    echo "-----------------------------------------------------"
    
    # 设置默认值
    local latency_default=180
    local local_bw_default=500
    local vps_bw_default=100
    local vps_mem_default=$(awk '/MemTotal/ {print int($2/1024)}' /proc/meminfo)
    
    # 如果是非交互模式，直接使用默认值
    if [ $FORCE_YES -eq 1 ]; then
        NETWORK_LATENCY=$latency_default
        NETWORK_LOCAL_BW=$local_bw_default
        NETWORK_VPS_BW=$vps_bw_default
        NETWORK_VPS_MEM=$vps_mem_default
        echo "非交互模式: 使用默认参数 (延迟=${NETWORK_LATENCY}ms, 本地带宽=${NETWORK_LOCAL_BW}Mbps, VPS带宽=${NETWORK_VPS_BW}Mbps, 内存=${NETWORK_VPS_MEM}MB)"
        fn_log "信息" "非交互模式: 使用网络优化默认参数"
    else
        # 交互式输入
        echo "请输入网络优化参数（用空格隔开）："
        echo "  参数: 延迟(ms) 本地带宽(Mbps) VPS带宽(Mbps)"
        echo "  说明: VPS内存将自动获取 (当前: ${vps_mem_default}MB)"
        echo ""
        echo "示例1 (完整参数): 180 500 100"
        echo "示例2 (单个参数): 1800  # 结果: 延迟=180ms, 其他使用默认值"
        echo ""
        echo "默认值: 延迟=${latency_default}ms, 本地带宽=${local_bw_default}Mbps, VPS带宽=${vps_bw_default}Mbps"
        echo "留空直接回车使用默认值，或输入自定义参数："
        
        local input
        read -r input || input=""
        
        if [ -z "$input" ]; then
            NETWORK_LATENCY=$latency_default
            NETWORK_LOCAL_BW=$local_bw_default
            NETWORK_VPS_BW=$vps_bw_default
            NETWORK_VPS_MEM=$vps_mem_default
            echo "使用默认参数"
        else
            IFS=' ' read -r latency local_bw vps_bw <<< "$input"
            NETWORK_LATENCY=${latency:-$latency_default}
            NETWORK_LOCAL_BW=${local_bw:-$local_bw_default}
            NETWORK_VPS_BW=${vps_bw:-$vps_bw_default}
            NETWORK_VPS_MEM=$vps_mem_default
        fi
    fi
    
    echo "最终参数: 延迟=${NETWORK_LATENCY}ms, 本地带宽=${NETWORK_LOCAL_BW}Mbps, VPS带宽=${NETWORK_VPS_BW}Mbps, 内存=${NETWORK_VPS_MEM}MB"
    echo "请按回车继续..."
    if [ $FORCE_YES -ne 1 ]; then
        read -r || true
    fi
    
    # 计算优化参数
    local min_bw=$((NETWORK_LOCAL_BW < NETWORK_VPS_BW ? NETWORK_LOCAL_BW : NETWORK_VPS_BW))
    local bdp=$((min_bw * 1000000 * NETWORK_LATENCY / 8 / 1000))
    
    local rmem_max=$((bdp * 2))
    local wmem_max=$((bdp * 3 / 2))
    local max_mem_bytes=$((NETWORK_VPS_MEM * 1024 * 1024 * 50 / 100))
    [[ $rmem_max -gt $max_mem_bytes ]] && rmem_max=$max_mem_bytes
    [[ $wmem_max -gt $max_mem_bytes ]] && wmem_max=$max_mem_bytes
    [[ $rmem_max -lt 1048576 ]] && rmem_max=1048576
    [[ $wmem_max -lt 1048576 ]] && wmem_max=1048576
    
    local netdev_max_backlog=$((min_bw * 10))
    [[ $netdev_max_backlog -gt 10000 ]] && netdev_max_backlog=10000
    [[ $netdev_max_backlog -lt 1000 ]] && netdev_max_backlog=1000
    
    local somaxconn=$((NETWORK_VPS_MEM * 20))
    [[ $somaxconn -gt 16384 ]] && somaxconn=16384
    [[ $somaxconn -lt 512 ]] && somaxconn=512
    
    local tcp_max_syn_backlog=$((somaxconn * 4))
    [[ $tcp_max_syn_backlog -gt 65536 ]] && tcp_max_syn_backlog=65536
    
    local tcp_init_cwnd=$((NETWORK_LATENCY / 20 + 10))
    [[ $tcp_init_cwnd -gt 32 ]] && tcp_init_cwnd=32
    [[ $tcp_init_cwnd -lt 10 ]] && tcp_init_cwnd=10
    
    local min_free_kbytes=$((NETWORK_VPS_MEM * 1024 * 12 / 100))
    [[ $min_free_kbytes -gt 524288 ]] && min_free_kbytes=524288
    [[ $min_free_kbytes -lt 65536 ]] && min_free_kbytes=65536
    
    # 创建配置文件 /etc/sysctl.d/99-net.conf
    local config_file="/etc/sysctl.d/99-net.conf"
    fn_log "信息" "创建网络优化配置: $config_file"
    
    cat > "$config_file" <<EOF
# 激进网络优化配置 - Generated by ax-optz.sh v${SCRIPT_VERSION}
# 延迟: ${NETWORK_LATENCY}ms, 本地带宽: ${NETWORK_LOCAL_BW}Mbps, VPS带宽: ${NETWORK_VPS_BW}Mbps, 内存: ${NETWORK_VPS_MEM}MB

# Kernel 参数
kernel.pid_max = 65535
kernel.panic = 1
kernel.sysrq = 1
kernel.core_pattern = core_%e
kernel.printk = 3 4 1 3
kernel.numa_balancing = 0
kernel.sched_autogroup_enabled = 0

# 虚拟内存
vm.swappiness = 5
vm.dirty_ratio = 5
vm.dirty_background_ratio = 2
vm.panic_on_oom = 1
vm.overcommit_memory = 1
vm.min_free_kbytes = ${min_free_kbytes}
vm.vfs_cache_pressure = 50

# 核心网络缓冲区
net.core.netdev_max_backlog = ${netdev_max_backlog}
net.core.rmem_max = ${rmem_max}
net.core.wmem_max = ${wmem_max}
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.somaxconn = ${somaxconn}
net.core.optmem_max = 262144

# 连接跟踪
net.netfilter.nf_conntrack_max = 262144
net.nf_conntrack_max = 262144

# TCP 优化
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 10
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_max_tw_buckets = 32768
net.ipv4.tcp_sack = 1
net.ipv4.tcp_fack = 1
net.ipv4.tcp_rmem = 32768 262144 ${rmem_max}
net.ipv4.tcp_wmem = 32768 262144 ${wmem_max}
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_notsent_lowat = 16384
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_adv_win_scale = 2
net.ipv4.tcp_moderate_rcvbuf = 1
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_init_cwnd = ${tcp_init_cwnd}
net.ipv4.tcp_max_syn_backlog = ${tcp_max_syn_backlog}
net.ipv4.tcp_max_orphans = 32768
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 2
net.ipv4.tcp_abort_on_overflow = 0
net.ipv4.tcp_stdurg = 0
net.ipv4.tcp_rfc1337 = 0
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 6
net.ipv4.tcp_ecn = 1
net.ipv4.tcp_ecn_fallback = 1
net.ipv4.tcp_frto = 0

# UDP 优化
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192

# IP 配置
net.ipv4.ip_forward = 1
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.ip_no_pmtu_disc = 0
net.ipv4.route.gc_timeout = 100

# Neighbor 配置
net.ipv4.neigh.default.gc_stale_time = 120
net.ipv4.neigh.default.gc_thresh3 = 4096
net.ipv4.neigh.default.gc_thresh2 = 2048
net.ipv4.neigh.default.gc_thresh1 = 512

# ICMP
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1

# 安全配置
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.all.route_localnet = 1

# 文件系统
fs.file-max = 1000000
fs.inotify.max_user_instances = 8192
EOF

    # 根据 IPv6 设置添加配置
    if [ "$DISABLE_IPV6" = "y" ] || [ "$DISABLE_IPV6" = "Y" ]; then
        cat >> "$config_file" <<EOF

# IPv6 禁用
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 0
EOF
    else
        cat >> "$config_file" <<EOF

# IPv6 启用
net.ipv6.conf.all.disable_ipv6 = 0
net.ipv6.conf.default.disable_ipv6 = 0
net.ipv6.conf.lo.disable_ipv6 = 0
net.ipv6.conf.all.accept_ra = 2
net.ipv6.conf.default.accept_ra = 2
net.ipv6.conf.all.forwarding = 1
net.ipv6.conf.default.forwarding = 1
net.ipv6.neigh.default.gc_thresh3 = 8192
net.ipv6.neigh.default.gc_thresh2 = 4096
net.ipv6.neigh.default.gc_thresh1 = 2048
EOF
    fi
    
    fn_log_action "CREATE_FILE" "$config_file"
    fn_log "成功" "网络优化配置文件已创建: $config_file"
    
    return 0
}

# 启用 BBR+FQ
fn_enable_bbr_fq() {
    echo "[任务] 自动开启BBR+FQ加速"
    fn_log "信息" "配置 BBR+FQ..."
    
    local config_file="/etc/sysctl.d/99-net.conf"
    
    # 检查配置文件是否存在
    if [ ! -f "$config_file" ]; then
        fn_log "警告" "配置文件 $config_file 不存在，创建基础配置"
        cat > "$config_file" <<EOF
# BBR+FQ 配置
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
EOF
        fn_log_action "CREATE_FILE" "$config_file"
    else
        # 确保 BBR+FQ 配置存在
        if ! grep -q "net.core.default_qdisc" "$config_file"; then
            echo "net.core.default_qdisc = fq" >> "$config_file"
        fi
        if ! grep -q "net.ipv4.tcp_congestion_control" "$config_file"; then
            echo "net.ipv4.tcp_congestion_control = bbr" >> "$config_file"
        fi
    fi
    
    # 应用配置
    sysctl -p "$config_file" > /dev/null 2>&1 || fn_log "警告" "sysctl应用BBR配置时出现警告"
    
    # 验证
    local current_qdisc=$(sysctl -n net.core.default_qdisc 2>/dev/null || echo "")
    local current_cc=$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo "")
    
    if [ "$current_qdisc" = "fq" ] && [ "$current_cc" = "bbr" ]; then
        echo "[完成] BBR+FQ 已成功启用"
        fn_log "成功" "BBR+FQ 已启用 (qdisc=$current_qdisc, cc=$current_cc)"
        return 0
    else
        echo "[警告] BBR+FQ 启用可能不完整 (qdisc=$current_qdisc, cc=$current_cc)"
        fn_log "警告" "BBR+FQ 状态异常"
        return 1
    fi
}

# 检测和处理 IPv6
fn_handle_ipv6() {
    echo "检测IPv6状态..."
    
    local ipv6_status=$(sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null || echo "1")
    
    if [ "$ipv6_status" = "0" ]; then
        echo "IPv6 已经开启"
        
        if [ $FORCE_YES -eq 1 ]; then
            DISABLE_IPV6="y"
            echo "非交互模式: 自动禁用 IPv6"
            fn_log "信息" "非交互模式: 自动禁用 IPv6"
        else
            echo "是否禁用 IPv6？（默认禁用）(Y/n)"
            local choice
            read -r choice || choice=""
            
            if [ -z "$choice" ] || [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
                DISABLE_IPV6="y"
                echo "将禁用 IPv6"
            else
                DISABLE_IPV6="n"
                echo "保持 IPv6 启用"
            fi
        fi
    else
        echo "IPv6 已经禁用，保持当前状态"
        DISABLE_IPV6="y"
    fi
    
    fn_log "信息" "IPv6 处理完成: disable_ipv6=${DISABLE_IPV6}"
    return 0
}

_fn_cleanup_fallback_swap() {
    local fallback_swap="/swapfile_zram"
    
    if [ ! -f "$fallback_swap" ]; then
        return 0
    fi

    if swapon -s | grep -q "$fallback_swap"; then
        fn_log "信息" "ZRAM 已激活，正在自动清理不再需要的回退 swapfile..."
        (swapoff "$fallback_swap") >> "$LOG_FILE" 2>&1 || true
        (rm -f "$fallback_swap") >> "$LOG_FILE" 2>&1 || true
        fn_log "成功" "已自动清理回退 swapfile: $fallback_swap"
    
    elif [ -f "$fallback_swap" ]; then
         fn_log "调试" "检测到未激活的回退 swapfile，正在清理..."
         (rm -f "$fallback_swap") >> "$LOG_FILE" 2>&1 || true
    fi
    return 0
}

fn_setup_zram_adaptive() {
    fn_log "信息" "启用 ZRAM (切换到 zram-tools 方案)..."

    if systemctl is-active zramswap.service >/dev/null 2>&1; then
        fn_log "信息" "ZRAM (zram-tools) 已激活，跳过。"
        _fn_cleanup_fallback_swap
        return 2
    fi
    
    if "${PKG_CMD_CHECK[@]}" systemd-zram-generator >/dev/null 2>&1; then
        fn_log "信息" "检测到冲突的 systemd-zram-generator，正在卸载..."
        fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
        "${PKG_CMD_REMOVE[@]}" systemd-zram-generator >>"$LOG_FILE" 2>&1 || true
        fn_log_action "UNINSTALL_PKG" "systemd-zram-generator"
    fi
    
    if "${PKG_CMD_CHECK[@]}" zram-tools >/dev/null 2>&1; then
        fn_log "信息" "ZRAM (zram-tools) 已安装。"
    else
        fn_log "信息" "正在安装 ZRAM (zram-tools)..."
        fn_wait_for_pkg_lock || { fn_log "错误" "包管理器锁等待失败"; return 1; }
        "${PKG_CMD_INSTALL[@]}" zram-tools >>"$LOG_FILE" 2>&1 || { 
            fn_log "警告" "zram-tools 安装失败"; 
            fn_setup_zram_fallback "zram-tools 安装失败"; 
            return 1; 
        }
        fn_log_action "INSTALL_PKG" "zram-tools"
        fn_log "信息" "ZRAM (zram-tools) 安装完成。"
    fi

    mem_mb="$MEM_MB"
    local zram_percent=100
    fn_log "信息" "ZRAM 目标大小: ${zram_percent}% 物理内存 (高风险设置)"

    local old_conf_file="/etc/systemd/zram-generator.conf"
    if [ -f "$old_conf_file" ]; then
        rm -f "$old_conf_file"
        fn_log "调试" "已移除旧的 zram-generator.conf"
    fi

    local conf_file="/etc/default/zramswap"
    cat > "$conf_file" <<EOF
# Configuration for zram-tools
ALGO=lz4
PERCENT=${zram_percent}
PRIORITY=100
EOF
    fn_log_action "CREATE_FILE" "$conf_file"
    fn_log "调试" "已写入 $conf_file"

    modprobe zram || true
    fn_log "调试" "已执行 modprobe zram"
    
    (systemctl restart zramswap.service) >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "已重启 zramswap.service (尝试 1)，等待 3 秒..."
    sleep 3

    if [ -b /dev/zram0 ] && swapon -s | grep -q 'zram'; then
        fn_log "成功" "ZRAM (zram-tools) 已激活 (尝试 1 成功)"
        (swapon -s) >> "$LOG_FILE" 2>&1
        systemctl enable zramswap.service >/dev/null 2>&1 || true
        _fn_cleanup_fallback_swap
        return 0
    fi

    fn_log "警告" "ZRAM 激活失败 (尝试 1)，将尝试清理内核缓存后重试..."
    (sync && echo 3 > /proc/sys/vm/drop_caches) 2>/dev/null || true
    fn_log "调试" "已清理内核缓存，等待 2 秒..."
    sleep 2

    (systemctl restart zramswap.service) >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "已重启 zramswap.service (尝试 2)，等待 3 秒..."
    sleep 3

    if [ -b /dev/zram0 ] && swapon -s | grep -q 'zram'; then
        fn_log "成功" "ZRAM (zram-tools) 已激活 (尝试 2 成功)"
        (swapon -s) >> "$LOG_FILE" 2>&1
        systemctl enable zramswap.service >/dev/null 2>&1 || true
        _fn_cleanup_fallback_swap
        return 0
    else
        fn_log "错误" "ZRAM (zram-tools) 激活失败 (尝试 2 仍失败)，使用 swapfile 回退"
        fn_log "警告" "100% 内存分配失败。这在低内存 VPS 上是常见情况 (os error 12)。"
        fn_setup_zram_fallback "ZRAM 激活失败"
        return 1
    fi
}

fn_setup_zram_fallback() {
    local reason="$1"
    fn_log "警告" "$reason, 使用 swapfile 回退"

    local swapfile="/swapfile_zram"
    local swapsize_mb=$(( MEM_MB < 512 ? MEM_MB : 512 ))
    
    if [ -f "$swapfile" ]; then
        fn_log "调试" "检测到旧的 swapfile，正在移除..."
        swapoff "$swapfile" 2>/dev/null || true
        rm -f "$swapfile" 2>/dev/null || true
    fi

    fn_log "调试" "创建 swapfile: $swapfile (大小: ${swapsize_mb}M)"
    (fallocate -l "${swapsize_mb}M" "$swapfile" || dd if=/dev/zero of="$swapfile" bs=1M count="$swapsize_mb") >> "$LOG_FILE" 2>&1
    fn_log_action "CREATE_FILE" "$swapfile"
    
    chmod 600 "$swapfile"
    (mkswap "$swapfile") >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "mkswap $swapfile"
    
    (swapon "$swapfile") >> "$LOG_FILE" 2>&1 || true
    fn_log "调试" "swapon $swapfile"
    
    if swapon -s | grep -q "$(basename "$swapfile")"; then
        fn_log "成功" "Swapfile 回退启用 (${swapsize_mb} MB)"
        (swapon -s) >> "$LOG_FILE" 2>&1
    else
        fn_log "错误" "Swapfile 回退启用失败。"
    fi
}

fn_prioritize_network_services_auto() {
local changes_made=0

local services_list_str
local IFS=','
services_list_str="${FN_NETWORK_SERVICES_LIST[*]}"
fn_log "信息" "正在搜索匹配的网络代理服务 (${services_list_str})..."

local found_names=()
for pattern in "${FN_NETWORK_SERVICES_LIST[@]}"; do
    while read -r service_file; do
        [ -z "$service_file" ] && continue
        
        local base_name="${service_file%.service}" 
        found_names+=("$base_name")
        
    done < <(systemctl list-unit-files --type=service --no-legend "${pattern}.service" 2>/dev/null | awk '{print $1}')
done

local detected_svcs=()
mapfile -t detected_svcs < <(printf "%s\n" "${found_names[@]}" | sort -u)


if [ ${#detected_svcs[@]} -eq 0 ]; then
fn_log "信息" "未检测到网络代理服务，无需优化。"
return 2
fi

local detected_svcs_str
IFS=','
detected_svcs_str="${detected_svcs[*]}"
fn_log "信息" "检测到: ${detected_svcs_str}。开始应用服务优化..."

for svc in "${detected_svcs[@]}"; do
    local conf_file="/etc/systemd/system/${svc}.service.d/90-vps_optimizert.conf"
    if [ -f "$conf_file" ]; then
        fn_log "调试" "配置文件 $conf_file 已存在，跳过 $svc。"
        continue
    fi
    
    fn_log "调试" "为 $svc 设置 RealTime 调度, Nice=-19, Limits."
    
    local svc_conf_dir="/etc/systemd/system/${svc}.service.d"
    mkdir -p "$svc_conf_dir"
    cat > "$conf_file" <<EOF
[Service]
# Extreme Performance Tuning
Nice=-19
CPUSchedulingPolicy=fifo
CPUSchedulingPriority=10
LimitNOFILE=1000000
LimitNPROC=1000000
EOF
    fn_log_action "CREATE_FILE" "$conf_file"
    changes_made=1
done

if [ "$changes_made" -eq 0 ]; then
     fn_log "信息" "网络代理服务均已配置，无需刷新。"
     return 2
fi

if [ "$changes_made" -eq 1 ]; then
    fn_log "调试" "重载 systemd daemon..."
    (systemctl daemon-reload) >> "$LOG_FILE" 2>&1
fi
fn_log "成功" "网络服务优化成功 (${detected_svcs_str})。"
return 0
}

fn_tune_network_interface() {
    fn_log "信息" "正在优化网络接口队列长度..."
    local default_iface
    default_iface=$(ip route | grep default | awk '{print $5}' | head -n1)
    
    if [ -z "$default_iface" ]; then
        fn_log "警告" "无法检测到默认网络接口，跳过接口优化。"
        return 2
    fi
    
    fn_log "信息" "检测到默认接口: $default_iface"
    
    if ip link set dev "$default_iface" txqueuelen 10000; then
        fn_log "成功" "已设置 $default_iface txqueuelen = 10000"
    else
        fn_log "警告" "设置 $default_iface txqueuelen 失败。"
    fi
    
    if command -v ethtool > /dev/null 2>&1; then
        ethtool -K "$default_iface" gso off gro off > /dev/null 2>&1 || true
        fn_log "信息" "尝试禁用 GSO/GRO (ethtool)。"
    fi
    
    return 0
}

fn_set_system_limits() {
    fn_log "信息" "设置系统级资源限制 (limits.conf)..."
    local limits_file="/etc/security/limits.conf"
    
    if grep -q "vps_optimizert" "$limits_file"; then
        fn_log "信息" "limits.conf 已包含优化配置，跳过。"
        return 2
    fi
    
    cp "$limits_file" "${limits_file}.bak" 2>/dev/null || true
    
    cat >> "$limits_file" <<'EOF'

# Added by vps_optimizert
* soft nofile 1000000
* hard nofile 1000000
* soft nproc 1000000
* hard nproc 1000000
root soft nofile 1000000
root hard nofile 1000000
root soft nproc 1000000
root hard nproc 1000000
EOF
    fn_log_action "MODIFY_FILE" "$limits_file"
    fn_log "成功" "已更新 /etc/security/limits.conf"
    return 0
}

fn_optimize_auto() {
    local result
    
    if fn_check_if_optimized; then
        echo "-----------------------------------------------------"
        echo "[错误] 检测到系统已被优化。"
        echo "操作日志: $ACTION_LOG (已包含内容)"
        echo ""
        echo "为防止覆盖现有配置和日志，操作已停止。"
        echo " * 如果您想重新优化，请先运行 [选项 2] 撤销优化。"
        echo "-----------------------------------------------------"
        fn_log "错误" "检测到已优化，fn_optimize_auto 已停止。"
        return 1
    fi

    echo "======================================================="
    echo "  VPS 激进优化脚本 v${SCRIPT_VERSION}"
    echo "  开始执行系统优化..."
    echo "======================================================="
    echo ""

    echo "创建备份文件..."
    result=0
    fn_backup_state || result=$?
    if [ $result -ne 0 ]; then
        echo "[失败] 备份文件创建失败，退出优化。"
        fn_log "错误" "fn_backup_state 失败，退出。"
        return 1
    fi
    echo "[完成] 备份文件创建成功: $BACKUP_DIR"
    echo ""
    
    echo "检查包管理器源..."
    result=0
    fn_fix_apt_sources_if_needed || result=$?
    if [ $result -ne 0 ]; then
        echo "[失败] 包管理器源检查失败。请检查日志。"
        fn_log "错误" "fn_fix_apt_sources_if_needed 失败。"
    else
        echo "[完成] 包管理器源检查通过。"
    fi
    echo ""

    echo "[任务 1]: 网络优化参数配置（交互式）..."
    result=0
    fn_setup_aggressive_network || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 网络优化配置已创建。"
    else
        echo "[警告] 网络优化配置创建失败。"
    fi
    echo ""

    echo "[任务 2]: IPv6 状态检测（交互式）..."
    result=0
    fn_handle_ipv6 || result=$?
    echo "[完成] IPv6 处理完成。"
    echo ""

    echo "[任务 3]: 检查 SELinux 状态..."
    result=0
    fn_handle_selinux || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] SELinux 检查完成 (已操作)。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] SELinux 状态良好或未检测到。"
    fi
    echo ""
    
    echo "[任务 4]: 配置 Journald (日志)..."
    result=0
    fn_setup_journald_volatile || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] Journald 已配置为内存模式。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 检测到已优化，跳过。"
    fi
    echo ""

    echo "[任务 5]: 应用网络配置到系统..."
    sysctl --system > /dev/null 2>&1 || fn_log "警告" "sysctl --system 出现警告"
    echo "[完成] 系统网络配置已应用。"
    fn_log "信息" "sysctl --system 已执行。"
    echo ""

    echo "[任务 6]: 优化网络接口..."
    result=0
    fn_tune_network_interface || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 网络接口队列已优化。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 无法检测接口或已优化。"
    fi
    echo ""

    echo "[任务 7]: 自动开启BBR+FQ..."
    result=0
    fn_enable_bbr_fq || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] BBR+FQ 加速已启用。"
    else
        echo "[警告] BBR+FQ 启用可能不完整。"
    fi
    echo ""

    echo "[任务 8]: 设置系统资源限制..."
    result=0
    fn_set_system_limits || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 系统资源限制 (limits.conf) 已更新。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 已存在配置，跳过。"
    fi
    echo ""

    echo "[任务 9]: 配置 ZRAM..."
    result=0
    fn_setup_zram_adaptive || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] ZRAM 配置成功。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 检测到已优化，跳过。"
    else
        echo "[警告] ZRAM 配置失败，已启用 swapfile 回退。"
    fi
    echo ""

    echo "[任务 10]: 配置 Fail2ban..."
    result=0
    fn_setup_fail2ban || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] Fail2ban 配置成功。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 检测到已优化，跳过。"
    else
        echo "[警告] Fail2ban 配置失败。请检查日志。"
    fi
    echo ""

    echo "[任务 11]: 优化网络代理服务..."
    result=0
    fn_prioritize_network_services_auto || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 网络代理服务优化完成。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 未检测到服务或服务均已配置。"
    fi
    echo ""
    
    echo "[任务 12]: 精简系统服务..."
    result=0
    fn_trim_services_auto || result=$?
    if [ $result -eq 0 ]; then
        echo "[完成] 系统服务精简完成。"
    elif [ $result -eq 2 ]; then
        echo "[跳过] 未检测到需要新屏蔽的服务。"
    fi
    echo ""
    
    echo "======================================================="
    echo "  系统优化完成！"
    echo "  请重启系统以完全生效所有优化。"
    echo "======================================================="
    fn_log "成功" "系统优化完成。请重启系统以完全生效。"
    fn_show_status_report "noclear"
}


fn_restore_all() {
    echo "[任务] 开始执行撤销优化..."
    fn_log "警告" "开始执行撤销优化... 将从 $ACTION_LOG 恢复。"

    local log_restored=false
    if [ -f "$ACTION_LOG" ] && [ $(grep -vc '^#' "$ACTION_LOG") -gt 0 ]; then
        echo "[成功] 检测到操作日志: $ACTION_LOG (共 $(grep -vc '^#' "$ACTION_LOG") 条操作)。将执行日志反向撤销..."
        fn_log "信息" "检测到有效操作日志，将执行反向撤销。"
        log_restored=true
    else
        echo "[失败] 未找到操作日志或日志为空: $ACTION_LOG。将仅使用备份文件和强制清理。"
        fn_log "错误" "未找到 $ACTION_LOG 或其为空，无法执行日志反向撤销。"
    fi

    echo "[任务]   正在停用 ZRAM 和 Swap..."
    (systemctl disable --now zramswap.service) >> "$LOG_FILE" 2>&1 || true
    swapoff -a >/dev/null 2>&1 || true
    modprobe -r zram >/dev/null 2>&1 || true
    
    if [ "$log_restored" = "true" ]; then
        tac "$ACTION_LOG" | while read -r line; do
            [ -z "$line" ] && continue
            [[ "$line" == \#* ]] && continue
            
            local action=$(echo "$line" | cut -d: -f1)
            local value=$(echo "$line" | cut -d: -f2-)

            case "$action" in
                MASK_SERVICE)
                    echo "[日志撤销] Unmasking $value"
                    fn_log "信息" "[日志撤销] Unmasking $value"
                    (systemctl unmask "$value") >> "$LOG_FILE" 2>&1 || true
                    ;;
                CREATE_FILE)
                    echo "[日志撤销] Removing file/dir $value"
                    fn_log "信息" "[日志撤销] Removing file/dir $value"
                    rm -rf "$value"
                    if [[ "$value" == *.service.d/*.conf ]]; then
                        rmdir "$(dirname "$value")" 2>/dev/null || true
                    fi
                    ;;
                INSTALL_PKG)
                    echo "[日志撤销] Purging package $value"
                    fn_log "信息" "[日志撤销] Purging package $value"
                    if [ ${#PKG_CMD_REMOVE[@]} -gt 0 ]; then
                        fn_wait_for_pkg_lock || fn_log "警告" "包管理器锁等待失败，跳过卸载 $value"
                        ("${PKG_CMD_REMOVE[@]}" "$value") >> "$LOG_FILE" 2>&1
                    fi
                    ;;
                UNINSTALL_PKG) 
                    echo "[日志撤销] Re-installing package $value"
                    fn_log "信息" "[日志撤销] Re-installing package $value"
                    if [ ${#PKG_CMD_INSTALL[@]} -gt 0 ]; then
                        fn_wait_for_pkg_lock || fn_log "警告" "包管理器锁等待失败，跳过安装 $value"
                        ("${PKG_CMD_INSTALL[@]}" "$value") >> "$LOG_FILE" 2>&1
                    fi
                    ;;
                MODIFY_FILE)
                    if [ -f "${value}.bak" ]; then
                        echo "[日志撤销] Restoring $value from ${value}.bak"
                        fn_log "信息" "[日志撤销] Restoring $value from ${value}.bak"
                        mv "${value}.bak" "$value" >> "$LOG_FILE" 2>&1
                    else
                        echo "[日志跳过] 未找到 ${value}.bak，无法恢复 $value"
                        fn_log "警告" "未找到 ${value}.bak，无法恢复 $value"
                    fi
                    ;;
                *)
                    fn_log "警告" "未知的撤销操作: $action"
                    ;;
            esac
        done
        
    fi

    echo "[任务]   正在恢复核心备份文件..."
    
    echo "[任务]     恢复 sysctl..."
    [ -f "${BACKUP_DIR}/sysctl.conf.bak" ] && cp -an "${BACKUP_DIR}/sysctl.conf.bak" /etc/sysctl.conf 2>/dev/null && fn_log "信息" "恢复 /etc/sysctl.conf" || true
    [ -d "${BACKUP_DIR}/sysctl.d.bak" ] && cp -ar "${BACKUP_DIR}/sysctl.d.bak" /etc/sysctl.d/ 2>/dev/null && fn_log "信息" "恢复 /etc/sysctl.d/" || true
    
    cat > /etc/sysctl.d/98-bbr-retention.conf <<'EOF'
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
EOF
    sysctl --system >/dev/null 2>/dev/null || true

    echo "[任务]     恢复 journald..."
    [ -d "${BACKUP_DIR}/journald.conf.d.bak" ] && rm -rf /etc/systemd/journald.conf.d/ && cp -ar "${BACKUP_DIR}/journald.conf.d.bak" /etc/systemd/journald.conf.d/ 2>/dev/null && fn_log "信息" "恢复 journald.conf.d" || true
    systemctl restart systemd-journald >/dev/null 2>/dev/null || true
    
    echo "[任务]     恢复 fstab..."
    [ -f "${BACKUP_DIR}/fstab.bak" ] && cp -an "${BACKUP_DIR}/fstab.bak" /etc/fstab 2>/dev/null && fn_log "信息" "恢复 /etc/fstab" || true
    
    echo "[任务]   正在执行强制配置清理 (确保无残留 vps_optimizert 配置)..."
    
    local files_to_clean=(
        "/etc/sysctl.d/99-vps_optimizert.conf"
        "/etc/apt/apt.conf.d/99-force-ipv4"
        "/etc/systemd/journald.conf.d/10-volatile.conf"
        "/etc/fail2ban/jail.d/99-vps_optimizert-systemd.conf"
        "/etc/default/zramswap"
        "/swapfile_zram"
    )
    
    for f in "${files_to_clean[@]}"; do
        if [ -f "$f" ]; then
            echo "[清理] 移除文件 $f"
            rm -f "$f"
            fn_log "信息" "[清理] 移除 $f"
        fi
    done

    echo "[任务]   正在清理网络服务 drop-in 配置..."
    find /etc/systemd/system/ -type d -name "*.service.d" 2>/dev/null | while read -r dropin_dir; do
        if [ -f "${dropin_dir}/90-vps_optimizert.conf" ]; then
            echo "[清理] 移除配置目录 $dropin_dir"
            rm -rf "$dropin_dir"
            fn_log "信息" "[清理] 移除网络服务配置目录 $dropin_dir"
        fi
    done
    
    echo "[任务]   正在恢复之前启用的服务 (来自 enabled_services.before.txt)..."
    if [ -f "${BACKUP_DIR}/enabled_services.before.txt" ]; then
        while read -r s; do 
            [ -z "$s" ] && continue
            (systemctl enable "$s") >> "$LOG_FILE" 2>&1 || true; 
        done < "${BACKUP_DIR}/enabled_services.before.txt"
    else
        echo "[跳过] 未找到 enabled_services.before.txt，跳过服务启用恢复。"
        fn_log "警告" "未找到 enabled_services.before.txt，跳过服务启用恢复。"
    fi

    (systemctl daemon-reload) >> "$LOG_FILE" 2>&1
    rm -f "$ACTION_LOG"
    
    echo "[完成] 撤销优化完成。"
    fn_log "成功" "撤销优化完成。"
}

fn_show_status_report() {
    if [ "${1:-}" != "noclear" ]; then
        clear
    fi
    
    echo "==================== 系统优化状态 ====================" 
    [ -f /etc/os-release ] && source /etc/os-release
    printf "系统: %s\n" "${PRETTY_NAME:-unknown}"
    printf "内存: %s MB\n" "$MEM_MB"
    printf "内核: %s\n" "$(uname -r)"
    echo "------------------------------------------------------"

    fn_print_line() {
        local name="$1"
        local status="$2"
        local success_msg="$3"
        local fail_msg="$4"
        local details="${5:-}"
        local status_msg="$fail_msg"
        [ "$status" == "true" ] && status_msg="$success_msg"
        local details_str=""
        [ -n "$details" ] && details_str="$details"
        printf "  %-30s %-15s %s\n" "$name" "$status_msg" "$details_str"
    }

    local sysctl_conf_file="/etc/sysctl.d/99-net.conf"
    local sysctl_status="false"
    local bbr_status="false"
    [ -f "$sysctl_conf_file" ] && sysctl_status="true"
    
    if [ "$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null)" == "bbr" ] && \
       [ "$(sysctl -n net.core.default_qdisc 2>/dev/null)" == "fq" ]; then
        bbr_status="true"
    fi
    
    fn_print_line "BBR+FQ 加速" "$bbr_status" "[ 已启用 ]" "[ 未启用 ]" ""
    fn_print_line "网络优化配置" "$sysctl_status" "[ 已配置 ]" "[ 未配置 ]" ""
    
    local ipv6_status="false"
    local ipv6_details=""
    if [ "$(sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null)" == "1" ]; then
        ipv6_status="true"
        ipv6_details="(已禁用)"
    else
        ipv6_status="false"
        ipv6_details="(已启用)"
    fi
    fn_print_line "IPv6 禁用" "$ipv6_status" "[ 已禁用 ]" "[ 已启用 ]" "$ipv6_details"

    local selinux_status="false"
    local selinux_details="(未检测到)"
    if command -v getenforce > /dev/null 2>&1; then
        local selinux_state
        selinux_state=$(getenforce)
        if [ "$selinux_state" == "Disabled" ]; then
            selinux_status="true"
            selinux_details="(已禁用)"
        else
            selinux_status="false"
            selinux_details="(状态: $selinux_state)"
        fi
    fi
    fn_print_line "SELinux" "$selinux_status" "[ 已优化 ]" "[ 未优化 ]" "$selinux_details"

    local f2b_status="false"
    local f2b_details="(未安装)"
    if systemctl is-active fail2ban > /dev/null 2>&1; then
        f2b_status="true"
        f2b_details="(已激活)"
    elif "${PKG_CMD_CHECK[@]}" fail2ban > /dev/null 2>&1; then
        f2b_status="false"
        f2b_details="(已安装/未运行)"
    fi
    fn_print_line "Fail2ban" "$f2b_status" "[ 已激活 ]" "[ 未激活 ]" "$f2b_details"

    local journal_storage
    journal_storage=$(systemd-analyze cat-config systemd/journald.conf | grep -i '^Storage=' | tail -n 1 | cut -d= -f2 2>/dev/null || echo "disk")
    local journal_status="false"
    local journal_details="(模式: ${journal_storage:-disk})"
    if [ "$journal_storage" == "volatile" ]; then
        journal_status="true"
        journal_details="(模式: 仅内存)"
    fi
    fn_print_line "Journald 日志" "$journal_status" "[ 已优化 ]" "[ 未优化 ]" "$journal_details"

    local zram_status="false"
    local zram_details="(未激活)"
    if systemctl is-active zramswap.service > /dev/null 2>&1 && swapon -s | grep -q 'zram'; then
        zram_status="true"
        zram_details="(已激活 ZRAM)"
    elif swapon -s | grep -q 'swapfile_zram'; then
        zram_status="true"
        zram_details="(已激活 Swapfile)"
    fi
    fn_print_line "ZRAM/Swap" "$zram_status" "[ 已优化 ]" "[ 未激活 ]" "$zram_details"

    echo "======================================================"
}

fn_show_menu() {
    clear
    
    echo "==============================================="
    echo " VPS 激进优化脚本 (ax-optz)"
    echo " 版本: $SCRIPT_VERSION"
    echo " 备份目录: $BACKUP_DIR"
    echo " 日志文件: $LOG_FILE"
    echo "==============================================="
    echo " 1) 执行系统优化 (激进方案+交互配置)"
    echo " 2) 撤销优化 (保留BBR)"
    echo " 3) 优化网络代理服务"
    echo " 4) 显示系统优化状态"
    echo " 0) 退出"
    echo "===============================================
"
    read -rp "请选择: " CH || true
    case "$CH" in
        1) 
            fn_optimize_auto || true 
            read -rp "按回车返回主菜单..." dummy || true
            ;;
        2) 
            fn_restore_all || true 
            read -rp "撤销完成。按回车返回主菜单..." dummy || true
            ;;
        3)
            echo "[任务] 正在优化网络代理服务..."
            result=0
            fn_prioritize_network_services_auto || result=$?
            if [ $result -eq 0 ]; then
                echo "[完成] 优化完成。"
            elif [ $result -eq 2 ]; then
                echo "[跳过] 未检测到服务或服务均已配置。"
            fi
            read -rp "按回车返回菜单..." dummy || true
            ;;
        4)
            fn_show_status_report
            read -rp "按回车返回菜单..." dummy || true 
            ;;
        0) 
            echo "退出。"
            fn_log "信息" "退出。"; exit 0 
            ;;
        *) 
            echo "错误: 无效选项。"
            fn_log "错误" "无效选项。"; sleep 1;
            ;;
    esac
    fn_show_menu
}

fn_check_root
fn_detect_os

fn_show_menu
