#!/bin/bash
# Xray（Vless、SS）、Hysteria2, UDP2RAW 、 KCPTUN 实例管理脚本
# Generated by github.com/halibotee

# =============================================================================
# 1. 核心全局变量与脚本版本
# =============================================================================
# 脚本版本号，用于显示和版本检查
SCRIPT_VERSION="1.1.31"

# 组件安装目录定义
KCP_INSTALL_DIR="/etc/kcptun"       # KCPTUN 安装目录
UDP2RAW_INSTALL_DIR="/etc/udp2raw"  # UDP2RAW 安装目录
HY2_INSTALL_DIR="/etc/hysteria2"    # Hysteria2 安装目录
XRAY_INSTALL_DIR="/etc/xray"        # Xray 安装目录
ACME_SH_INSTALL_DIR="/root/.acme.sh/acme.sh" # acme.sh 脚本路径
AX_CERT_DIR="/etc/ax-certs"         # 证书统一存放目录

# =============================================================================
# 2. Systemd 服务模板文件路径
# =============================================================================
KCPTUN_TEMPLATE_FILE="/etc/systemd/system/ax-kcptun@.service"   # KCPTUN 服务模板
UDP2RAW_TEMPLATE_FILE="/etc/systemd/system/ax-udp2raw@.service" # UDP2RAW 服务模板
HY2_TEMPLATE_FILE="/etc/systemd/system/ax-hysteria2@.service"   # Hysteria2 服务模板
XRAY_TEMPLATE_FILE="/etc/systemd/system/ax-xray@.service"       # Xray 服务模板

# =============================================================================
# 3. 网络与服务默认配置
# =============================================================================
PUBLIC_IP=""                     # 存储获取到的公网 IP，留空则在运行时自动获取
DEFAULT_LISTEN_ADDR="0.0.0.0"    # 默认的全局监听地址 (0.0.0.0 表示监听所有接口)
DEFAULT_TARGET_ADDR="127.0.0.1"  # KCP/UDP 默认的目标(回环)地址
RANDOM_PORT_MIN=10000            # 随机端口生成的最小值
RANDOM_PORT_MAX=65535            # 随机端口生成的最大值
PUBLIC_IP_SERVICE_1="ip.sb"      # 获取公网 IP 的首选服务 API
PUBLIC_IP_SERVICE_2="ipinfo.io/ip" # 获取公网 IP 的备选服务 API

# =============================================================================
# 4. Hysteria2 (HY2) 专属配置
# =============================================================================
HY2_SNI="bing.com"                                # Hysteria2 自签名模式默认使用的 SNI 域名
HY2_CERT_PATH="/etc/ssl/private/${HY2_SNI}.crt"   # 默认自签名证书路径
HY2_KEY_PATH="/etc/ssl/private/${HY2_SNI}.key"    # 默认自签名密钥路径
HY2_MASQUERADE_URL="https://www.bing.com"         # 默认伪装流量的目标 URL
HY2_CLIENT_INSECURE="1"                           # Hysteria2 客户端是否跳过证书验证 (1: 跳过, 0: 验证)

# =============================================================================
# 5. Xray VLESS 专属配置
# =============================================================================
XRAY_REALITY_DEFAULT_SNI="www.apple.com"          # VLESS+Reality 模式默认 SNI
XRAY_REALITY_DEFAULT_FP="chrome"                  # VLESS+Reality 模式默认指纹 (fingerprint)
XRAY_REALITY_DEFAULT_TARGET="www.apple.com:443"   # VLESS+Reality 模式默认回落目标
XRAY_REALITY_DEFAULT_FLOW="xtls-rprx-vision"      # VLESS+Reality 模式默认流控 (flow)
KCPTUN_DEFAULT_MODE="fast3"                       # KCPTUN 默认的加速模式
SS_DEFAULT_METHOD="2022-blake3-aes-256-gcm"       # Shadowsocks 默认加密方式

# =============================================================================
# 6. WARP 分流配置
# =============================================================================
DEFAULT_WARP_SOCKS_ADDR="127.0.0.1" # WARP SOCKS5 服务的默认监听地址
DEFAULT_WARP_SOCKS_PORT="40000"     # WARP SOCKS5 服务的默认端口
# WARP 分流规则 (JSON 格式)
WARP_GEOSITE_LIST_JSON='"geosite:google","geosite:openai","geosite:perplexity"'
WARP_GEOIP_LIST_JSON='"geoip:google"'
# WARP 分流规则 (YAML 格式，用于 Hysteria2)
WARP_GEOSITE_LIST_YAML='- warp(suffix:ip-api.com)
    - warp(geosite:google)
    - warp(geoip:google)
    - warp(suffix:google.com)
    - warp(geosite:openai)
    - warp(suffix:openai.com)
    - warp(suffix:chatgpt.com)
    - warp(geosite:perplexity)
    - warp(suffix:perplexity.com)'

# =============================================================================
# 7. Github 软件源配置
# =============================================================================
KCPTUN_REPO="xtaci/kcptun"       # KCPTUN 官方仓库
UDP2RAW_REPO="wangyu-/udp2raw"   # UDP2RAW 官方仓库
HY2_REPO="apernet/hysteria"      # Hysteria2 官方仓库
XRAY_REPO="XTLS/Xray-core"       # Xray-core 官方仓库
GITHUB_API_URL="https://api.github.com/repos" # GitHub API 地址
GITHUB_URL="https://github.com"               # GitHub 主页地址

# =============================================================================
# 8. 客户端默认参数配置
# =============================================================================
CLIENT_KCPTUN_LISTEN_ADDR="127.0.0.1:1091"       # KCPTUN 客户端默认本地监听地址
CLIENT_UDP2RAW_LISTEN_ADDR="127.0.0.1:1093"      # UDP2RAW 客户端默认本地监听地址
CLIENT_VLESS_UDP2RAW_LISTEN_ADDR="127.0.0.1:1094" # VLESS+UDP2RAW 客户端默认本地监听地址
# [NEW] 3-Chain SS+KCP+UDP 客户端本地端口
CLIENT_SS_3_CHAIN_KCP_TARGET="127.0.0.1:1095"    # SS+KCP+UDP 模式下，KCP 目标地址 (即 UDP2RAW 监听地址)
CLIENT_SS_3_CHAIN_SS_TARGET="127.0.0.1:1096"     # SS+KCP+UDP 模式下，SS 目标地址 (即 KCP 监听地址)

# UDP2RAW 通用参数
UDP2RAW_COMMON_ARGS="--raw-mode faketcp --cipher-mode aes128cbc --auth-mode hmac_sha1 --seq-mode 4 -a --keep-rule --fix-gro"
# UDP2RAW 客户端基础参数
UDP2RAW_CLIENT_BASE_ARGS="-c ${UDP2RAW_COMMON_ARGS}"

# =============================================================================
# 9. 配置文件模板 (JSON / YAML / CONF)
# =============================================================================

# -----------------------------------------------------------------------------
# KCPTUN 服务端配置文件模板 (JSON)
# -----------------------------------------------------------------------------
read -r -d '' KCPTUN_CONFIG_JSON_TEMPLATE <<'EOM'
{
    "listen": "__LISTEN__", "target": "__TARGET__", "key": "__KEY__", "crypt": "__CRYPT__", "mode": "__MODE__", "smuxver": 2, "mtu": 1350, "sndwnd": 256, "rcvwnd": 2048, "datashard": 10, "parityshard": 3, "dscp": 46, "nocomp": __NOCOMP__, "acknodelay": false, "nodelay": 1, "interval": 20, "resend": 2, "nc": 1, "sockbuf": 16777217, "smuxbuf": 16777217, "streambuf": 4194304, "keepalive": 5, "autoexpire": 600, "quiet": false, "tcp": __TCP__
}
EOM

# -----------------------------------------------------------------------------
# UDP2RAW 服务端配置文件模板 (CONF)
# -----------------------------------------------------------------------------
read -r -d '' UDP2RAW_CONFIG_TEMPLATE <<'EOM'
-s
-l __LISTEN_ADDR__
-r __TARGET_ADDR__
-k __PASSWORD__
--raw-mode __RAW_MODE__
--cipher-mode __CIPHER_MODE__
--auth-mode __AUTH_MODE__
--seq-mode 4
-a
--keep-rule
--fix-gro
EOM

# -----------------------------------------------------------------------------
# Hysteria2 服务端配置文件模板 (YAML)
# -----------------------------------------------------------------------------
read -r -d '' HYSTERIA2_CONFIG_YAML_TEMPLATE <<'EOM'
listen: __LISTEN__
tls:
  cert: __CERT_PATH__
  key: __KEY_PATH__
auth:
  type: password
  password: __PASSWORD__
masquerade:
  type: proxy
  proxy:
    url: https://www.macbed.com
    rewriteHost: true
    insecure: false
ignoreClientBandwidth: __IGNORE_CLIENT_BANDWIDTH__
sniff:
  enable: true
  timeout: 2s
  rewriteDomain: true
  tcpPorts: 80,443,8000-9000
  __UDP_SNIFF_CONFIG__
__OUTBOUNDS_AND_ACL__
EOM

# -----------------------------------------------------------------------------
# Hysteria2 WARP 分流配置块 (YAML)
# -----------------------------------------------------------------------------
read -r -d '' HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK <<'EOM'
outbounds:
  - name: warp
    type: socks5
    socks5:
      addr: __WARP_SOCKS5_ADDR__
      udp: false
acl:
  inline:
    __WARP_GEOSITE_LIST_YAML__
    - direct(all)
EOM
HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_GEOSITE_LIST_YAML__/$WARP_GEOSITE_LIST_YAML}"

# -----------------------------------------------------------------------------
# Hysteria2 直连配置块 (YAML)
# -----------------------------------------------------------------------------
read -r -d '' HYSTERIA2_DIRECT_ACL_BLOCK <<'EOM'
acl:
  inline:
    - direct(all)
EOM

# -----------------------------------------------------------------------------
# Xray VLESS+Reality 服务端配置文件模板 (JSON)
# -----------------------------------------------------------------------------
read -r -d '' XRAY_VLESS_REALITY_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [
        {
            "listen": null,
            "port": __LISTEN_PORT__,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "__UUID__",
                        "flow": "__REALITY_FLOW__"
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "fingerprint": "__FINGERPRINT__",
                    "target": "__TARGET__",
                    "xver": 0,
                    "serverNames": [
                        "__SNI__"
                    ],
                    "privateKey": "__PRIVATE_KEY__",
                    "publicKey": "__PUBLIC_KEY__",
                    "minClientVer": "",
                    "maxClientVer": "",
                    "maxTimeDiff": 60000,
                    "shortIds": [
                        "__SHORT_ID__"
                    ]
                },
                "tcpSettings": {
                    "header": {
                        "type": "none"
                    }
                }
            },
            "tag": "inbound-__LISTEN_PORT__",
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls",
                    "quic"
                ]
            }
        }
    ],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# -----------------------------------------------------------------------------
# Xray VLESS+mKCP 服务端配置文件模板 (JSON)
# -----------------------------------------------------------------------------
read -r -d '' XRAY_VLESS_MKCP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "vless",
        "settings": {
            "clients": [{ "id": "__UUID__" }],
            "decryption": "none"
        },
        "streamSettings": {
            "network": "kcp",
            "kcpSettings": {
                "mtu": 1200, "tti": 30, "uplinkCapacity": 25, "downlinkCapacity": 100, "congestion": true, "readBufferSize": 4, "writeBufferSize": 4,
                "header": { "type": "wechat-video" },
                "seed": "__MKCP_SEED__"
            }
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# -----------------------------------------------------------------------------
# Xray Shadowsocks (TCP/UDP) 服务端配置文件模板 (JSON)
# 用于 KCPTUN / UDP2RAW 串联模式
# -----------------------------------------------------------------------------
read -r -d '' XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "shadowsocks",
        "settings": {
            "method": "__SS_METHOD__",
            "password": "__SS_PASSWORD__",
            "network": "tcp,udp"
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# -----------------------------------------------------------------------------
# Xray WARP 分流配置块 (JSON)
# -----------------------------------------------------------------------------
read -r -d '' XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "socks", "tag": "warp", "settings": { "servers": [{ "address": "__WARP_SOCKS5_ADDR__", "port": __WARP_SOCKS5_PORT__ }] } },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
        { "type": "field", "outboundTag": "warp", "domain": [ __WARP_GEOSITE_LIST_JSON__ ] },
        { "type": "field", "outboundTag": "warp", "ip": [ __WARP_GEOIP_LIST_JSON__ ] },
        { "type": "field", "outboundTag": "warp", "domain": [ "suffix:ip-api.com" ] },
        { "type": "field", "outboundTag": "block", "domain": [ "geosite:category-ads-all" ] }
    ]
}
EOM
XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK="${XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK//__WARP_GEOSITE_LIST_JSON__/$WARP_GEOSITE_LIST_JSON}"
XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK="${XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK//__WARP_GEOIP_LIST_JSON__/$WARP_GEOIP_LIST_JSON}"

# -----------------------------------------------------------------------------
# Xray 直连配置块 (JSON)
# -----------------------------------------------------------------------------
read -r -d '' XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": { "rules": [ { "type": "field", "outboundTag": "direct", "network": "tcp,udp" } ] }
EOM


# =============================================================================
# 10. 辅助工具函数 (颜色、日志、检查等)
# =============================================================================

# -----------------------------------------------------------------------------
# 终端颜色输出函数
# -----------------------------------------------------------------------------
green(){ echo -e "\033[0;32m$1\033[0m"; }  # 输出绿色文本
red(){ echo -e "\033[0;31m$1\033[0m"; }    # 输出红色文本 (用于错误)
yellow(){ echo -e "\033[0;33m$1\033[0m"; } # 输出黄色文本 (用于警告/提示)
cyan(){ echo -e "\033[0;36m$1\033[0m"; }   # 输出青色文本 (用于信息)
bold(){ echo -e "\033[1m$1\033[0m"; }      # 输出粗体文本
dim(){ echo -e "\033[2m$1\033[0m"; }       # 输出淡化(灰色)文本

# -----------------------------------------------------------------------------
# 日志记录函数
# -----------------------------------------------------------------------------
log(){ echo -e "[$(date '+%H:%M:%S')] $(bold "$1")"; }

# -----------------------------------------------------------------------------
# 检查是否已安装任何实例
# -----------------------------------------------------------------------------
is_installed(){ ls "$KCP_INSTALL_DIR"/*.json >/dev/null 2>&1 || ls "$UDP2RAW_INSTALL_DIR"/*.conf >/dev/null 2>&1 || ls "$HY2_INSTALL_DIR"/*.yaml >/dev/null 2>&1 || ls "$XRAY_INSTALL_DIR"/*.json >/dev/null 2>&1; }

# -----------------------------------------------------------------------------
# 获取本机公网 IP 地址
# -----------------------------------------------------------------------------
get_public_ip() {
    if [[ -n "$PUBLIC_IP" ]]; then echo "$PUBLIC_IP"; return; fi
    # 尝试从首选和备选服务获取 IP
    PUBLIC_IP=$(curl -s4m2 $PUBLIC_IP_SERVICE_1 || curl -s4m2 $PUBLIC_IP_SERVICE_2)
    # 如果获取失败，回退到 127.0.0.1 并警告
    if [[ -z "$PUBLIC_IP" ]]; then PUBLIC_IP="127.0.0.1"; yellow "获取公网 IP 失败，将使用 127.0.0.1 作为备用。" >&2; fi
    echo "$PUBLIC_IP"
}

# -----------------------------------------------------------------------------
# 统一检测与安装系统依赖和核心程序
# -----------------------------------------------------------------------------
install_dependencies_and_programs(){
    echo ""
    log "正在检测 系统依赖组件与核心程序..."
    echo ""
    
    # ========== 第一阶段：检测系统依赖组件 ==========
    local packages_to_install=()
    local missing_deps=()
    
    # 定义需要检查的依赖列表
    declare -A dep_map=(
        ["curl"]="curl"
        ["wget"]="wget"
        ["tar"]="tar"
        ["unzip"]="unzip"
        ["jq"]="jq"
        ["openssl"]="openssl"
        ["uuidgen"]="uuid-runtime"
        ["nano"]="nano"
        ["iptables"]="iptables"
        ["socat"]="socat"
    )
    
    # 检查 dig 命令 (DNS 工具)
    if ! command -v dig &>/dev/null; then
        if command -v apt-get &>/dev/null; then
            dep_map["dig"]="dnsutils"
        elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then
            dep_map["dig"]="bind-utils"
        fi
    fi
    
    # 检测缺失的依赖
    for cmd in "${!dep_map[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            packages_to_install+=("${dep_map[$cmd]}")
            missing_deps+=("$cmd")
        fi
    done
    
    # ========== 第二阶段：安装系统依赖组件 ==========
    if [ ${#packages_to_install[@]} -gt 0 ]; then
        echo ""
        yellow "开始下载安装 系统依赖组件..."
        echo ""
        
        # 逐个显示要安装的包
        for pkg in "${packages_to_install[@]}"; do
            cyan "  » 安装 $pkg"
        done
        echo ""
        
        # 执行实际安装
        if (apt-get update && apt-get install -y "${packages_to_install[@]}") >/dev/null 2>&1 || \
           (yum install -y epel-release && yum install -y "${packages_to_install[@]}") >/dev/null 2>&1 || \
           (dnf install -y "${packages_to_install[@]}") >/dev/null 2>&1; then
            green "✓ 系统依赖组件安装完成！"
        else
            red "✗ 部分系统依赖组件安装失败"
            yellow "请手动执行: apt install ${packages_to_install[*]}"
            return 1
        fi
    else
        green "✓ 所有系统依赖组件已就绪"
    fi
    
    # ========== 第三阶段：检测与下载核心程序 ==========
    echo ""
    yellow "开始下载安装 核心程序..." 
    echo ""
    
    # 检查各核心程序文件是否存在
    local need_download=false
    local kcp_ok=true; if [[ ! -f "$KCP_INSTALL_DIR/kcptun_server" ]]; then kcp_ok=false; need_download=true; fi
    local udp_ok=true; if [[ ! -f "$UDP2RAW_INSTALL_DIR/udp2raw" ]]; then udp_ok=false; need_download=true; fi
    local hy2_ok=true; if [[ ! -f "$HY2_INSTALL_DIR/hysteria" ]]; then hy2_ok=false; need_download=true; fi
    local xray_ok=true; if [[ ! -f "$XRAY_INSTALL_DIR/xray" ]]; then xray_ok=false; need_download=true; fi
    
    if [[ "$need_download" == false ]]; then
        green "✓ 所有核心程序已就绪"
        echo ""
        return 0
    fi
    
    # 下载缺失的核心程序
    if [[ "$kcp_ok" == false || "$udp_ok" == false ]]; then
        cyan "  » 下载 KCPTUN/UDP2RAW"
        download_kcp_udp_binaries || { red "✗ KCPTUN/UDP2RAW 下载失败"; return 1; }
        green "    ✓ KCPTUN/UDP2RAW 安装完成"
    fi
    
    if [[ "$hy2_ok" == false ]]; then
        cyan "  » 下载 Hysteria2"
        download_hysteria2_binary || { red "✗ Hysteria2 下载失败"; return 1; }
        green "    ✓ Hysteria2 安装完成"
    fi
    
    if [[ "$xray_ok" == false ]]; then
        cyan "  » 下载 Xray-core"
        download_xray_binary || { red "✗ Xray-core 下载失败"; return 1; }
        green "    ✓ Xray-core 安装完成"
    fi
    
    echo ""
    green "✓ 所有组件安装完成！"
    echo ""
}

# -----------------------------------------------------------------------------
# 带重试机制的文件下载函数
# 参数: $1=URL, $2=输出路径
# -----------------------------------------------------------------------------
download_with_retry(){
    local url=$1 output=$2 retries=3 timeout=15
    for ((i=1; i<=retries; i++)); do
        log "下载 ($i/$retries)：$url"
        curl -L --connect-timeout 5 --max-time $timeout -o "$output" "$url" && return 0
        yellow "下载失败，正在重试..."
    done
    red "下载失败超过 $retries 次，请检查网络。"
    return 1
}

# -----------------------------------------------------------------------------
# 查找一个未被占用的随机端口 (范围: RANDOM_PORT_MIN - RANDOM_PORT_MAX)
# -----------------------------------------------------------------------------
find_available_port() {
    local port
    while true; do
        port=$(( RANDOM % (RANDOM_PORT_MAX - RANDOM_PORT_MIN + 1) + RANDOM_PORT_MIN ))
        # 检查端口是否被占用 (ss -tuln)
        ! ss -tuln | grep -q ":${port} " && echo "$port" && return
    done
}

# -----------------------------------------------------------------------------
# 生成强密码 (优先使用 uuidgen，失败则使用 hexdump)
# -----------------------------------------------------------------------------
generate_strong_password() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    else
        log "uuidgen 未找到，生成备用 UUID..." >&2
        hexdump -n 16 -v -e '4/4 "%08x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 6/6 "%012x"' /dev/urandom | head -c 36
    fi
}

# -----------------------------------------------------------------------------
# 生成 Hysteria2 自签名证书 (如果不存在)
# -----------------------------------------------------------------------------
generate_self_signed_cert() {
    if [[ -s "$HY2_CERT_PATH" && -s "$HY2_KEY_PATH" ]]; then return; fi
    log "正在为 ${HY2_SNI} 生成自签名证书..."
    mkdir -p "$(dirname "$HY2_KEY_PATH")"
    # 生成私钥
    openssl ecparam -name prime256v1 -genkey -noout -out "$HY2_KEY_PATH"
    chmod 600 "$HY2_KEY_PATH"
    if [[ $? -ne 0 ]]; then red "错误: openssl ecparam 命令执行失败。"; exit 1; fi
    # 生成证书
    openssl req -new -x509 -days 36500 -key "$HY2_KEY_PATH" -out "$HY2_CERT_PATH" -subj "/CN=${HY2_SNI}" -nodes
    if [[ $? -ne 0 ]]; then red "错误: openssl req 命令执行失败。"; exit 1; fi
    if [[ ! -s "$HY2_CERT_PATH" || ! -s "$HY2_KEY_PATH" ]]; then red "错误: 证书文件生成失败或为空！"; exit 1; fi
    green "证书生成完毕。"
}

# -----------------------------------------------------------------------------
# 处理密码输入逻辑
# 支持自动生成、手动输入和保存上次使用的密码
# -----------------------------------------------------------------------------
handle_password_input() {
    local service_type=$1; local pass_file; local last_pass=""
    # 根据服务类型确定密码保存文件路径
    case "$service_type" in
        kcptun) mkdir -p "$KCP_INSTALL_DIR"; pass_file="$KCP_INSTALL_DIR/last_${service_type}_pass.txt" ;;
        udp2raw) mkdir -p "$UDP2RAW_INSTALL_DIR"; pass_file="$UDP2RAW_INSTALL_DIR/last_${service_type}_pass.txt" ;;
        hysteria2) mkdir -p "$HY2_INSTALL_DIR"; pass_file="$HY2_INSTALL_DIR/last_hy2_pass.txt" ;;
        xray_mkcp) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_xray_mkcp_seed.txt" ;;
        shadowsocks) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_ss_pass.txt" ;;
    esac
    
    # 读取上次保存的密码 (如果存在)
    if [[ -f "$pass_file" ]]; then last_pass=$(cat "$pass_file"); fi
    local display_pass=${last_pass:-"无"}
    local prompt_text="请输入密码"

    # 为 SS-2022 提供特定提示
    if [[ "$service_type" == "shadowsocks" ]]; then
         yellow "注意: SS-2022 (如 $SS_DEFAULT_METHOD) 必须使用 Base64 密钥。" >&2
         prompt_text="请输入 Base64 密钥"
    elif [[ "$service_type" == "xray_mkcp" ]]; then
         prompt_text="请输入 mKCP Seed"
    fi

    read -p "${prompt_text} (原有: ${display_pass}, 回车自动生成): " password

    if [[ -z "$password" ]]; then
        # 用户未输入，使用自动生成逻辑
        if [[ "$service_type" == "shadowsocks" ]]; then
            # SS-2022 需要特定长度的 Base64 密钥
            local key_length=32 # 默认 32 字节 (用于 256-gcm)
            if [[ "$SS_DEFAULT_METHOD" == *"128-gcm"* ]]; then
                key_length=16 # 16 字节 (用于 128-gcm)
            fi
            
            if ! command -v openssl &>/dev/null; then
                red "错误: openssl 命令未找到，无法生成 SS-2022 密钥！" >&2
                return 1
            fi
            password=$(openssl rand -base64 $key_length)
            green "已为您自动生成 SS-2022 Base64 密钥: $password" >&2
        else
            # 其他服务使用通用强密码生成
            password=$(generate_strong_password)
            green "已为您自动生成随机密码: $password" >&2
        fi
    else
        # 用户手动输入了密码
        if [[ "$service_type" == "shadowsocks" ]]; then
            yellow "警告: 已使用您输入的 '$password'。" >&2
            yellow "如果 Xray 启动失败，请检查这是否是有效的 Base64 密钥。" >&2
        fi
    fi

    # 保存密码到文件并设置权限
    echo "$password" > "$pass_file"
    chmod 600 "$pass_file"
    echo "$password"
}

# =============================================================================
# 11. 参数收集公共函数 (交互式)
# =============================================================================

# -----------------------------------------------------------------------------
# 收集 UDP2RAW 参数
# 返回格式: raw_mode|cipher_mode|auth_mode
# -----------------------------------------------------------------------------
collect_udp2raw_params() {
    read -p "raw_mode [faketcp/udp/icmp] (默认 faketcp): " raw_mode >&2
    raw_mode=${raw_mode:-faketcp}
    
    read -p "cipher_mode [aes128cbc/xor/none] (默认 aes128cbc): " cipher_mode >&2
    cipher_mode=${cipher_mode:-aes128cbc}
    
    read -p "auth_mode [hmac_sha1/simple/md5] (默认 hmac_sha1): " auth_mode >&2
    auth_mode=${auth_mode:-hmac_sha1}
    
    echo "$raw_mode|$cipher_mode|$auth_mode"
}

# -----------------------------------------------------------------------------
# 收集 KCPTUN 参数
# 返回格式: mode|crypt|tcp_enabled|nocomp
# -----------------------------------------------------------------------------
collect_kcptun_params() {

    read -p "mode [fast/fast2/fast3/normal/manual] (默认 $KCPTUN_DEFAULT_MODE): " mode >&2
    mode=${mode:-$KCPTUN_DEFAULT_MODE}
    
    read -p "crypt [aes-128/aes-192/aes-256] (默认 aes-128): " crypt >&2
    crypt=${crypt:-aes-128}
    
    read -p "tcp [true/false] (默认 false): " tcp_enabled >&2
    tcp_enabled=${tcp_enabled:-false}
    if [[ "$tcp_enabled" != "true" ]]; then
        tcp_enabled="false"
    fi
    
    read -p "nocomp [true/false] (默认 false): " nocomp_input >&2
    nocomp_input=${nocomp_input:-false}
    
    # nocomp=true 意味着 "不压缩" (Disable Compression)
    # nocomp=false 意味着 "压缩" (Enable Compression)
    local nocomp="$nocomp_input"
    
    echo "$mode|$crypt|$tcp_enabled|$nocomp"
}

# -----------------------------------------------------------------------------
# 收集 WARP 配置
# 参数: $1=服务类型 (hysteria2/xray)
# 返回: 替换好参数的配置块 (YAML 或 JSON)
# -----------------------------------------------------------------------------
collect_warp_config() {
    local service_type=$1
    read -p "是否启用 WARP SOCKS5 分流 (默认"否")？[y/N]: " enable_warp
    
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR"
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port
        warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        
        local warp_config_block=""
        if [[ "$service_type" == "hysteria2" ]]; then
            warp_config_block="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_SOCKS5_ADDR__/${warp_addr}:${warp_port}}"
        else # xray
            warp_config_block=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
            warp_config_block=${warp_config_block/__WARP_SOCKS5_ADDR__/$warp_addr}
            warp_config_block=${warp_config_block/__WARP_SOCKS5_PORT__/$warp_port}
        fi
        
        # 检查 WARP 端口是否在监听
        if ! ss -tuln | grep -q ":${warp_port} "; then
             yellow "警告: 检测到端口 ${warp_port} 未被监听！" >&2
             yellow "请确保您已安装并启动 WARP SOCKS5 服务，且端口设置为 ${warp_port}。" >&2
             yellow "您可以在主菜单选择 '14) 安装warp-Socks5' 进行安装或配置。" >&2
        else
             green "检测到 WARP 服务正在运行于端口 ${warp_port}。" >&2
        fi

        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。" >&2
        echo "$warp_config_block"
    else
        # 不启用 WARP，返回直连配置
        if [[ "$service_type" == "hysteria2" ]]; then
            echo "$HYSTERIA2_DIRECT_ACL_BLOCK"
        else # xray
            echo "$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK"
        fi
        yellow "已禁用 WARP SOCKS5 分流。" >&2
    fi
}

# -----------------------------------------------------------------------------
# 查找下一个可用的实例 ID (数字)
# 遍历目录查找未使用的文件名编号
# -----------------------------------------------------------------------------
find_next_available_id() {
    local type=$1; local dir file_prefix file_ext; local i=1
    case "$type" in
        hysteria2) dir="$HY2_INSTALL_DIR"; file_prefix="hy2"; file_ext="yaml";;
        udp2raw) dir="$UDP2RAW_INSTALL_DIR"; file_prefix="udp2raw"; file_ext="conf";;
        kcptun) dir="$KCP_INSTALL_DIR"; file_prefix="kcptun"; file_ext="json";;
        xray) dir="$XRAY_INSTALL_DIR"; file_prefix="xray"; file_ext="json";;
    esac
    while true; do
        # 检查各种可能的 ID 格式是否已存在
        if [[ ! -f "$dir/${file_prefix}_${i}.${file_ext}" && ! -f "$dir/${file_prefix}_c${i}.${file_ext}" && ! -f "$dir/${file_prefix}_vc${i}.${file_ext}" && ! -f "$dir/${file_prefix}_s3c${i}.${file_ext}" ]]; then
            echo "$i"; return
        fi
        i=$((i + 1))
    done
}

# =============================================================================
# 12. ACME 证书管理函数
# =============================================================================

# -----------------------------------------------------------------------------
# 安装 acme.sh 客户端
# -----------------------------------------------------------------------------
install_acme_sh_client() {
    if [ -f "$ACME_SH_INSTALL_DIR" ]; then
        return 0 # 已安装
    fi
    log "正在安装 acme.sh 证书客户端..."
    
    local Aemail
    read -p "请输入注册 ACME 所需的邮箱 (回车自动生成): " Aemail
    if [ -z "$Aemail" ]; then
        local auto_email=$(date +%s%N | md5sum | cut -c 1-8)
        Aemail="$auto_email@gmail.com"
        yellow "已为您自动生成邮箱: $Aemail"
    fi

    # 使用 get.acme.sh 官方安装
    curl https://get.acme.sh | sh -s email=$Aemail
    if [ ! -f "$ACME_SH_INSTALL_DIR" ]; then
        red "acme.sh 客户端安装失败！"
        return 1
    fi
    
    "$ACME_SH_INSTALL_DIR" --upgrade --auto-upgrade
    "$ACME_SH_INSTALL_DIR" --set-default-ca --server letsencrypt
    green "acme.sh 客户端安装完成。"
}

# -----------------------------------------------------------------------------
# 检查 80 端口并释放 (用于 ACME Standalone 模式)
# -----------------------------------------------------------------------------
release_80_port() {
    log "正在检查 80 端口占用..."
    local pid=$(lsof -t -i:80)
    if [ -n "$pid" ]; then
        yellow "警告: 80 端口被进程 $pid 占用。"
        read -p "是否尝试强行释放 80 端口? [Y/n] (默认“Y”): " kill_confirm
        kill_confirm=${kill_confirm:-y} # Default to yes if empty
        if [[ "$kill_confirm" == "y" || "$kill_confirm" == "Y" ]]; then
            log "正在强行释放 80 端口..."
            kill -9 $pid
            sleep 2
            if lsof -t -i:80 >/dev/null; then
                red "80 端口释放失败！"
                return 1
            else
                green "80 端口已释放。"
            fi
        else
            red "80 端口被占用，ACME Standalone 模式无法继续。"
            return 1
        fi
    fi
    return 0
}

# -----------------------------------------------------------------------------
# 核心函数：获取或续订证书
# 支持 80 端口模式和 DNS API 模式
# -----------------------------------------------------------------------------
ax_get_certificate() {
    local domain=$1
    local cert_dir="$AX_CERT_DIR/$domain"
    
    # 1. 检查证书是否已存在且有效
    if [ -f "$cert_dir/fullchain.cer" ]; then
        log "证书 $domain 已存在于 $cert_dir"
        return 0
    fi
    
    # 2. 确保 acme.sh 客户端已安装
    install_acme_sh_client || return 1
    
    # 3. 检查 DNS 解析 (确保域名解析到本机)
    log "正在验证 $domain 的 DNS 解析..."
    local v4=$(curl -s4m2 $PUBLIC_IP_SERVICE_1 || curl -s4m2 $PUBLIC_IP_SERVICE_2)
    local v6=$(curl -s6m2 $PUBLIC_IP_SERVICE_1 || curl -s6m2 $PUBLIC_IP_SERVICE_2)
    local domainIP=$(dig @8.8.8.8 +time=2 +short "$domain" 2>/dev/null | grep -m1 '^[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+$')
    
    if [[ -z "$domainIP" && -n "$v6" ]]; then
        domainIP=$(dig @2001:4860:4860::8888 +time=2 aaaa +short "$domain" 2>/dev/null | grep -m1 ':')
    fi
    
    if [[ -z "$domainIP" ]]; then
        red "错误: 无法解析 $domain 的 IP 地址。"
        return 1
    fi
    
    if [[ "$domainIP" != "$v4" && "$domainIP" != "$v6" ]]; then
        red "错误: $domain 解析的 IP ($domainIP) 与本机 IP ($v4 / $v6) 不匹配！"
        yellow "请确保 DNS 记录已正确设置，且 CDN (小黄云) 已关闭。"
        return 1
    fi
    green "DNS 验证通过: $domain -> $domainIP"

    # 4. 选择 ACME 模式
    read -p "选择 ACME 验证模式: [1] 80 端口 (Standalone) [2] DNS API (推荐): " acme_mode
    local issue_cmd=""

    if [ "$acme_mode" == "1" ]; then
        # 80 端口模式
        release_80_port || return 1
        local listen_opt=""
        if [[ "$domainIP" == "$v6" ]]; then
            listen_opt="--listen-v6"
        fi
        issue_cmd="$ACME_SH_INSTALL_DIR --issue -d $domain --standalone -k ec-256 $listen_opt"
    
    elif [ "$acme_mode" == "2" ]; then
        # DNS API 模式
        read -p "选择 DNS 服务商: [1] Cloudflare [2] DNSPod [3] Aliyun: " dns_provider
        local dns_api_cmd=""
        yellow "警告: API 密钥将保存在 acme.sh 配置中 (~/.acme.sh/account.conf)"
        
        case $dns_provider in
            1) # Cloudflare
                read -s -p "请输入 Cloudflare Global API Key: " GAK; echo
                export CF_Key="$GAK"
                read -p "请输入 Cloudflare 注册邮箱: " CFemail
                export CF_Email="$CFemail"
                dns_api_cmd="--dns dns_cf"
                ;;
            2) # DNSPod
                read -s -p "请输入 DNSPod DP_Id: " DPID; echo
                export DP_Id="$DPID"
                read -s -p "请输入 DNSPod DP_Key: " DPKEY; echo
                export DP_Key="$DPKEY"
                dns_api_cmd="--dns dns_dp"
                ;;
            3) # Aliyun
                read -s -p "请输入 Aliyun Ali_Key: " ALKEY; echo
                export Ali_Key="$ALKEY"
                read -s -p "请输入 Aliyun Ali_Secret: " ALSER; echo
                export Ali_Secret="$ALSER"
                dns_api_cmd="--dns dns_ali"
                ;;
            *)
                red "无效的服务商选择。"
                return 1
                ;;
        esac
        issue_cmd="$ACME_SH_INSTALL_DIR --issue -d $domain $dns_api_cmd -k ec-256 --force"
    
    else
        red "无效的模式选择。"
        return 1
    fi

    # 5. 执行申请
    log "正在执行 ACME 证书申请，请稍候..."
    eval $issue_cmd
    if [ $? -ne 0 ]; then
        red "ACME 证书申请失败！"
        return 1
    fi
    
    # 6. 安装证书到 ax 目录
    log "正在安装证书到 $cert_dir ..."
    mkdir -p "$cert_dir"
    "$ACME_SH_INSTALL_DIR" --install-cert -d "$domain" --ecc \
        --fullchain-file "$cert_dir/fullchain.cer" \
        --key-file "$cert_dir/private.key"
        
    if [ -f "$cert_dir/fullchain.cer" ]; then
        green "证书 $domain 已成功安装到 $cert_dir"
        # 确保 cron 任务已设置
        "$ACME_SH_INSTALL_DIR" --cron -f >/dev/null 2>&1
        return 0
    else
        red "证书安装失败！"
        return 1
    fi
}

# =============================================================================
# 13. 核心程序下载与安装函数
# =============================================================================

# -----------------------------------------------------------------------------
# 获取 GitHub 仓库最新 Release 标签
# -----------------------------------------------------------------------------
get_latest_github_tag() {
    local repo_name=$1
    # 使用 jq -r .tag_name 来安全、准确地获取标签名
    curl -s "$GITHUB_API_URL/$repo_name/releases/latest" | jq -r .tag_name
}

# -----------------------------------------------------------------------------
# 下载并安装 KCPTUN 和 UDP2RAW 二进制文件
# -----------------------------------------------------------------------------
download_kcp_udp_binaries(){
    local kcp_latest=$(get_latest_github_tag "$KCPTUN_REPO")
    local udp_latest=$(get_latest_github_tag "$UDP2RAW_REPO")
    if [[ -z "$kcp_latest" || -z "$udp_latest" ]]; then red "获取 KCPTUN/UDP2RAW 版本号失败。"; return 1; fi
    
    mkdir -p "$KCP_INSTALL_DIR"
    mkdir -p "$UDP2RAW_INSTALL_DIR"

    # KCPTUN
    local kcp_current=$(cat "$KCP_INSTALL_DIR/version.txt" 2>/dev/null)
    if [[ "$kcp_latest" != "$kcp_current" ]]; then
        log "发现 KCPTUN 新版本: $kcp_latest (当前: ${kcp_current:-未知})"
        log "下载 KCPTUN ($kcp_latest)..."
        download_with_retry "$GITHUB_URL/$KCPTUN_REPO/releases/download/${kcp_latest}/kcptun-linux-amd64-$(echo $kcp_latest | sed 's/v//').tar.gz" /tmp/kcptun.tar.gz && \
        tar -xzf /tmp/kcptun.tar.gz -C "$KCP_INSTALL_DIR" server_linux_amd64 && mv "$KCP_INSTALL_DIR/server_linux_amd64" "$KCP_INSTALL_DIR/kcptun_server" && \
        echo "$kcp_latest" > "$KCP_INSTALL_DIR/version.txt" && chmod +x "$KCP_INSTALL_DIR/kcptun_server" || { red "KCPTUN 更新失败。"; return 1; }
    else
        green "KCPTUN 已是最新版本 ($kcp_latest)"
    fi

    # UDP2RAW
    local udp_current=$(cat "$UDP2RAW_INSTALL_DIR/version.txt" 2>/dev/null)
    if [[ "$udp_latest" != "$udp_current" ]]; then
        log "发现 UDP2RAW 新版本: $udp_latest (当前: ${udp_current:-未知})"
        log "下载 UDP2RAW ($udp_latest)..."
        download_with_retry "$GITHUB_URL/$UDP2RAW_REPO/releases/download/${udp_latest}/udp2raw_binaries.tar.gz" /tmp/udp2raw.tar.gz && \
        tar -xzf /tmp/udp2raw.tar.gz -C "$UDP2RAW_INSTALL_DIR" udp2raw_amd64 && mv "$UDP2RAW_INSTALL_DIR/udp2raw_amd64" "$UDP2RAW_INSTALL_DIR/udp2raw" && \
        echo "$udp_latest" > "$UDP2RAW_INSTALL_DIR/version.txt" && chmod +x "$UDP2RAW_INSTALL_DIR/udp2raw" || { red "UDP2RAW 更新失败。"; return 1; }
    else
        green "UDP2RAW 已是最新版本 ($udp_latest)"
    fi
}

# -----------------------------------------------------------------------------
# 下载并安装 Hysteria2 二进制文件
# -----------------------------------------------------------------------------
download_hysteria2_binary(){
    local hy2_latest=$(get_latest_github_tag "$HY2_REPO")
    if [[ -z "$hy2_latest" ]]; then red "获取 Hysteria2 版本号失败。"; return 1; fi

    mkdir -p "$HY2_INSTALL_DIR"
    local hy2_current=$(cat "$HY2_INSTALL_DIR/version.txt" 2>/dev/null)
    
    if [[ "$hy2_latest" != "$hy2_current" ]]; then
        log "发现 Hysteria2 新版本: $hy2_latest (当前: ${hy2_current:-未知})"
        log "下载 Hysteria2 ($hy2_latest)..."
        local hy2_url="$GITHUB_URL/$HY2_REPO/releases/download/${hy2_latest}/hysteria-linux-amd64"
        download_with_retry "$hy2_url" "$HY2_INSTALL_DIR/hysteria" && \
        echo "$hy2_latest" > "$HY2_INSTALL_DIR/version.txt" && chmod +x "$HY2_INSTALL_DIR/hysteria" || { red "Hysteria2 下载失败。"; return 1; }
    else
        green "Hysteria2 已是最新版本 ($hy2_latest)"
    fi
}

# -----------------------------------------------------------------------------
# 下载并安装 Xray-core 二进制文件
# -----------------------------------------------------------------------------
download_xray_binary(){
    local xray_latest=$(get_latest_github_tag "$XRAY_REPO")
    if [[ -z "$xray_latest" ]]; then red "获取 Xray-core 版本号失败。"; return 1; fi
    
    mkdir -p "$XRAY_INSTALL_DIR"
    local xray_current=$(cat "$XRAY_INSTALL_DIR/version.txt" 2>/dev/null)
    
    if [[ "$xray_latest" != "$xray_current" ]]; then
        log "发现 Xray-core 新版本: $xray_latest (当前: ${xray_current:-未知})"
        log "下载 Xray-core ($xray_latest)..."
        local xray_url="$GITHUB_URL/$XRAY_REPO/releases/download/${xray_latest}/Xray-linux-64.zip"
        download_with_retry "$xray_url" /tmp/xray.zip || { red "Xray-core 下载失败。"; return 1; }
        unzip -o /tmp/xray.zip -d "$XRAY_INSTALL_DIR" xray geoip.dat geosite.dat && \
        echo "$xray_latest" > "$XRAY_INSTALL_DIR/version.txt" && chmod +x "$XRAY_INSTALL_DIR/xray" || { red "Xray-core 解压失败。"; return 1; }
    else
        green "Xray-core 已是最新版本 ($xray_latest)"
    fi
    
    # 复制 geo dat 文件到 Hysteria2 目录 (供 Hysteria2 使用)
    log "正在复制 geoip.dat / geosite.dat 到 Hysteria2 目录..."
    cp -n "$XRAY_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    cp -n "$XRAY_INSTALL_DIR/geosite.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    chmod 644 "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat" 2>/dev/null
}

# =============================================================================
# 14. Systemd 服务管理与状态查询
# =============================================================================

# -----------------------------------------------------------------------------
# 确保所有 Systemd 服务模板文件都已创建
# -----------------------------------------------------------------------------
ensure_template_files() {
    # KCPTUN Template
    cat > "$KCPTUN_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=KCPTUN Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$KCP_INSTALL_DIR/kcptun_server -c $KCP_INSTALL_DIR/kcptun_%i.json
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F

    # UDP2RAW Template
    cat > "$UDP2RAW_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=UDP2RAW Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$UDP2RAW_INSTALL_DIR/udp2raw --conf-file $UDP2RAW_INSTALL_DIR/udp2raw_%i.conf
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F

    # Hysteria2 Template
    generate_self_signed_cert
    cat > "$HY2_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Hysteria2 Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$HY2_INSTALL_DIR/hysteria -c $HY2_INSTALL_DIR/hy2_%i.yaml server
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F

    # Xray Template
    cat > "$XRAY_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Xray Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$XRAY_INSTALL_DIR/xray -c $XRAY_INSTALL_DIR/xray_%i.json
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F

    systemctl daemon-reload
}

# -----------------------------------------------------------------------------
# 从配置文件中提取监听地址和端口 (用于显示状态)
# -----------------------------------------------------------------------------
get_listen_info_from_conf() {
    local conf_path=$1
    if [[ ! -f "$conf_path" ]]; then echo "配置文件不存在"; return; fi

    if [[ "$conf_path" == *".json" ]]; then
        if grep -q '"smuxver"' "$conf_path" 2>/dev/null; then
            grep -Po '(?<="listen": ")[^"]+' "$conf_path"
        else
            local listen=$(jq -r '.inbounds[0].listen // "0.0.0.0"' "$conf_path" 2>/dev/null)
            local port=$(jq -r '.inbounds[0].port // 0' "$conf_path" 2>/dev/null)
            if [[ "$listen" == "null" || "$port" == "0" ]]; then echo "JSON解析错误"; else echo "${listen}:${port}"; fi
        fi
    elif [[ "$conf_path" == *".conf" ]]; then
        grep -Po '(?<=-l )[^ ]+' "$conf_path"
    elif [[ "$conf_path" == *".yaml" ]]; then
        local raw_listen=$(grep -Po '(?<=listen: ).*' "$conf_path" | tr -d '[:space:]')
        if [[ "$raw_listen" == :* ]]; then echo "0.0.0.0$raw_listen"; else echo "$raw_listen"; fi
    fi
}

# -----------------------------------------------------------------------------
# 从配置文件中检查 WARP 是否启用
# -----------------------------------------------------------------------------
get_warp_status_from_conf() {
    local conf_path=$1
    if [[ "$conf_path" == *".yaml" ]]; then
        if grep -q "name: warp" "$conf_path" 2>/dev/null; then echo "已启用WARP"; else echo "未启用WARP"; fi
    elif [[ "$conf_path" == *".json" ]]; then
        if jq -e '.outbounds[] | select(.tag == "warp")' "$conf_path" >/dev/null 2>&1; then echo "已启用WARP"; else echo "未启用WARP"; fi
    else
        echo ""
    fi
}

# -----------------------------------------------------------------------------
# 获取单个服务的运行状态字符串 (绿色或黄色)
# -----------------------------------------------------------------------------
get_service_status_string() {
    local service_name=$1
    if systemctl is-active --quiet "$service_name"; then echo "运行中"; else echo "未运行"; fi
}

# -----------------------------------------------------------------------------
# 获取串联实例的组合状态 (颜色, 状态1, 状态2)
# -----------------------------------------------------------------------------
get_chain_status_tuple() {
    local chain_type=$1 chain_id=$2
    local service1_name="" service2_name=""
    if [[ "$chain_type" == "hy2" ]]; then
        service1_name="ax-hysteria2@${chain_id}.service"
        service2_name="ax-udp2raw@${chain_id}.service"
    else # vless
        service1_name="ax-xray@${chain_id}.service"
        service2_name="ax-udp2raw@${chain_id}.service"
    fi
    
    local s1_active=false s2_active=false status_color="yellow"
    if systemctl is-active --quiet "$service1_name"; then s1_active=true; fi
    if systemctl is-active --quiet "$service2_name"; then s2_active=true; fi
    if $s1_active && $s2_active; then status_color="cyan"; fi
    
    echo "$status_color $(get_service_status_string "$service1_name") $(get_service_status_string "$service2_name")"
}

# -----------------------------------------------------------------------------
# 获取 3 组件串联实例的组合状态 (颜色, 状态1, 状态2, 状态3)
# -----------------------------------------------------------------------------
get_3_chain_status_tuple() {
    local chain_id=$1 # e.g., s3c1
    local service1_name="ax-xray@${chain_id}.service" # SS
    local service2_name="ax-kcptun@${chain_id}.service"        # KCPTUN
    local service3_name="ax-udp2raw@${chain_id}.service"        # UDP2RAW
    
    local s1_active=false s2_active=false s3_active=false status_color="yellow"
    if systemctl is-active --quiet "$service1_name"; then s1_active=true; fi
    if systemctl is-active --quiet "$service2_name"; then s2_active=true; fi
    if systemctl is-active --quiet "$service3_name"; then s3_active=true; fi
    
    if $s1_active && $s2_active && $s3_active; then status_color="cyan"; fi
    
    echo "$status_color $(get_service_status_string "$service1_name") $(get_service_status_string "$service2_name") $(get_service_status_string "$service3_name")"
}


# -----------------------------------------------------------------------------
# 显示单个实例的状态行 (用于主菜单)
# -----------------------------------------------------------------------------
display_instance_status_line() {
    local type=$1 id=$2 prefix=$3; local full_id="$id"; local line
    case "$type" in
        "hy2_chain")
            full_id="c${id}"
            read -r color hy2_status udp_status <<< "$(get_chain_status_tuple "hy2" "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$HY2_INSTALL_DIR/hy2_${full_id}.yaml")
            line="$($color "${prefix}Hysteria2 [${hy2_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "vless_chain")
            full_id="vc${id}"
            read -r color xray_status udp_status <<< "$(get_chain_status_tuple "vless" "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}VLESS_mKCP [${xray_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "ss_3_chain_chain")
            full_id="s3c${id}"
            read -r color s1_status s2_status s3_status <<< "$(get_3_chain_status_tuple "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}SS [${s1_status}] + KCP [${s2_status}] + UDP2RAW [${s3_status}] ${udp_info} (${warp_status})")"
            ;;
        "hysteria2"|"udp2raw"|"kcptun"|"xray_reality"|"xray_mkcp"|"xray_ss")
            local conf_file service_prefix title; local color_func="yellow"
            case "$type" in
                hysteria2) conf_file="$HY2_INSTALL_DIR/hy2_${id}.yaml"; service_prefix="ax-hysteria2"; title="Hysteria2";;
                udp2raw) conf_file="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"; service_prefix="ax-udp2raw"; title="UDP2RAW";;
                kcptun) conf_file="$KCP_INSTALL_DIR/kcptun_${id}.json"; service_prefix="ax-kcptun"; title="KCPTUN";;
                xray_reality) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="VLESS+Reality";;
                xray_mkcp) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="VLESS+mKCP";;
                xray_ss) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="Shadowsocks";;
            esac
            local status_info=$(get_listen_info_from_conf "$conf_file")
            local status_str=$(get_service_status_string "${service_prefix}@${id}.service")
            local extra_info=""
            if [[ "$type" == "hysteria2" || "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then
                extra_info=" ($(get_warp_status_from_conf "$conf_file"))"
            fi
            if [[ "$status_str" == "运行中" ]]; then color_func="cyan"; fi
            line="$($color_func "${prefix}${title} [${status_str}] ${status_info}${extra_info}")"
            ;;
    esac
    echo -e "$line"
}

# -----------------------------------------------------------------------------
# 获取指定目录下的所有实例 ID (内部函数)
# -----------------------------------------------------------------------------
get_instances() {
    local dir=$1 pattern=$2
    ls -1 "$dir"/$pattern 2>/dev/null | sed -E "s/.*_([a-zA-Z0-9]+)\\..*/\1/" | sort -V
}

# -----------------------------------------------------------------------------
# 获取 *独立* 实例的 ID 列表 (过滤掉串联实例)
# -----------------------------------------------------------------------------
get_standalone_instances() {
    local type_lowercase=$1
    local dir="" pattern=""
    local standalone_instances=()
    
    case "$type_lowercase" in
        "hysteria2") dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml";;
        "xray_reality") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_mkcp") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_ss") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "udp2raw") dir="$UDP2RAW_INSTALL_DIR"; pattern="udp2raw_*.conf";;
        "kcptun") dir="$KCP_INSTALL_DIR"; pattern="kcptun_*.json";;
    esac

    local all_instances=$(get_instances "$dir" "$pattern")
    for i in $all_instances; do
        if [[ "$type_lowercase" == "xray_reality" ]]; then
            grep -q '"security": "reality"' "$dir/xray_${i}.json" 2>/dev/null && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_mkcp" ]]; then
            grep -q '"network": "kcp"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^(vc|s3c)[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_ss" ]]; then
            grep -q '"protocol": "shadowsocks"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^s3c[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ ! "$i" =~ ^(c|vc|s3c)[0-9]+$ ]]; then
            standalone_instances+=($i)
        fi
    done
    echo "${standalone_instances[@]}"
}


# =============================================================================
# 15. 实例管理菜单与操作
# =============================================================================

# -----------------------------------------------------------------------------
# 管理单个独立实例的子菜单
# -----------------------------------------------------------------------------
manage_instance_menu() {
    local type=$1 id=$2 service=$3 conf=$4
    while true; do
        clear; echo "=================================="; echo "      管理 ${type^^} 实例 $(dim "$id")"; echo "=================================="
        echo "状态：$(get_service_status_string "$service") $(dim "$(get_listen_info_from_conf "$conf")")"
        if [[ "$type" == "hysteria2" ]]; then cyan "订阅链接: $(generate_hy2_subscription_link $id)"; fi
        if [[ "$type" == "xray_reality" ]]; then cyan "分享链接: $(generate_xray_reality_link $id)"; fi
        if [[ "$type" == "xray_mkcp" ]]; then cyan "分享链接: $(generate_xray_mkcp_link $id)"; fi
        if [[ "$type" == "xray_ss" ]]; then cyan "分享链接: $(generate_xray_ss_link $id)"; fi
        echo "----------------------------------"; echo "1) 启动/重启"; echo "2) 停止"; echo "3) 查看实时日志"; echo "4) 编辑配置"; echo "6) 查看客户端配置"; echo "99) 删除此实例"; echo "0) 返回"
        read -p "请选择 [0-4, 6, 99]: " choice
        case $choice in
            1) log "正在启动/重启..."; systemctl restart "$service"; green "操作完成！";;
            2) log "正在停止..."; systemctl stop "$service"; green "操作完成！";;
            3) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪日志... (按 Ctrl+C 仅退出日志)"
                sleep 1
                local current_trap=$(trap -p SIGINT) # 保存当前 trap
                trap ':' SIGINT
                journalctl -u "$service" -f --since "1 hour ago"
                eval "$current_trap" # 恢复 trap
                ;;
            4) nano "$conf"; log "重启实例以应用配置..."; systemctl restart "$service"; green "配置已更新！";;
            99) read -p "确认彻底删除实例 ${id}？(默认“否”) [y/N]: " confirm; if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then log "停止并删除..."; systemctl stop "$service"; systemctl disable "$service" >/dev/null 2>&1; rm -f "$conf"; systemctl daemon-reload; green "实例 ${id} 已删除！"; break; fi;;
            6) clear; echo "--- ${type^^} 客户端配置 (实例 $id) ---"
               case "$type" in
                   "hysteria2") cyan "订阅链接: $(generate_hy2_subscription_link "$id")" ;;
                   "udp2raw") view_udp2raw_client_config "$id" ;;
                   "kcptun") view_kcptun_client_config "$id" ;;
                   "xray_reality") cyan "分享链接: $(generate_xray_reality_link "$id")" ;;
                   "xray_mkcp") cyan "分享链接: $(generate_xray_mkcp_link "$id")" ;;
                   "xray_ss") cyan "分享链接: $(generate_xray_ss_link "$id")" ;;
               esac
               read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$choice" == "1" || "$choice" == "2" || "$choice" == "4" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}

# -----------------------------------------------------------------------------
# 创建一个新的独立实例 (Hysteria2, UDP2RAW, KCPTUN)
# -----------------------------------------------------------------------------
create_new_instance() {
    local type=$1; local next_id; local INSTALL_DIR SERVICE_PREFIX FILE_EXT TITLE CONFIG_TEMPLATE SYSTEMD_SERVICE_NAME
    declare -A replacements

    case "$type" in
        hysteria2) 
            TITLE="Hysteria2"
            INSTALL_DIR="$HY2_INSTALL_DIR"
            SERVICE_PREFIX="hy2"
            SYSTEMD_SERVICE_NAME="ax-hysteria2"
            FILE_EXT="yaml"
            CONFIG_TEMPLATE="$HYSTERIA2_CONFIG_YAML_TEMPLATE"

            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ax-${SYSTEMD_SERVICE_NAME}@${next_id}.service"

            read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN__"]=":${listen_port}"
            read -p "ignoreClientBandwidth [true/false] (默认 true): " ignore_client_bandwidth
            ignore_client_bandwidth=${ignore_client_bandwidth:-true}
            if [[ "$ignore_client_bandwidth" != "false" ]]; then
                ignore_client_bandwidth="true"
            fi
            replacements["__IGNORE_CLIENT_BANDWIDTH__"]="$ignore_client_bandwidth"

            cyan "--- ACME证书 配置 ---"
            read -p "是否使用 ACME证书? (否则将使用自签名证书) [Y/n] (默认“Y”): " use_acme
            use_acme=${use_acme:-y} # Default to yes
            
            local cert_path="" key_path="" sni="" masquerade_url=""
            
            if [[ "$use_acme" == "y" || "$use_acme" == "Y" ]]; then
                read -p "请输入您的域名 (DNS 必须指向本机): " domain_name
                if [[ -z "$domain_name" ]]; then
                    red "域名不能为空！已取消创建。"
                    return 1
                fi

                # 尝试申请证书，如果失败直接退出
                if ! ax_get_certificate "$domain_name"; then
                    red "ACME 证书申请流程失败，已取消创建实例。"
                    return 1
                fi
                
                # 双重检查文件是否存在
                if [ -f "$AX_CERT_DIR/$domain_name/fullchain.cer" ]; then
                    green "ACME 验证成功. Hysteria2 将使用 $domain_name"
                    cert_path="$AX_CERT_DIR/$domain_name/fullchain.cer"
                    key_path="$AX_CERT_DIR/$domain_name/private.key"
                    sni="$domain_name"
                    masquerade_url="https://$domain_name"
                else
                    red "错误：未找到申请的证书文件，已取消创建实例。"
                    return 1
                fi
            else
                # 用户明确选择“否”，使用自签名
                generate_self_signed_cert
                cert_path="$HY2_CERT_PATH"
                key_path="$HY2_KEY_PATH"
                sni="$HY2_SNI"
                masquerade_url="$HY2_MASQUERADE_URL"
            fi
            
            replacements["__CERT_PATH__"]="$cert_path"
            replacements["__KEY_PATH__"]="$key_path"
            replacements["__MASQUERADE_URL__"]="$masquerade_url"

            # 生成密码
            local password=$(handle_password_input "hysteria2")
            replacements["__PASSWORD__"]="$password"
            
            # 收集WARP配置
            cyan "--- warp sockets 配置 ---"
            local warp_config=$(collect_warp_config "hysteria2")
            replacements["__OUTBOUNDS_AND_ACL__"]="$warp_config"
            
            replacements["__UDP_SNIFF_CONFIG__"]=""
            ;;
        udp2raw) TITLE="UDP2RAW"; INSTALL_DIR="$UDP2RAW_INSTALL_DIR"; SERVICE_PREFIX="udp2raw"; SYSTEMD_SERVICE_NAME="ax-udp2raw"; FILE_EXT="conf"; CONFIG_TEMPLATE="$UDP2RAW_CONFIG_TEMPLATE" 
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ax-${SYSTEMD_SERVICE_NAME}@${next_id}.service"
            read -p "请输入监听地址 (默认: $DEFAULT_LISTEN_ADDR): " listen_addr_input; listen_addr=${listen_addr_input:-$DEFAULT_LISTEN_ADDR}
            read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN_ADDR__"]="${listen_addr}:${listen_port}"
            read -p "请输入目标地址 (默认: $DEFAULT_TARGET_ADDR): " target_host; target_host=${target_host:-$DEFAULT_TARGET_ADDR}
            read -p "请输入目标端口 (留空则随机生成): " target_port; if [[ -z "$target_port" ]]; then target_port=$(find_available_port); green "已为您随机选择目标端口: $target_port"; fi
            replacements["__TARGET_ADDR__"]="${target_host}:${target_port}"
            
            # 收集UDP2RAW配置参数
            local udp_params=$(collect_udp2raw_params)
            IFS='|' read -r raw_mode cipher_mode auth_mode <<< "$udp_params"
            replacements["__RAW_MODE__"]="$raw_mode"
            replacements["__CIPHER_MODE__"]="$cipher_mode"
            replacements["__AUTH_MODE__"]="$auth_mode"
            
            # 生成密码
            local password=$(handle_password_input "$type"); replacements["__PASSWORD__"]="$password"
            ;;
            
        kcptun) TITLE="KCPTUN"; INSTALL_DIR="$KCP_INSTALL_DIR"; SERVICE_PREFIX="kcptun"; SYSTEMD_SERVICE_NAME="ax-kcptun"; FILE_EXT="json"; CONFIG_TEMPLATE="$KCPTUN_CONFIG_JSON_TEMPLATE" 
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ax-${SYSTEMD_SERVICE_NAME}@${next_id}.service"
            read -p "请输入监听地址 (默认: $DEFAULT_LISTEN_ADDR): " listen_addr_input; listen_addr=${listen_addr_input:-$DEFAULT_LISTEN_ADDR}
            read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN__"]="${listen_addr}:${listen_port}"
            read -p "请输入目标地址 (默认: $DEFAULT_TARGET_ADDR): " target_host; target_host=${target_host:-$DEFAULT_TARGET_ADDR}
            read -p "请输入目标端口 (留空则随机生成): " target_port; if [[ -z "$target_port" ]]; then target_port=$(find_available_port); green "已为您随机选择目标端口: $target_port"; fi
            replacements["__TARGET__"]="${target_host}:${target_port}"
            
            # 收集KCPTUN配置参数
            local kcp_params=$(collect_kcptun_params)
            IFS='|' read -r mode crypt tcp_enabled nocomp <<< "$kcp_params"
            replacements["__MODE__"]="$mode"
            replacements["__CRYPT__"]="$crypt"
            replacements["__TCP__"]="$tcp_enabled"
            replacements["__NOCOMP__"]="$nocomp"
            
            # 生成密码
            local password=$(handle_password_input "$type"); replacements["__KEY__"]="$password"
            ;;
            
        *) red "内部错误: 无效的实例类型 '$type'"; return 1 ;;
    esac

    log "生成配置文件..."; local temp_config="$CONFIG_TEMPLATE"; local conf_path="${INSTALL_DIR}/${SERVICE_PREFIX}_${next_id}.${FILE_EXT}"
    for placeholder in "${!replacements[@]}"; do temp_config="${temp_config//${placeholder}/${replacements[${placeholder}]}}"; done
    echo "$temp_config" > "$conf_path"

    sync; log "启动服务..."; systemctl enable --now "${SYSTEMD_SERVICE_NAME}@${next_id}.service"; sleep 1; green "实例 ${next_id} 已启动！"; echo
    case "$type" in
        hysteria2) local sub_link=""; local retries=5; for ((i=1; i<=retries; i++)); do sub_link=$(generate_hy2_subscription_link $next_id); if [[ "$sub_link" != "N/A" ]]; then break; fi; sleep 0.5; done; cyan "订阅链接: $sub_link";;
        udp2raw) view_udp2raw_client_config "$next_id" ;;
        kcptun) view_kcptun_client_config "$next_id" ;;
    esac
}

# -----------------------------------------------------------------------------
# 创建一个新的 Xray 实例 (Reality, mKCP, Shadowsocks)
# -----------------------------------------------------------------------------
create_new_xray_instance() {
    local type=$1; local next_id;
    next_id=$(find_next_available_id "xray")
    
    declare -A replacements
    local temp_config=""
    local title=""

    if [[ "$type" == "xray_reality" ]]; then
        title="VLESS+Reality"
        temp_config="$XRAY_VLESS_REALITY_TEMPLATE"
        log "启动一个新的 ${title} 实例..."
        green "新实例将被创建为: ax-xray@${next_id}.service"
        
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"
        
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        
        log "正在生成 Reality 密钥对..."
        local tmp_key=$("$XRAY_INSTALL_DIR/xray" x25519)
        local private_key=$(echo "$tmp_key" | grep "Private key" | cut -d: -f2- | tr -d '[:space:]')
        local public_key=$(echo "$tmp_key" | grep "Public key" | cut -d: -f2- | tr -d '[:space:]')

        if [[ -z "$private_key" ]]; then
            private_key=$(echo "$tmp_key" | grep "PrivateKey" | cut -d: -f2- | tr -d '[:space:]')
        fi
        if [[ -z "$public_key" ]]; then
            public_key=$(echo "$tmp_key" | grep "Password" | cut -d: -f2- | tr -d '[:space:]')
        fi

        if [[ -z "$private_key" || -z "$public_key" ]]; then
            red "错误: 无法生成或解析 Reality 密钥对！"
            log "Xray 命令输出 (Debug): $tmp_key" 
            return 1
        fi

        replacements["__PRIVATE_KEY__"]="$private_key"
        replacements["__PUBLIC_KEY__"]="$public_key"
                
        green "已使用默认 Reality 参数: SNI=${XRAY_REALITY_DEFAULT_SNI}, Target=${XRAY_REALITY_DEFAULT_TARGET}, Fingerprint=${XRAY_REALITY_DEFAULT_FP}"
        replacements["__SNI__"]="$XRAY_REALITY_DEFAULT_SNI"
        replacements["__TARGET__"]="$XRAY_REALITY_DEFAULT_TARGET"
        replacements["__FINGERPRINT__"]="$XRAY_REALITY_DEFAULT_FP"
        replacements["__REALITY_FLOW__"]="$XRAY_REALITY_DEFAULT_FLOW"
        
        local short_id=$(openssl rand -hex 8); replacements["__SHORT_ID__"]="$short_id"
    
    elif [[ "$type" == "xray_mkcp" ]]; then
        title="VLESS+mKCP"
        temp_config="$XRAY_VLESS_MKCP_TEMPLATE"
        log "启动一个新的 ${title} 实例..."
        green "新实例将被创建为: ax-xray@${next_id}.service"
        
        read -p "请输入监听 IP (默认: $DEFAULT_LISTEN_ADDR): " listen_addr; listen_addr=${listen_addr:-$DEFAULT_LISTEN_ADDR}; replacements["__LISTEN_ADDR__"]="$listen_addr"
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"
        
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        local mkcp_seed=$(handle_password_input "xray_mkcp"); replacements["__MKCP_SEED__"]="$mkcp_seed"
        read -p "congestion [true/false] (默认 true): " mkcp_congestion
        mkcp_congestion=${mkcp_congestion:-true}
        if [[ "$mkcp_congestion" != "false" ]]; then
            mkcp_congestion="true"
        fi
        
        if [[ "$mkcp_congestion" == "true" ]]; then
            # 在模板中添加congestion字段
            temp_config=$(echo "$temp_config" | sed 's/"seed": "__MKCP_SEED__"/"seed": "__MKCP_SEED__", "congestion": true/')
        fi
    elif [[ "$type" == "xray_ss" ]]; then
        title="Shadowsocks"
        temp_config="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE"
        log "启动一个新的 ${title} 实例..."
        green "新实例将被创建为: ax-xray@${next_id}.service"

        read -p "请输入监听 IP (默认: $DEFAULT_LISTEN_ADDR): " listen_addr; listen_addr=${listen_addr:-$DEFAULT_LISTEN_ADDR}; replacements["__LISTEN_ADDR__"]="$listen_addr"
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"

        # 添加Shadowsocks加密方式选择
        cyan "--- Shadowsocks 加密方式选项 ---"
        echo "1) 2022-blake3-aes-256-gcm (推荐)"
        echo "2) 2022-blake3-aes-128-gcm"
        echo "3) 2022-blake3-chacha20-poly1305"
        echo "4) aes-256-gcm"
        echo "5) aes-128-gcm"
        echo "6) chacha20-poly1305"
        read -p "请选择加密方式 (默认 1): " ss_method_choice
        ss_method_choice=${ss_method_choice:-1}
        
        local ss_method=""
        case $ss_method_choice in
            1) ss_method="2022-blake3-aes-256-gcm" ;;
            2) ss_method="2022-blake3-aes-128-gcm" ;;
            3) ss_method="2022-blake3-chacha20-poly1305" ;;
            4) ss_method="aes-256-gcm" ;;
            5) ss_method="aes-128-gcm" ;;
            6) ss_method="chacha20-poly1305" ;;
            *) ss_method="2022-blake3-aes-256-gcm" ;;
        esac
        
        replacements["__SS_METHOD__"]="$ss_method"
        local ss_password=$(handle_password_input "shadowsocks"); replacements["__SS_PASSWORD__"]="$ss_password"
    fi
    read -p "是否启用 WARP SOCKS5 分流 (默认“否”)？[y/N]: " enable_warp
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # [新] 自动使用默认地址
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        local warp_config=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
        warp_config=${warp_config/__WARP_SOCKS5_ADDR__/$warp_addr}
        warp_config=${warp_config/__WARP_SOCKS5_PORT__/$warp_port}
        replacements["__OUTBOUNDS_AND_ROUTING__"]="$warp_config"
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        replacements["__OUTBOUNDS_AND_ROUTING__"]="$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK"
        yellow "已禁用 WARP SOCKS5 分流。"
    fi

    log "生成配置文件..."; local conf_path="${XRAY_INSTALL_DIR}/xray_${next_id}.json"
    for placeholder in "${!replacements[@]}"; do
        temp_config="${temp_config//${placeholder}/${replacements[${placeholder}]}}"
    done
    echo "$temp_config" > "$conf_path"

    sync; log "启动服务..."; systemctl enable --now "ax-xray@${next_id}.service"; sleep 1;
    if ! systemctl is-active --quiet "ax-xray@${next_id}.service"; then
        red "实例 ${next_id} 启动失败！请检查配置或日志。"
    else
        green "实例 ${next_id} 已启动！"; echo
        if [[ "$type" == "xray_reality" ]]; then
            cyan "分享链接: $(generate_xray_reality_link "$next_id")"
        elif [[ "$type" == "xray_mkcp" ]]; then
            cyan "分享链接: $(generate_xray_mkcp_link "$next_id")"
        elif [[ "$type" == "xray_ss" ]]; then
            cyan "分享链接: $(generate_xray_ss_link "$next_id")"
        fi
    fi
}

# =============================================================================
# 16. 客户端配置与订阅链接生成
# =============================================================================

# -----------------------------------------------------------------------------
# 生成 Hysteria2 订阅链接
# -----------------------------------------------------------------------------
generate_hy2_subscription_link() {
    local id=$1; local conf="$HY2_INSTALL_DIR/hy2_${id}.yaml"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    
    local password=$(grep -Po '(?<=password: ).*' "$conf" | tr -d '[:space:]')
    local port_info=$(get_listen_info_from_conf "$conf")
    local port=$(echo "$port_info" | awk -F':' '{print $NF}')
    local ip=$(get_public_ip)
    
    # [新] 动态决定 SNI 和 insecure 标记
    local cert_path=$(grep -Po '(?<=cert: ).*' "$conf" | tr -d '[:space:]')
    local sni=""
    local insecure_flag=0 # 默认安全
    
    if [[ "$cert_path" == *"$AX_CERT_DIR"* ]]; then
        # 是 ACME 证书, 从路径中提取域名
        sni=$(echo "$cert_path" | cut -d'/' -f4)
        insecure_flag=0 # 真实证书，安全
    else
        # 是自签名证书
        sni="$HY2_SNI" # 默认 bing.com
        insecure_flag=$HY2_CLIENT_INSECURE # 使用全局不安全标记 (1)
    fi
    
    # [新] 使用 sni 作为标识 (如果有)
    local host_label=$ip
    if [[ "$sni" != "$HY2_SNI" && -n "$sni" ]]; then
        host_label=$sni
    fi

    echo "hysteria2://${password}@${ip}:${port}?sni=${sni}&insecure=${insecure_flag}#hy2_${host_label}_${id}"
}

# -----------------------------------------------------------------------------
# 生成 VLESS+Reality 分享链接
# -----------------------------------------------------------------------------
generate_xray_reality_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local sni=$(jq -r '.inbounds[0].streamSettings.realitySettings.serverNames[0]' "$conf")
    local pbk=$(jq -r '.inbounds[0].streamSettings.realitySettings.publicKey' "$conf")
    local sid=$(jq -r '.inbounds[0].streamSettings.realitySettings.shortIds[0]' "$conf")
    local flow=$(jq -r '.inbounds[0].settings.clients[0].flow' "$conf")
    local fp=$(jq -r '.inbounds[0].streamSettings.realitySettings.fingerprint' "$conf")

    local link="vless://${uuid}@${ip}:${port}?type=tcp&security=reality&sni=${sni}&pbk=${pbk}&flow=${flow}&sid=${sid}&fp=${fp}#Xray_Reality_${ip}_${id}"
    echo "$link"
}

# -----------------------------------------------------------------------------
# 生成 VLESS+mKCP 分享链接
# -----------------------------------------------------------------------------
generate_xray_mkcp_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$conf")
    local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$conf")
    local congestion=$(jq -r '.inbounds[0].streamSettings.kcpSettings.congestion' "$conf")
    
    # [New] 添加 congestion 参数到 URL 参数
    local extra_params="&congestion=$congestion"
    
    echo "vless://${uuid}@${ip}:${port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}${extra_params}#vless_mkcp_${ip}_${id}"
}

# -----------------------------------------------------------------------------
# 生成 Shadowsocks 分享链接
# -----------------------------------------------------------------------------
generate_xray_ss_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port_info=$(get_listen_info_from_conf "$conf")
    local port=$(echo "$port_info" | awk -F':' '{print $NF}')
    local password=$(jq -r '.inbounds[0].settings.password' "$conf")
    local method=$(jq -r '.inbounds[0].settings.method' "$conf")
    
    # Base64 encode: method:password
    local user_info=$(echo -n "${method}:${password}" | base64 | tr -d '\n' | sed 's/=*$//') # Remove padding
    
    local link="ss://${user_info}@${ip}:${port}#SS_${ip}_${id}"
    echo "$link"
}

# -----------------------------------------------------------------------------
# 查看所有 Hysteria2 独立实例的订阅链接
# -----------------------------------------------------------------------------
view_all_hy2_subscriptions() {
    local INSTANCES=$(get_standalone_instances "hysteria2"); if [[ -z "$INSTANCES" ]]; then yellow "未找到任何 Hysteria2 独立实例。"; return; fi
    cyan "--- Hysteria2 独立实例订阅链接 ---"; for id in $INSTANCES; do green "实例 ${id}: $(generate_hy2_subscription_link $id)"; done
}

# -----------------------------------------------------------------------------
# 查看 UDP2RAW 客户端配置
# -----------------------------------------------------------------------------
view_udp2raw_client_config(){
    local id=$1; local conf="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    local ip=$(get_public_ip); local port=$(get_listen_info_from_conf "$conf" | awk -F':' '{print $NF}'); local password=$(grep -Po '(?<=-k )[^ ]+' "$conf")
    
    cyan "--- UDP2RAW 实例 ${id} 客户端配置 ---";  echo
    green "${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${port} -l ${CLIENT_UDP2RAW_LISTEN_ADDR} -k ${password}"
}

# -----------------------------------------------------------------------------
# 查看 KCPTUN 客户端配置
# -----------------------------------------------------------------------------
view_kcptun_client_config(){
    local id=$1; local conf="$KCP_INSTALL_DIR/kcptun_${id}.json"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    if ! command -v jq &>/dev/null; then red "错误: jq 未安装，无法解析配置。"; return; fi
    local ip=$(get_public_ip); local server_listen=$(jq -r '.listen' "$conf"); local server_port=$(echo "$server_listen" | awk -F':' '{print $NF}'); cyan "--- KCPTUN 实例 ${id} 客户端配置 ---"; echo
    yellow "方法一: 使用 JSON 配置文件 (推荐)"; yellow "将以下内容保存为客户端的 config.json (本地监听地址 ${CLIENT_KCPTUN_LISTEN_ADDR} 可自行修改):"; green "$(jq --arg listen "${CLIENT_KCPTUN_LISTEN_ADDR}" --arg target "${ip}:${server_port}" '.listen = $listen | .target = $target' "$conf")"; echo
    yellow "方法二: 使用命令行参数"; yellow "在客户端使用以下命令行参数 (本地监听地址 ${CLIENT_KCPTUN_LISTEN_ADDR} 可自行修改):";local args="--listen ${CLIENT_KCPTUN_LISTEN_ADDR} --target ${ip}:${server_port}"
    for key in $(jq -r 'keys_unsorted | .[]' "$conf"); do if [[ "$key" != "listen" && "$key" != "target" ]]; then local value=$(jq -r --arg k "$key" '.[$k]' "$conf"); args+=" --${key} ${value}"; fi; done; green "$args"; echo
}

# =============================================================================
# 17. 组件串联实例管理 (SS+KCP+UDP)
# =============================================================================

# [NEW] 获取 3 组件串联实例ID列表 (ss_3_chain)
# -----------------------------------------------------------------------------
# 获取 3 组件串联实例ID列表 (ss_3_chain)
# -----------------------------------------------------------------------------
get_chain_instances_3() {
    local instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances2=$(ls -1 "$KCP_INSTALL_DIR"/kcptun_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances3=$(ls -1 "$UDP2RAW_INSTALL_DIR"/udp2raw_s3c*.conf 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    echo "$instances1 $instances2 $instances3" | tr ' ' '\n' | sort -un
}

# -----------------------------------------------------------------------------
# 查看 3 组件串联实例的客户端配置
# -----------------------------------------------------------------------------
view_chain_client_config_3() {
    local id_num=$1
    local id="s3c${id_num}"
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${id}.json"
    local kcptun_conf_path="$KCP_INSTALL_DIR/kcptun_${id}.json"
    local udp2raw_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"
    
    if [[ ! -f "$ss_conf_path" || ! -f "$kcptun_conf_path" || ! -f "$udp2raw_conf_path" ]]; then
        red "串联实例 ${id} 的配置文件不完整。"; return
    fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf_path" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf_path")
    local kcptun_password=$(jq -r '.key' "$kcptun_conf_path")
    local ss_method=$(jq -r '.inbounds[0].settings.method' "$ss_conf_path")
    local ss_password=$(jq -r '.inbounds[0].settings.password' "$ss_conf_path")
    
    cyan "--- SS+KCP+UDP 实例 ${id} 客户端配置 ---"; echo
    
    yellow "步骤 1: 运行 UDP2RAW (客户端)"
    yellow " (它会监听 ${CLIENT_SS_3_CHAIN_KCP_TARGET}, 作为 KCPTUN 的目标)"
    local client_args_udp2raw="${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${udp2raw_port} -l ${CLIENT_SS_3_CHAIN_KCP_TARGET} -k ${udp2raw_password}"
    green "$client_args_udp2raw"; echo
    
    yellow "步骤 2: 运行 KCPTUN (客户端)"
    yellow " (它会监听 ${CLIENT_SS_3_CHAIN_SS_TARGET}, 作为 SS 的目标)"

    local kcp_args="--listen ${CLIENT_SS_3_CHAIN_SS_TARGET} --target ${CLIENT_SS_3_CHAIN_KCP_TARGET}"
    # 解析 JSON 并将所有其他键附加为参数
    for key in $(jq -r 'keys_unsorted | .[]' "$kcptun_conf_path"); do
        if [[ "$key" != "listen" && "$key" != "target" ]]; then
            local value=$(jq -r --arg k "$key" '.[$k]' "$kcptun_conf_path")
            kcp_args+=" --${key} ${value}"
        fi
    done
    green "$kcp_args"; echo
    
    yellow "步骤 3: SS 客户端配置 (指向本地 KCPTUN)"
    local ss_user_info=$(echo -n "${ss_method}:${ss_password}" | base64 | tr -d '\n' | sed 's/=*$//')
    local ss_host=$(echo "$CLIENT_SS_3_CHAIN_SS_TARGET" | cut -d: -f1)
    local ss_port=$(echo "$CLIENT_SS_3_CHAIN_SS_TARGET" | cut -d: -f2)
    
    # [修改点] 统一命名格式为 Chain_ss_kcp_... +UDP2RAW
    # [New] 提取 KCPTUN 参数并添加到 URL 参数
    local kcp_mode=$(jq -r '.mode' "$kcptun_conf_path")
    local kcp_crypt=$(jq -r '.crypt' "$kcptun_conf_path")
    local kcp_nocomp=$(jq -r '.nocomp' "$kcptun_conf_path")

    # SS 链接通常没有标准参数支持这些，但可以作为扩展参数添加
    local sub_link="ss://${ss_user_info}@${ss_host}:${ss_port}/?kcp_mode=${kcp_mode}&kcp_crypt=${kcp_crypt}&kcp_nocomp=${kcp_nocomp}#Chain_ss_kcp_${ip}_${id}+UDP2RAW"
    green "$sub_link"; echo
    
    echo
    yellow "[SS+KCPTUN+UDP2RAW] 合并订阅链接 (复制以下整行):"
    green "CHAIN##${sub_link} && KCPTUN://${kcp_args} && UDP2RAW://${client_args_udp2raw}"
    echo
}

# -----------------------------------------------------------------------------
# 启动一个新的 3 组件串联实例 (SS+KCP+UDP)
# -----------------------------------------------------------------------------
start_new_chain_instance_3() {
    local i=1
    while true; do if [[ ! -f "$XRAY_INSTALL_DIR/xray_s3c${i}.json" ]]; then break; fi; i=$((i + 1)); done
    
    local chain_id="s3c${i}"
    log "启动一个新的 SS+KCP+UDP 串联实例..."
    green "新串联实例将被创建为: ${chain_id} (ax-xray@${chain_id} + ax-kcptun@${chain_id} + ax-udp2raw@${chain_id})"
    
    read -p "请输入UDP2RAW对外端口 (远程客户端->UDP2RAW) (留空则随机): " udp2raw_listen_port
    if [[ -z "$udp2raw_listen_port" ]]; then 
        udp2raw_listen_port=$(find_available_port); 
        green "已随机选择对外端口 (UDP2RAW): $udp2raw_listen_port"
    else
        green "已指定对外端口 (UDP2RAW): $udp2raw_listen_port"
    fi
    
    read -p "请输入KCPTUN内联端口 (UDP2RAW->KCPTUN) (留空则随机生成): " kcptun_listen_port
    if [[ -z "$kcptun_listen_port" ]]; then kcptun_listen_port=$(find_available_port); green "已随机选择内联端口 (KCPTUN): $kcptun_listen_port"; fi
    
    read -p "请输入SS内联端口 (KCPTUN->SS) (留空则随机生成): " ss_listen_port
    if [[ -z "$ss_listen_port" ]]; then ss_listen_port=$(find_available_port); green "已随机选择内联端口 (SS): $ss_listen_port"; fi
    
    cyan "--- SS(XRAY) 配置 ---"
    echo "Shadowsocks 加密方式选项:"
    echo "1) 2022-blake3-aes-256-gcm (推荐)"
    echo "2) 2022-blake3-aes-128-gcm"
    echo "3) 2022-blake3-chacha20-poly1305"
    echo "4) aes-256-gcm"
    echo "5) aes-128-gcm"
    echo "6) chacha20-poly1305"
    read -p "请选择加密方式 (默认 1): " ss_method_choice
    ss_method_choice=${ss_method_choice:-1}
    
    local ss_method=""
    case $ss_method_choice in
        1) ss_method="2022-blake3-aes-256-gcm" ;;
        2) ss_method="2022-blake3-aes-128-gcm" ;;
        3) ss_method="2022-blake3-chacha20-poly1305" ;;
        4) ss_method="aes-256-gcm" ;;
        5) ss_method="aes-128-gcm" ;;
        6) ss_method="chacha20-poly1305" ;;
        *) ss_method="2022-blake3-aes-256-gcm" ;;
    esac
    
    cyan "--- KCPTUN 配置 ---"
    local kcp_params=$(collect_kcptun_params)
    IFS='|' read -r kcp_mode kcp_crypt kcp_tcp kcp_nocomp <<< "$kcp_params"
    
    cyan "--- UDP2RAW 配置 ---"
    local udp_params=$(collect_udp2raw_params)
    IFS='|' read -r udp_raw_mode udp_cipher_mode udp_auth_mode <<< "$udp_params"
    
    log "正在自动生成所有密码..."
    local udp2raw_password=$(generate_strong_password)
    green "已自动生成 UDP2RAW 密码: $udp2raw_password"
    
    local kcptun_password=$(generate_strong_password)
    green "已自动生成 KCPTUN 密码: $kcptun_password"

    if ! command -v openssl &>/dev/null; then 
        red "错误: openssl 未安装, 无法生成 SS 密钥！"; return 1; 
    fi
    local ss_password=$(openssl rand -base64 32)
    green "已自动生成 SS-2022 Base64 密钥: $ss_password"
    
    cyan "--- warp sockets 配置 ---"
    local warp_config_block=$(collect_warp_config "xray")
    
    local ss_config="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE"
    ss_config=${ss_config/__LISTEN_ADDR__/127.0.0.1}
    ss_config=${ss_config/__LISTEN_PORT__/$ss_listen_port}
    ss_config=${ss_config/__SS_METHOD__/$ss_method}
    ss_config=${ss_config/__SS_PASSWORD__/$ss_password}
    ss_config=${ss_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${chain_id}.json"
    
    local kcp_config="$KCPTUN_CONFIG_JSON_TEMPLATE"
    kcp_config=${kcp_config/__LISTEN__/127.0.0.1:${kcptun_listen_port}}
    kcp_config=${kcp_config/__TARGET__/127.0.0.1:${ss_listen_port}}
    kcp_config=${kcp_config/__KEY__/$kcptun_password}
    kcp_config=${kcp_config/__MODE__/$kcp_mode}
    kcp_config=${kcp_config/__CRYPT__/$kcp_crypt}
    kcp_config=${kcp_config/__TCP__/$kcp_tcp}
    kcp_config=${kcp_config/__NOCOMP__/$kcp_nocomp}
    local kcp_conf_path="$KCP_INSTALL_DIR/kcptun_${chain_id}.json"
    
    local udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    udp_config="${udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    udp_config="${udp_config//__TARGET_ADDR__/127.0.0.1:${kcptun_listen_port}}"
    udp_config="${udp_config//__PASSWORD__/${udp2raw_password}}"
    udp_config="${udp_config//__RAW_MODE__/${udp_raw_mode}}"
    udp_config="${udp_config//__CIPHER_MODE__/${udp_cipher_mode}}"
    udp_config="${udp_config//__AUTH_MODE__/${udp_auth_mode}}"
    local udp_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${chain_id}.conf"
    
    # 写入所有配置
    log "生成配置文件..."
    echo "$ss_config" > "$ss_conf_path"
    echo "$kcp_config" > "$kcp_conf_path"
    echo "$udp_config" > "$udp_conf_path"
    
    sync; log "启动串联服务...";
    systemctl enable --now "ax-xray@${chain_id}.service"
    systemctl enable --now "ax-kcptun@${chain_id}.service"
    systemctl enable --now "ax-udp2raw@${chain_id}.service"
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config_3 "$i"
}

# -----------------------------------------------------------------------------
# [NEW] 管理一个已存在的 3 组件串联实例
# -----------------------------------------------------------------------------
manage_chain_instance_3() {
    local id_num=$1
    local manage_id="s3c${id_num}"
    
    local service1_full="ax-xray@${manage_id}.service" # SS
    local service2_full="ax-kcptun@${manage_id}.service"        # KCP
    local service3_full="ax-udp2raw@${manage_id}.service"        # UDP2RAW
    
    local conf1_path="$XRAY_INSTALL_DIR/xray_${manage_id}.json"
    local conf2_path="$KCP_INSTALL_DIR/kcptun_${manage_id}.json"
    local conf3_path="$UDP2RAW_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "   管理 SS+KCP+UDP $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status s3_status <<< "$(get_3_chain_status_tuple "$manage_id")"
        local udp2raw_info=$(get_listen_info_from_conf "$conf3_path")
        
        $color "状态: SS [${s1_status}] + KCP [${s2_status}] + UDP2RAW [${s3_status}] $(dim "$udp2raw_info")"

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 SS (Xray) 日志"; echo "5) 查看 KCPTUN 日志"; echo "6) 查看 UDP2RAW 日志"; echo "7) 编辑 SS (Xray) 配置文件"; echo "8) 编辑 KCPTUN 配置文件"; echo "9) 编辑 UDP2RAW 配置文件"; echo "99) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full" "$service3_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full" "$service3_full";;
            3) view_chain_client_config_3 "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) log "正在实时跟踪 SS (Xray) 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service1_full" -f; eval "$ct";;
            5) log "正在实时跟踪 KCPTUN 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service2_full" -f; eval "$ct";;
            6) log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service3_full" -f; eval "$ct";;
            7) nano "$conf1_path"; systemctl restart "$service1_full";;
            8) nano "$conf2_path"; systemctl restart "$service2_full";;
            9) nano "$conf3_path"; systemctl restart "$service3_full";;
            99) read -p "确认删除串联实例 ${manage_id}？(默认“否”) [y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full" "$service3_full"; 
                systemctl disable "$service1_full" "$service2_full" "$service3_full" >/dev/null 2>&1; 
                rm -f "$conf1_path" "$conf2_path" "$conf3_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "7" || "$manage_choice" == "8" || "$manage_choice" == "9" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}


# =============================================================================
# 18. 组件串联实例管理 (Hysteria2 / VLESS + UDP2RAW)
# =============================================================================

# -----------------------------------------------------------------------------
# 获取 2 组件串联实例ID列表 (hy2 或 vless)
# -----------------------------------------------------------------------------
get_chain_instances() {
    local chain_type=$1
    local instances1="" instances2=""
    if [[ "$chain_type" == "hy2" ]]; then
        instances1=$(ls -1 "$HY2_INSTALL_DIR"/hy2_c*.yaml 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
        instances2=$(ls -1 "$UDP2RAW_INSTALL_DIR"/udp2raw_c*.conf 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
    else # vless
        instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_vc*.json 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
        instances2=$(ls -1 "$UDP2RAW_INSTALL_DIR"/udp2raw_vc*.conf 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
    fi
    echo "$instances1 $instances2" | tr ' ' '\n' | sort -un
}

# -----------------------------------------------------------------------------
# 查看 2 组件串联实例的客户端配置
# -----------------------------------------------------------------------------
view_chain_client_config() {
    local chain_type=$1 id_num=$2
    local id_prefix="" main_conf_path="" client_listen_addr="" title=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"; client_listen_addr="$CLIENT_UDP2RAW_LISTEN_ADDR"
    else
        id_prefix="vc"; title="VLESS_mKCP"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"; client_listen_addr="$CLIENT_VLESS_UDP2RAW_LISTEN_ADDR"
    fi
    local id="${id_prefix}${id_num}"
    local udp2raw_conf="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"
    if [[ ! -f "$main_conf_path" || ! -f "$udp2raw_conf" ]]; then red "串联实例 ${id} 的配置文件不完整。"; return; fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf")
    
    local client_args="${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${udp2raw_port} -l ${client_listen_addr} -k ${udp2raw_password}"
    local client_udp2raw_host=$(echo "$client_listen_addr" | cut -d: -f1)
    local client_udp2raw_port=$(echo "$client_listen_addr" | cut -d: -f2)
    local sub_link=""
    local display_title=""
    local host_label=$ip
    local server_addr=$ip

    if [[ "$chain_type" == "hy2" ]]; then
        display_title="[hy2+UDP2RAW]"
        local hy2_password=$(grep -Po '(?<=password: ).*' "$main_conf_path" | tr -d '[:space:]')
        
        # [新] 动态提取 SNI
        local cert_path=$(grep -Po '(?<=cert: ).*' "$main_conf_path" | tr -d '[:space:]')
        local sni=""
        local insecure_flag=0
        
        if [[ "$cert_path" == *"$AX_CERT_DIR"* ]]; then
            # 是 ACME 证书
            sni=$(echo "$cert_path" | cut -d'/' -f4)
            insecure_flag=0
        else
            # 自签名
            sni="$HY2_SNI"
            insecure_flag=$HY2_CLIENT_INSECURE
        fi
        
        # [新] 如果有真实域名，UDP2RAW 和 链接备注都使用域名
        if [[ "$sni" != "$HY2_SNI" && -n "$sni" ]]; then
            server_addr=$sni
            host_label=$sni
            # 更新 client_args 使用域名
            client_args="${UDP2RAW_CLIENT_BASE_ARGS} -r ${server_addr}:${udp2raw_port} -l ${client_listen_addr} -k ${udp2raw_password}"
        fi
        
        # [修改点] 更改了节点备注格式：Chain_hy2_... +UDP2RAW
        sub_link="hysteria2://${hy2_password}@${client_udp2raw_host}:${client_udp2raw_port}?sni=${sni}&insecure=${insecure_flag}#Chain_hy2_${host_label}_${id}+UDP2RAW"
    else # vless
        display_title="[VLESS_mKCP+UDP2RAW]"
        local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$main_conf_path")
        local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$main_conf_path")
        local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$main_conf_path")
        local congestion=$(jq -r '.inbounds[0].streamSettings.kcpSettings.congestion' "$main_conf_path")
        
        # [修改点] 更改了节点备注格式：Chain_vless_kcp_... +UDP2RAW
        sub_link="vless://${uuid}@${client_udp2raw_host}:${client_udp2raw_port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}&congestion=${congestion}#Chain_vless_kcp_${host_label}_${id}+UDP2RAW"
    fi

    cyan "--- ${title} 串联实例 ${id} 客户端配置 ---"; echo
    
    yellow "1. ${title} 客户端 (指向本地):"
    green "$sub_link"; echo
    
    yellow "2. UDP2RAW 客户端 (连接公网):"
    green "$client_args"; echo
    
    yellow "$display_title 合并订阅链接 (复制以下整行):"
    green "CHAIN##${sub_link} && UDP2RAW://${client_args}"
    echo
}

# -----------------------------------------------------------------------------
# 启动一个新的 2 组件串联实例 (hy2 或 vless)
# -----------------------------------------------------------------------------
start_new_chain_instance() {
    local chain_type=$1
    local i=1 id_prefix="" title="" main_conf_dir="" main_conf_template=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2+UDP"; main_conf_dir="$HY2_INSTALL_DIR"; main_conf_template="$HYSTERIA2_CONFIG_YAML_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/hy2_c${i}.yaml" ]]; then break; fi; i=$((i + 1)); done
    else # vless
        id_prefix="vc"; title="VLESS_mKCP+UDP"; main_conf_dir="$XRAY_INSTALL_DIR"; main_conf_template="$XRAY_VLESS_MKCP_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/xray_vc${i}.json" ]]; then break; fi; i=$((i + 1)); done
    fi
    
    local chain_id="${id_prefix}${i}"
    log "启动一个新的 ${title} 串联实例..."
    if [[ "$chain_type" == "hy2" ]]; then
        green "新串联实例将被创建为: ${chain_id} (ax-hysteria2@${chain_id} + ax-udp2raw@${chain_id})"
    else
        green "新串联实例将被创建为: ${chain_id} (ax-xray@${chain_id} + ax-udp2raw@${chain_id})"
    fi
    
    # 先进行参数配置
    read -p "请输入对外端口 (留空则随机生成): " udp2raw_listen_port
    if [[ -z "$udp2raw_listen_port" ]]; then udp2raw_listen_port=$(find_available_port); green "已随机选择对外端口: $udp2raw_listen_port"; fi

    read -p "请输入内联端口 (留空则随机生成): " internal_listen_port
    if [[ -z "$internal_listen_port" ]]; then internal_listen_port=$(find_available_port); green "已随机选择内联端口: $internal_listen_port"; fi
    
    # 添加Hysteria2串联实例的配置选项
    if [[ "$chain_type" == "hy2" ]]; then
        cyan "--- Hysteria2 配置 ---"
        read -p "ignoreClientBandwidth [true/false] (默认 true): " ignore_client_bandwidth
        ignore_client_bandwidth=${ignore_client_bandwidth:-true}
        if [[ "$ignore_client_bandwidth" != "false" ]]; then
            ignore_client_bandwidth="true"
        fi
    else # vless
        # 添加VLESS mKCP串联实例的配置选项
        cyan "--- VLESS mKCP 配置 ---"
        read -p "congestion [true/false] (默认 true): " mkcp_congestion
        mkcp_congestion=${mkcp_congestion:-true}
        if [[ "$mkcp_congestion" != "false" ]]; then
            mkcp_congestion="true"
        fi
    fi
    
    
    local main_config="$main_conf_template"
    local main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        local hy2_password=$(generate_strong_password); echo -n "已自动生成 Hysteria2 密码: "; green "$hy2_password"
        
        cyan "--- ACME证书 配置 ---"
        read -p "是否使用 ACME证书? (否则将使用自签名证书) [Y/n] (默认“Y”): " use_acme
        use_acme=${use_acme:-y} # 回车默认为 y
        
        local cert_path="" key_path="" masquerade_url=""
        
        if [[ "$use_acme" == "y" || "$use_acme" == "Y" ]]; then
            read -p "请输入您的域名 (DNS 必须指向本机): " domain_name
            if [[ -z "$domain_name" ]]; then
                red "域名不能为空！已取消创建。"
                return 1
            fi

            # 尝试申请证书，如果失败直接退出
            if ! ax_get_certificate "$domain_name"; then
                red "ACME 证书申请流程失败，已取消创建实例。"
                return 1
            fi
            
            if [ -f "$AX_CERT_DIR/$domain_name/fullchain.cer" ]; then
                green "ACME 验证成功. Hysteria2 将使用 $domain_name"
                cert_path="$AX_CERT_DIR/$domain_name/fullchain.cer"
                key_path="$AX_CERT_DIR/$domain_name/private.key"
                masquerade_url="https://$domain_name"
            else
                red "错误：未找到申请的证书文件，已取消创建实例。"
                return 1
            fi
        else
            # 用户明确选择“否”
            generate_self_signed_cert
            cert_path="$HY2_CERT_PATH"
            key_path="$HY2_KEY_PATH"
            masquerade_url="$HY2_MASQUERADE_URL"
        fi
        # ------------------------------------
        
        main_config="${main_config//__LISTEN__/127.0.0.1:${internal_listen_port}}"
        main_config="${main_config//__CERT_PATH__/${cert_path}}"
        main_config="${main_config//__KEY_PATH__/${key_path}}"
        main_config="${main_config//__PASSWORD__/${hy2_password}}"
        main_config="${main_config//__MASQUERADE_URL__/${masquerade_url}}"
        main_config="${main_config/__UDP_SNIFF_CONFIG__/udpPorts: all}"
        main_conf_path="$main_conf_dir/hy2_${chain_id}.yaml"
        
        main_config="${main_config/__IGNORE_CLIENT_BANDWIDTH__/$ignore_client_bandwidth}"
       
    else # vless
        local uuid=$(generate_strong_password); echo -n "已自动生成 VLESS UUID: "; green "$uuid"
        local mkcp_seed=$(generate_strong_password); echo -n "已自动生成 mKCP Seed: "; green "$mkcp_seed"
        main_config=${main_config/__LISTEN_ADDR__/127.0.0.1}
        main_config=${main_config/__LISTEN_PORT__/$internal_listen_port}
        main_config=${main_config/__UUID__/$uuid}
        main_config=${main_config/__MKCP_SEED__/$mkcp_seed}
        
        if [[ "$mkcp_congestion" == "true" ]]; then
            main_config=$(echo "$main_config" | sed 's/"seed": "__MKCP_SEED__"/"seed": "__MKCP_SEED__", "congestion": true/')
        fi
        
        main_conf_path="$main_conf_dir/xray_${chain_id}.json"
    fi

    # 添加UDP2RAW串联实例的配置选项
    cyan "--- UDP2RAW 配置 ---"
    read -p "raw_mode [faketcp/udp/icmp] (默认 faketcp): " raw_mode
    raw_mode=${raw_mode:-faketcp}
    
    read -p "cipher_mode [aes128cbc/xor] (默认 aes128cbc): " cipher_mode
    cipher_mode=${cipher_mode:-aes128cbc}
    
    read -p "auth_mode [hmac_sha1/simple] (默认 hmac_sha1): " auth_mode
    auth_mode=${auth_mode:-hmac_sha1}
    
    # 然后生成密码
    local udp2raw_password=$(generate_strong_password); echo -n "已自动生成 UDP2RAW 密码: "; green "$udp2raw_password"
    
    local service_type="hysteria2"
    if [[ "$chain_type" != "hy2" ]]; then
        service_type="xray"
    fi

    cyan "--- warp sockets 配置 ---"
    local warp_config_block=$(collect_warp_config "$service_type")
    
    if [[ "$chain_type" == "hy2" ]]; then
        main_config=${main_config/__OUTBOUNDS_AND_ACL__/$warp_config_block}
    else # vless
        main_config=${main_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
    fi
    
    echo "$main_config" > "$main_conf_path"
    
    log "生成 UDP2RAW 配置文件: udp2raw_${chain_id}.conf..."; local temp_udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    temp_udp_config="${temp_udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    temp_udp_config="${temp_udp_config//__TARGET_ADDR__/127.0.0.1:${internal_listen_port}}"
    temp_udp_config="${temp_udp_config//__PASSWORD__/${udp2raw_password}}"
    temp_udp_config="${temp_udp_config//__RAW_MODE__/${raw_mode}}"
    temp_udp_config="${temp_udp_config//__CIPHER_MODE__/${cipher_mode}}"
    temp_udp_config="${temp_udp_config//__AUTH_MODE__/${auth_mode}}"
    
    local udp2raw_conf="$UDP2RAW_INSTALL_DIR/udp2raw_${chain_id}.conf"
    echo "$temp_udp_config" > "$udp2raw_conf"
    
    sync; log "启动串联服务...";
    if [[ "$chain_type" == "hy2" ]]; then
        systemctl enable --now "ax-hysteria2@${chain_id}.service"
    else # vless
        systemctl enable --now "ax-xray@${chain_id}.service"
    fi
    systemctl enable --now "ax-udp2raw@${chain_id}.service"
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config "$chain_type" "$i"
}

# -----------------------------------------------------------------------------
# 管理一个已存在的 2 组件串联实例
# -----------------------------------------------------------------------------
manage_chain_instance() {
    local chain_type=$1 id_num=$2
    local id_prefix="" title="" service1_name="" service2_name="" main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; service1_name="ax-hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"
    else # vless
        id_prefix="vc"; title="VLESS_mKCP"; service1_name="ax-xray"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"
    fi
    
    local manage_id="${id_prefix}${id_num}"
    service2_name="udp2raw"
    local service1_full="${service1_name}@${manage_id}.service"
    local service2_full="ax-udp2raw@${manage_id}.service"
    local udp2raw_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "      管理${title}串联实例 $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status <<< "$(get_chain_status_tuple "$chain_type" "$manage_id")"
        local udp2raw_info=$(get_listen_info_from_conf "$udp2raw_conf_path")
        
        if [[ "$chain_type" == "hy2" ]]; then
            $color "状态: Hysteria2 [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        else
            $color "状态: VLESS_mKCP [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        fi

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 ${title} 日志"; echo "5) 查看 UDP2RAW 日志"; echo "6) 编辑 ${title} 配置文件"; echo "7) 编辑 UDP2RAW 配置文件"; echo "99) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full";;
            3) view_chain_client_config "$chain_type" "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 ${title} 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service1_full" -f
                eval "$current_trap"
                ;;
            5) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service2_full" -f
                eval "$current_trap"
                ;;
            6) nano "$main_conf_path"; systemctl restart "$service1_full";;
            7) nano "$udp2raw_conf_path"; systemctl restart "$service2_full";;
            99) read -p "确认删除串联实例 ${manage_id}？(默认“否”) [y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full"; 
                systemctl disable "$service1_full" "$service2_full" >/dev/null 2>&1; 
                rm -f "$main_conf_path" "$udp2raw_conf_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "6" || "$manage_choice" == "7" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}

# -----------------------------------------------------------------------------
# [Bugfix] 3 组件串联实例的通用管理菜单
# -----------------------------------------------------------------------------
chain_manager_menu_3() {
    local title="SS+KCP+UDP 一键串联"
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; return' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances_3)
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "ss_3_chain_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的串联实例。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的串联实例"; echo "2) 管理一个已存在的串联实例"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance_3; read -p $'\n按任意键返回...' -n1 -s;;
            2) 
                if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi
                read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num
                # 简单的存在性检查
                if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then 
                    manage_chain_instance_3 "$manage_id_num"
                else 
                    red "无效的实例ID！"; sleep 2
                fi
                ;;
            3) 
                if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi
                local i; for i in $INSTANCES; do view_chain_client_config_3 "$i"; done
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# -----------------------------------------------------------------------------
# 2 组件串联实例的通用管理菜单
# -----------------------------------------------------------------------------
chain_manager_menu() {
    local chain_type=$1
    local title=""
    if [[ "$chain_type" == "hy2" ]]; then
        title="Hysteria2+UDP一键串联"
    else # vless
        title="VLESS_mKCP+UDP一键串联"
    fi
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; return' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances "$chain_type")
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "${chain_type}_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的串联实例。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的串联实例"; echo "2) 管理一个已存在的串联实例"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance "$chain_type"; read -p $'\n按任意键返回...' -n1 -s;;
            2) if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi; read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num; if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then manage_chain_instance "$chain_type" "$manage_id_num"; else red "无效的实例ID！"; sleep 2; fi;;
            3) if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi; local i; for i in $INSTANCES; do view_chain_client_config "$chain_type" $i; done; read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# -----------------------------------------------------------------------------
# 独立实例总管理菜单 (循环)
# -----------------------------------------------------------------------------
main_manager_loop() {
    local type=$1; local title dir pattern service_prefix type_lowercase
    case $type in 
        hysteria2) title="Hysteria2 (独立)"; dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml"; service_prefix="ax-hysteria2"; type_lowercase="hysteria2";;
        udp2raw) title="UDP2RAW (独立)"; dir="$UDP2RAW_INSTALL_DIR"; pattern="udp2raw_*.conf"; service_prefix="udp2raw"; type_lowercase="udp2raw";;
        kcptun) title="KCPTUN (独立)"; dir="$KCP_INSTALL_DIR"; pattern="kcptun_*.json"; service_prefix="kcptun"; type_lowercase="kcptun";;
        xray_reality) title="VLESS+Reality (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_reality";;
        xray_mkcp) title="VLESS+mKCP (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_mkcp";;
        xray_ss) title="Shadowsocks (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_ss";;
    esac
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; return' SIGINT
        clear; echo "=================================="; echo "     安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#INSTANCES[@]} -gt 0 ]]; then
            echo "$(bold "--- 已存在的实例 ---")"; for i in "${INSTANCES[@]}"; do display_instance_status_line "$type_lowercase" "$i" "  "; done
        else
            yellow "当前没有已创建的 $title 实例。"
        fi

        echo "----------------------------------"; local menu_options=("1) 启动一个新的实例" "2) 管理一个已存在的实例")
        if [[ "$type" == "hysteria2" ]]; then menu_options+=("3) 查看hy2订阅地址");
        elif [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then menu_options+=("3) 查看分享链接");
        elif [[ "$type" == "udp2raw" || "$type" == "kcptun" ]]; then menu_options+=("3) 查看客户端配置"); fi
        menu_options+=("0) 返回主菜单"); for opt in "${menu_options[@]}"; do echo "$opt"; done
        read -p "请选择: " choice
        case $choice in
            1)
                if [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then create_new_xray_instance "$type_lowercase"; else create_new_instance "$type_lowercase"; fi
                read -p $'\n按任意键返回...' -n1 -s;;
            2)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi
                local manage_id; read -p "请输入您想管理的实例ID [$(echo "${INSTANCES[@]}")]: " manage_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$manage_id" ]]; then is_valid=true; break; fi; done
                if [[ "$is_valid" == true ]]; then
                    local conf_path
                    case $type in
                        hysteria2) conf_path="$dir/hy2_${manage_id}.yaml";;
                        udp2raw) conf_path="$dir/udp2raw_${manage_id}.conf";;
                        kcptun) conf_path="$dir/kcptun_${manage_id}.json";;
                        xray_reality|xray_mkcp|xray_ss) conf_path="$dir/xray_${manage_id}.json";;
                    esac
                    manage_instance_menu "$type_lowercase" "$manage_id" "${service_prefix}@${manage_id}" "$conf_path"
                else red "无效的实例ID！"; sleep 2; fi;;
            3)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi
                if [[ "$type" == "hysteria2" ]]; then view_all_hy2_subscriptions
                else
                    local view_id; read -p "请输入您想查看的实例ID [$(echo "${INSTANCES[@]}")]: " view_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$view_id" ]]; then is_valid=true; break; fi; done
                    if [[ "$is_valid" == true ]]; then
                        case "$type" in
                            udp2raw) view_udp2raw_client_config "$view_id" ;;
                            kcptun) view_kcptun_client_config "$view_id" ;;
                            xray_reality) cyan "$(generate_xray_reality_link "$view_id")" ;;
                            xray_mkcp) cyan "$(generate_xray_mkcp_link "$view_id")" ;;
                            xray_ss) cyan "$(generate_xray_ss_link "$view_id")" ;;
                        esac
                    else red "无效的实例ID！"; fi
                fi
                read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# =============================================================================
# 19. 全局操作 (查看全部/重启/更新/卸载)
# =============================================================================

# -----------------------------------------------------------------------------
# [新] 显示全局 TLS 证书状态
# -----------------------------------------------------------------------------
show_global_tls_status() {
    echo "--- TLS 证书状态 ---"
    
    # 检查 ACME 证书目录
    if [ ! -d "$AX_CERT_DIR" ] || [ -z "$(ls -A $AX_CERT_DIR)" ]; then
        yellow "未找到 ACME 证书。"
    else
        # 遍历 $AX_CERT_DIR 下的每个域名目录
        for domain_dir in "$AX_CERT_DIR"/*; do
            if [ -d "$domain_dir" ]; then
                local domain=$(basename "$domain_dir")
                local cert_file="$domain_dir/fullchain.cer"
                local key_file="$domain_dir/private.key"
                
                if [ -f "$cert_file" ] && [ -f "$key_file" ]; then
                    local expiry_date_str
                    local days_remaining="N/A"
                    
                    # 尝试获取到期天数
                    if command -v openssl &>/dev/null; then
                        expiry_date_str=$(openssl x509 -in "$cert_file" -noout -enddate 2>/dev/null | cut -d= -f2)
                        if [ -n "$expiry_date_str" ]; then
                            local expiry_epoch=$(date -d "$expiry_date_str" +%s 2>/dev/null)
                            local now_epoch=$(date +%s)
                            if [ -n "$expiry_epoch" ]; then
                                days_remaining=$(((expiry_epoch - now_epoch) / 86400))
                                days_remaining="(剩余 ${days_remaining} 天)"
                            fi
                        fi
                    fi
                    
                    cyan "[域名] $domain $days_remaining"
                    echo "  公钥 (Cert): $cert_file"
                    echo "  私钥 (Key):  $key_file"
                fi
            fi
        done
    fi
}

# -----------------------------------------------------------------------------
# 查看全部实例的客户端配置
# -----------------------------------------------------------------------------
view_all_configs() {
    clear; echo "=================================="; echo "        查看全部实例配置"; echo "=================================="; echo
    
    local ss_3_chain_instances=$(get_chain_instances_3); if [[ -n "$ss_3_chain_instances" ]]; then for i in $ss_3_chain_instances; do view_chain_client_config_3 "$i"; echo "----------------------------------"; done; fi
    local hy2_chain_instances=$(get_chain_instances "hy2"); if [[ -n "$hy2_chain_instances" ]]; then for i in $hy2_chain_instances; do view_chain_client_config "hy2" "$i"; echo "----------------------------------"; done; fi
    local vless_chain_instances=$(get_chain_instances "vless"); if [[ -n "$vless_chain_instances" ]]; then for i in $vless_chain_instances; do echo; view_chain_client_config "vless" "$i"; echo "----------------------------------"; done; fi
    
    local standalone_hy2=($(get_standalone_instances "hysteria2")); if [[ ${#standalone_hy2[@]} -gt 0 ]]; then echo; cyan "--- Hysteria2 (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_hy2[@]}"; do green "$(generate_hy2_subscription_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_reality=($(get_standalone_instances "xray_reality")); if [[ ${#standalone_reality[@]} -gt 0 ]]; then echo; cyan "--- VLESS+Reality (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_reality[@]}"; do green "$(generate_xray_reality_link $id)"; done; echo "----------------------------------"; fi
    local standalone_mkcp=($(get_standalone_instances "xray_mkcp")); if [[ ${#standalone_mkcp[@]} -gt 0 ]]; then echo; cyan "--- VLESS+mKCP (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_mkcp[@]}"; do green "$(generate_xray_mkcp_link $id)"; done; echo "----------------------------------"; fi
    local standalone_ss=($(get_standalone_instances "xray_ss")); if [[ ${#standalone_ss[@]} -gt 0 ]]; then echo; cyan "--- Shadowsocks (独立) 实例订阅链接 ---"; echo
    for id in "${standalone_ss[@]}"; do green "$(generate_xray_ss_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_udp2raw=($(get_standalone_instances "udp2raw")); if [[ ${#standalone_udp2raw[@]} -gt 0 ]]; then echo; for id in "${standalone_udp2raw[@]}"; do view_udp2raw_client_config "$id"; echo; done; echo "----------------------------------"; fi
    local standalone_kcptun=($(get_standalone_instances "kcptun")); if [[ ${#standalone_kcptun[@]} -gt 0 ]]; then echo; for id in "${standalone_kcptun[@]}"; do view_kcptun_client_config "$id"; echo; done; fi

    if ! is_installed; then yellow "系统中没有任何已配置的实例。"; fi
}

# -----------------------------------------------------------------------------
# 重启所有服务
# -----------------------------------------------------------------------------
restart_all_services(){ log "正在重启所有正在运行的实例..."; systemctl restart ax-kcptun@*.service ax-udp2raw@*.service ax-xray@*.service ax-hysteria2@*.service 2>/dev/null; green "操作完成！"; sleep 2; }

# -----------------------------------------------------------------------------
# 检查并更新所有核心程序
# -----------------------------------------------------------------------------
check_for_updates(){
    log "检查更新..."
    
    # 记录更新前的版本
    local kcp_before=$(cat "$KCP_INSTALL_DIR/version.txt" 2>/dev/null)
    local udp_before=$(cat "$UDP2RAW_INSTALL_DIR/version.txt" 2>/dev/null)
    local hy2_before=$(cat "$HY2_INSTALL_DIR/version.txt" 2>/dev/null)
    local xray_before=$(cat "$XRAY_INSTALL_DIR/version.txt" 2>/dev/null)
    
    # 执行更新检查与下载
    download_kcp_udp_binaries
    download_hysteria2_binary
    download_xray_binary
    
    # 检查是否有任何更新
    local kcp_after=$(cat "$KCP_INSTALL_DIR/version.txt" 2>/dev/null)
    local udp_after=$(cat "$UDP2RAW_INSTALL_DIR/version.txt" 2>/dev/null)
    local hy2_after=$(cat "$HY2_INSTALL_DIR/version.txt" 2>/dev/null)
    local xray_after=$(cat "$XRAY_INSTALL_DIR/version.txt" 2>/dev/null)
    
    local has_updates=false
    if [[ "$kcp_before" != "$kcp_after" ]] || [[ "$udp_before" != "$udp_after" ]] || \
       [[ "$hy2_before" != "$hy2_after" ]] || [[ "$xray_before" != "$xray_after" ]]; then
        has_updates=true
    fi
    
    # 只有在有更新时才执行后续操作
    if [[ "$has_updates" == true ]]; then
        log "所有程序已更新到最新版本，重启所有服务以应用..."
        restart_all_services
        sleep 2
    else
        echo ""
        green "所有程序均已是最新版本，无需更新。"
        echo ""
    fi
}

# -----------------------------------------------------------------------------
# [NEW] 安装 VPS 一键优化脚本
# -----------------------------------------------------------------------------
install_sys_opt() {
    echo "----------------------------------------------------------------"
    log "即将开始下载并运行 VPS 一键优化脚本 (vps_optimizert.sh) ..."
    
    # 运行用户提供的命令
    wget --no-check-certificate -O vps_optimizert.sh "https://raw.githubusercontent.com/halibotee/scripts/main/vps_optimizert.sh" && chmod +x vps_optimizert.sh && ./vps_optimizert.sh
    
    # 检查脚本是否成功下载（作为执行后的一个简单反馈）
    if [ ! -f "vps_optimizert.sh" ]; then
         echo "----------------------------------------------------------------"
         red "错误：下载 vps_optimizert.sh 失败或脚本未正确执行。"
         log "即将返回主菜单..."
         return 1 # 返回错误状态
    fi

    echo "----------------------------------------------------------------"
    green "VPS 一键优化脚本 (vps_optimizert.sh) 执行完毕。"
    log "即将返回主菜单..."
}

# -----------------------------------------------------------------------------
# [NEW] 安装 warp-socket5 脚本
# -----------------------------------------------------------------------------
install_warp_yg() {
    echo "----------------------------------------------------------------"
    log "即将开始下载并运行 warp-socket5.sh 脚本..."
    
    # 运行用户提供的命令
    wget --no-check-certificate -O warp-socket5.sh "https://raw.githubusercontent.com/halibotee/scripts/main/warp-socket5.sh" && chmod +x warp-socket5.sh && ./warp-socket5.sh
    
    if [ ! -f "warp-socket5.sh" ]; then
         echo "----------------------------------------------------------------"
         red "错误：下载 warp-socket5.sh 失败或脚本未正确执行。"
         log "即将返回主菜单..."
         return 1 # 返回错误状态
    fi
    
    echo "----------------------------------------------------------------"
    green "warp-socket5.sh 脚本 执行完毕。"
    log "即将返回主菜单..."
}

# -----------------------------------------------------------------------------
# 卸载所有 (REFACTORED: 修复软卸载路径)
# -----------------------------------------------------------------------------
uninstall_all() {
    read -p "确认要卸载吗？(默认“否”) [y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then 
        yellow "操作已取消。"
        return 1
    fi
    
    read -p "是否要执行彻底清理（删除所有配置文件和证书）？(默认“否”) [y/N]: " nuke_choice
    log "开始卸载流程..."
    log "步骤 1: 停止并禁用所有相关服务..."
    systemctl stop "ax-kcptun@*.service" "ax-udp2raw@*.service" "ax-xray@*.service" "ax-hysteria2@*.service" "hysteria-server@*.service" 2>/dev/null
    systemctl disable "ax-kcptun@*.service" "ax-udp2raw@*.service" "ax-xray@*.service" "ax-hysteria2@*.service" "hysteria-server@*.service" 2>/dev/null
    green "服务已停止并禁用。"
    log "步骤 2: 删除所有 systemd 服务文件..."
    rm -f "$KCPTUN_TEMPLATE_FILE" \
          "$UDP2RAW_TEMPLATE_FILE" \
          "$HY2_TEMPLATE_FILE" \
          "$XRAY_TEMPLATE_FILE" \
          /etc/systemd/system/hysteria-server@.service
    green "Systemd 服务文件已删除。"
    if [[ "$nuke_choice" == "y" || "$nuke_choice" == "Y" ]]; then
        log "步骤 3: 执行彻底清理..."
        rm -rf "$KCP_INSTALL_DIR" "$UDP2RAW_INSTALL_DIR" "$HY2_INSTALL_DIR" "$XRAY_INSTALL_DIR" "$AX_CERT_DIR"
        green "程序和配置文件目录已删除。"
        
        log "步骤 4: 删除生成的证书..."
        rm -f /etc/ssl/private/bing.com.crt /etc/ssl/private/bing.com.key
        green "自签名证书已删除。"
        
        # 清理 ACME.sh 证书客户端
        if [ -d "/root/.acme.sh" ]; then
            log "步骤 5: 清理 ACME.sh 证书客户端..."
            
            # 先尝试使用 acme.sh 的官方卸载命令 (会自动清理 cron 任务)
            if [ -f "/root/.acme.sh/acme.sh" ]; then
                yellow "正在卸载 ACME.sh 客户端并清理 cron 任务..."
                /root/.acme.sh/acme.sh --uninstall > /dev/null 2>&1 || true
            fi
            
            # 删除整个 acme.sh 目录 (包含所有证书和配置)
            rm -rf /root/.acme.sh
            green "ACME.sh 客户端、证书和 cron 任务已删除。"
        else
            yellow "未检测到 ACME.sh 客户端，跳过清理。"
        fi
        
        # 清理 WARP-Socks5
        if command -v warp-cli &> /dev/null || [ -f /etc/apt/sources.list.d/cloudflare-client.list ]; then
            log "步骤 5.1: 清理 WARP-Socks5 客户端..."
            
            # 断开并删除 WARP 配置
            if command -v warp-cli &> /dev/null; then
                yellow "正在断开 WARP 连接并删除配置..."
                warp-cli --accept-tos disconnect > /dev/null 2>&1 || true
                warp-cli --accept-tos disable-always-on > /dev/null 2>&1 || true
                warp-cli --accept-tos delete > /dev/null 2>&1 || true
            fi
            
            # 卸载 cloudflare-warp 包
            if command -v yum &> /dev/null; then
                yellow "正在卸载 cloudflare-warp (CentOS)..."
                yum autoremove cloudflare-warp -y > /dev/null 2>&1 || true
            elif command -v apt &> /dev/null; then
                yellow "正在卸载 cloudflare-warp (Debian/Ubuntu)..."
                apt purge cloudflare-warp -y > /dev/null 2>&1 || true
                rm -f /etc/apt/sources.list.d/cloudflare-client.list
                rm -f /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg
            fi
            
            green "WARP-Socks5 客户端已删除。"
        else
            yellow "未检测到 WARP-Socks5 客户端，跳过清理。"
        fi
    else
        log "步骤 3: 执行软卸载 (仅删除二进制文件和 dat 文件)..."
        rm -f "$KCP_INSTALL_DIR/kcptun_server" "$UDP2RAW_INSTALL_DIR/udp2raw"
        rm -f "$HY2_INSTALL_DIR/hysteria" "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat"
        rm -f "$XRAY_INSTALL_DIR/xray" "$XRAY_INSTALL_DIR/geoip.dat" "$XRAY_INSTALL_DIR/geosite.dat"
        green "程序文件已删除。"
    fi
    log "步骤 6: 清理残留的二进制文件..."
    rm -f /usr/local/bin/hysteria
    green "残留二进制文件已清理。"
    log "步骤 7: 清理临时文件..."
    rm -f /tmp/kcptun.tar.gz /tmp/udp2raw.tar.gz /tmp/xray.zip
    log "步骤 8: 重载 systemd 并清理状态..."
    systemctl daemon-reload; systemctl reset-failed
    green "Systemd 已重载并清理。"
    
    echo; green "==== 卸载完成！ ===="
    yellow "提示：依赖包 (如 curl, openssl, jq) 未被卸载。"
    yellow "提示：请手动删除此脚本文件。"
    
    # 检查是否还有 acme.sh 残留
    if [[ "$nuke_choice" != "y" && "$nuke_choice" != "Y" ]] && [ -d "/root/.acme.sh" ]; then
        yellow "提示：检测到 ACME.sh 证书客户端仍存在，您可运行以下命令手动卸载："
        cyan "      /root/.acme.sh/acme.sh --uninstall && rm -rf /root/.acme.sh"
    fi
    
    # 检查是否还有 WARP 残留
    if [[ "$nuke_choice" != "y" && "$nuke_choice" != "Y" ]] && command -v warp-cli &> /dev/null; then
        yellow "提示：检测到 WARP-Socks5 客户端仍存在，您可通过以下方式卸载："
        cyan "      方法1: 运行主菜单 14) 安装warp-Socks5 -> 选择 3) 卸载"
        cyan "      方法2: 运行 ./warp-socket5.sh 并选择卸载选项"
    fi
    
    sleep 3
    return 0
}

# =============================================================================
# 20. 脚本入口与初始化
# =============================================================================

# -----------------------------------------------------------------------------
# 系统兼容性检查函数
# -----------------------------------------------------------------------------
check_system_compatibility() {
    # 检查是否为root用户
    if [[ $EUID -ne 0 ]]; then
        red "错误: 此脚本必须以root用户身份运行"
        exit 1
    fi
    
    # 检查系统是否使用systemd
    if ! command -v systemctl &> /dev/null; then
        red "错误: 此脚本需要systemd支持，但您的系统似乎没有安装systemd"
        exit 1
    fi
    
    # 检查必要的命令是否可用
    local required_commands=("curl" "wget" "jq" "openssl")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        yellow "警告: 以下必要命令在系统中不可用:"
        for cmd in "${missing_commands[@]}"; do
            echo "  - $cmd"
        done
        yellow "将尝试在初始化过程中安装这些依赖"
    fi
}

# -----------------------------------------------------------------------------
# 首次运行检查和安装核心程序
# -----------------------------------------------------------------------------
initial_check_and_install() {
    # 添加系统兼容性检查
    check_system_compatibility
    
    # 使用统一的安装函数
    install_dependencies_and_programs || { red "安装失败，退出脚本。"; exit 1; }
    
    # 确保模板文件就绪
    ensure_template_files
    sleep 1
}

# -----------------------------------------------------------------------------
# 主菜单状态总览 (使用粗体标题)
# -----------------------------------------------------------------------------
show_status_summary() {
    local menu_index=21; echo "--- 当前状态 (输入序号可直接管理) ---"; if ! is_installed; then yellow "未安装任何组件。"; return; fi
    
    local ss_3_chain_instances=$(get_chain_instances_3)
    if [[ -n "$ss_3_chain_instances" ]]; then
        echo "$(bold "SS+KCP+UDP 串联实例:")"
        for i in $ss_3_chain_instances; do display_instance_status_line "ss_3_chain_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="ss_3_chain_chain"; menu_index=$((menu_index + 1)); done
    fi
    local hy2_chain_instances=$(get_chain_instances "hy2")
    if [[ -n "$hy2_chain_instances" ]]; then
        echo "$(bold "Hysteria2+UDP 串联实例:")"
        for i in $hy2_chain_instances; do display_instance_status_line "hy2_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="hy2_chain"; menu_index=$((menu_index + 1)); done
    fi
    local vless_chain_instances=$(get_chain_instances "vless")
    if [[ -n "$vless_chain_instances" ]]; then
        echo "$(bold "VLESS_mKCP+UDP 串联实例:")"
        for i in $vless_chain_instances; do display_instance_status_line "vless_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="vless_chain"; menu_index=$((menu_index + 1)); done
    fi

    for type in "Hysteria2" "VLESS+Reality" "VLESS+mKCP" "Shadowsocks" "UDP2RAW" "KCPTUN"; do
        local type_lowercase=""
        case "$type" in
            "Hysteria2") type_lowercase="hysteria2";;
            "VLESS+Reality") type_lowercase="xray_reality";;
            "VLESS+mKCP") type_lowercase="xray_mkcp";;
            "Shadowsocks") type_lowercase="xray_ss";;
            "UDP2RAW") type_lowercase="udp2raw";;
            "KCPTUN") type_lowercase="kcptun";;
        esac
        
        local standalone_instances=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#standalone_instances[@]} -gt 0 ]]; then
            echo "$(bold "${type} (独立) 实例:")"
            for i in "${standalone_instances[@]}"; do
                display_instance_status_line "$type_lowercase" "$i" "$menu_index) "
                QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="$type_lowercase"; menu_index=$((menu_index + 1))
            done
        fi
    done
}

# -----------------------------------------------------------------------------
# 主菜单 
# -----------------------------------------------------------------------------
main_menu(){
    declare -A QUICK_MANAGE_MAP_ID; declare -A QUICK_MANAGE_MAP_TYPE
    while true; do
        QUICK_MANAGE_MAP_ID=(); QUICK_MANAGE_MAP_TYPE=()
        trap '' SIGINT
        clear; echo "=================================="; echo "  多合一隧道管理脚本 V$SCRIPT_VERSION"; echo "=================================="
        cyan "--- 串联管理 ---"
        echo " 1) Hysteria2+UDP2RAW 串联"
        echo " 2) VLESS_mKCP+UDP2RAW 串联"
        echo " 3) Shadowsocks+KCP+UDP 串联"
        cyan "--- 独立实例管理 ---"
        echo " 4) Hysteria2"
        echo " 5) VLESS+Reality"
        echo " 6) VLESS+mKCP"
        echo " 7) Shadowsocks"
        cyan "--- 加速管理 ---"
        echo " 8) UDP2RAW"
        echo " 9) KCPTUN"
        echo "----------------------------------"
        cyan "--- 全局操作 ---"
        echo " 10) 查看全部配置"
        echo " 11) 重启全部服务"
        echo " 12) 检查更新程序" 
        cyan "--- 工具管理 ---"
        echo " 13) 优化VPS系统"
        echo " 14) 安装warp-Socks5"
        echo "----------------------------------"   
        echo " 99) 卸载"
        echo "----------------------------------"   
        echo " 0) 退出"
        
        # --- [新] 全局 TLS 状态 (位于 0 和 "当前状态" 之间) ---
        echo "----------------------------------"
        show_global_tls_status
        # --- ACME 状态结束 ---
        
        echo "----------------------------------"
        show_status_summary
        local num_items=${#QUICK_MANAGE_MAP_ID[@]}; local max_index=$((20 + num_items))
        echo "----------------------------------"
        # [MODIFIED] 更改提示符范围
        local prompt="请选择 [0-14, 99"; if [[ $num_items -gt 0 ]]; then prompt+=", 21-${max_index}]"; else prompt+="]"; fi
        read -p "$prompt： " choice
        
        if [[ -n "${QUICK_MANAGE_MAP_ID[$choice]}" ]]; then
            local real_id="${QUICK_MANAGE_MAP_ID[$choice]}"; local type="${QUICK_MANAGE_MAP_TYPE[$choice]}"
            case "$type" in
                "ss_3_chain_chain") manage_chain_instance_3 "$real_id" ;;
                "hy2_chain") manage_chain_instance "hy2" "$real_id" ;;
                "vless_chain") manage_chain_instance "vless" "$real_id" ;;
                "hysteria2") manage_instance_menu "hysteria2" "$real_id" "ax-hysteria2@${real_id}" "$HY2_INSTALL_DIR/hy2_${real_id}.yaml" ;;
                "xray_reality") manage_instance_menu "xray_reality" "$real_id" "ax-xray@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "xray_mkcp") manage_instance_menu "xray_mkcp" "$real_id" "ax-xray@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "xray_ss") manage_instance_menu "xray_ss" "$real_id" "ax-xray@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "udp2raw") manage_instance_menu "udp2raw" "$real_id" "ax-udp2raw@${real_id}" "$UDP2RAW_INSTALL_DIR/udp2raw_${real_id}.conf" ;;
                "kcptun") manage_instance_menu "kcptun" "$real_id" "ax-kcptun@${real_id}" "$KCP_INSTALL_DIR/kcptun_${real_id}.json" ;;
            esac
            continue
        fi
        
        case $choice in
            1) chain_manager_menu "hy2" ;;
            2) chain_manager_menu "vless" ;;
            3) chain_manager_menu_3 ;;
            4) main_manager_loop "hysteria2" ;; 
            5) main_manager_loop "xray_reality" ;;
            6) main_manager_loop "xray_mkcp" ;; 
            7) main_manager_loop "xray_ss" ;;
            8) main_manager_loop "udp2raw" ;;
            9) main_manager_loop "kcptun" ;;
            10) view_all_configs; read -p $'\n按任意键返回...' -n1 -s;;
            11) restart_all_services ;;
            12) check_for_updates; read -p "按任意键继续..." -n1 -s ;;
            13) clear; install_sys_opt; read -p $'\n按任意键返回...' -n1 -s ;;
            14) clear; install_warp_yg; read -p $'\n按任意键返回...' -n1 -s ;;
            99) uninstall_all; if [[ $? -eq 0 ]]; then exit 0; fi ;;
            0) trap - SIGINT; exit 0 ;; 
            *) red "无效选择!"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# 21. 脚本执行入口
# =============================================================================
echo -e "\033[1;36m[INFO] 脚本启动... 当前版本: v${SCRIPT_VERSION}\033[0m"
sleep 2

# 捕获 Ctrl+C 信号，以便在脚本主体执行期间优雅退出
trap 'echo -e "\n\n${yellow}操作被中断，退出脚本。${reset}"; trap - SIGINT; exit 1' SIGINT
# 初始化检查和安装
initial_check_and_install
# 显示主菜单
main_menu
