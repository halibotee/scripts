#!/bin/bash
# Xray（Vless、SS）、Hysteria2, UDP2RAW 、 KCPTUN 实例管理脚本
# Generated by github.com/halibotee

# --- 1. 核心全局变量与脚本版本 ---
SCRIPT_VERSION="1.0.0" # 脚本版本号
KCPTUN_INSTALL_DIR="/etc/kcptun"          # KCPTUN 安装目录
UDP2RAW_INSTALL_DIR="/etc/udp2raw"        # UDP2RAW 安装目录
HY2_INSTALL_DIR="/etc/hysteria2"          # Hysteria2 安装目录
XRAY_INSTALL_DIR="/etc/xray"              # Xray 安装目录

# [新] ACME 相关配置
ACME_SH_INSTALL_DIR="/root/.acme.sh/acme.sh"
AX_CERT_DIR="/etc/ax-certs"

# --- 2. Systemd 模板文件路径 ---
KCPTUN_TEMPLATE_FILE="/etc/systemd/system/ax-kcptun@.service"
UDP2RAW_TEMPLATE_FILE="/etc/systemd/system/ax-udp2raw@.service"
HY2_TEMPLATE_FILE="/etc/systemd/system/ax-hysteria2@.service"
XRAY_TEMPLATE_FILE="/etc/systemd/system/ax-xray@.service"

# --- 3. 网络与服务默认配置 ---
PUBLIC_IP=""                     # 存储获取到的公网 IP，留空自动获取
DEFAULT_LISTEN_ADDR="0.0.0.0"    # 默认的全局监听地址
DEFAULT_TARGET_ADDR="127.0.0.1"  # KCP/UDP 默认的目标(回环)地址
RANDOM_PORT_MIN=10000            # 随机端口的最小值
RANDOM_PORT_MAX=65535            # 随机端口的最大值
PUBLIC_IP_SERVICE_1="ip.sb"      # 获取公网 IP 的首选服务
PUBLIC_IP_SERVICE_2="ipinfo.io/ip" # 获取公网 IP 的备选服务

# --- 4. Hysteria2 (HY2) 专属配置 ---
HY2_SNI="bing.com" # Hysteria2 自签名模式默认 SNI
HY2_CERT_PATH="/etc/ssl/private/${HY2_SNI}.crt" # 默认自签名证书路径
HY2_KEY_PATH="/etc/ssl/private/${HY2_SNI}.key"  # 默认自签名密钥路径
HY2_MASQUERADE_URL="https://www.bing.com"   # 默认伪装流量的目标 URL
HY2_CLIENT_INSECURE="1" # Hysteria2 客户端是否跳过证书验证 (1为是)

# --- 5. Xray VLESS 专属配置 ---
XRAY_REALITY_DEFAULT_SNI="www.apple.com" # VLESS+Reality 默认 SNI
XRAY_REALITY_DEFAULT_FP="chrome"       # VLESS+Reality 默认指纹
XRAY_REALITY_DEFAULT_TARGET="www.apple.com:443" # VLESS+Reality 默认回落目标
XRAY_REALITY_DEFAULT_FLOW="xtls-rprx-vision" # VLESS+Reality 默认 flow
KCPTUN_DEFAULT_MODE="fast3"      # KCPTUN 默认的加速模式
SS_DEFAULT_METHOD="2022-blake3-aes-256-gcm" # Shadowsocks 默认加密方式

# --- 6. WARP 分流配置 ---
DEFAULT_WARP_SOCKS_ADDR="127.0.0.1" # WARP SOCKS5 服务的默认监听地址
DEFAULT_WARP_SOCKS_PORT="40000"   # WARP SOCKS5 服务的默认端口
WARP_GEOSITE_LIST_JSON='"geosite:google","geosite:openai","geosite:perplexity"'
WARP_GEOSITE_LIST_YAML='- warp(suffix:ip-api.com)
    - warp(geosite:google)
    - warp(geoip:google)
    - warp(suffix:google.com)
    - warp(geosite:openai)
    - warp(suffix:openai.com)
    - warp(suffix:chatgpt.com)
    - warp(geosite:perplexity)
    - warp(suffix:perplexity.com)'

# --- 7. Github 软件源配置 ---
KCPTUN_REPO="xtaci/kcptun"
UDP2RAW_REPO="wangyu-/udp2raw"
HY2_REPO="apernet/hysteria"
XRAY_REPO="XTLS/Xray-core"
GITHUB_API_URL="https://api.github.com/repos"
GITHUB_URL="https://github.com"

# --- 8. 客户端默认参数配置 ---
CLIENT_KCPTUN_LISTEN_ADDR="127.0.0.1:1091"
CLIENT_UDP2RAW_LISTEN_ADDR="127.0.0.1:1093"
CLIENT_VLESS_UDP2RAW_LISTEN_ADDR="127.0.0.1:1094"
# [NEW] 3-Chain SS+KCP+UDP 客户端本地端口
CLIENT_SS_3_CHAIN_KCP_TARGET="127.0.0.1:1095" # KCP 目标 (UDP2RAW 监听)
CLIENT_SS_3_CHAIN_SS_TARGET="127.0.0.1:1096"  # SS 目标 (KCP 监听)

UDP2RAW_COMMON_ARGS="--raw-mode faketcp --cipher-mode aes128cbc --auth-mode hmac_sha1 --seq-mode 4 -a --keep-rule --fix-gro"
UDP2RAW_CLIENT_BASE_ARGS="-c ${UDP2RAW_COMMON_ARGS}"

# --- 9. 配置文件模板 (JSON / YAML / CONF) ---

# KCPTUN_CONFIG 模板
read -r -d '' KCPTUN_CONFIG_JSON_TEMPLATE <<'EOM'
{
    "listen": "__LISTEN__", "target": "__TARGET__", "key": "__KEY__", "crypt": "aes-128", "mode": "__MODE__", "smuxver": 2, "mtu": 1350, "sndwnd": 256, "rcvwnd": 2048, "datashard": 10, "parityshard": 3, "dscp": 46, "nocomp": true, "acknodelay": false, "nodelay": 1, "interval": 20, "resend": 2, "nc": 1, "sockbuf": 16777217, "smuxbuf": 16777217, "streambuf": 4194304, "keepalive": 5, "autoexpire": 600, "quiet": false, "tcp": false
}
EOM

# UDP2RAW Config 模板 
read -r -d '' UDP2RAW_CONFIG_TEMPLATE <<'EOM'
-s
-l __LISTEN_ADDR__
-r __TARGET_ADDR__
-k __PASSWORD__
--raw-mode faketcp
--cipher-mode aes128cbc
--auth-mode hmac_sha1
--seq-mode 4
-a
--keep-rule
--fix-gro
EOM

# HYSTERIA2 CONFIG 模板
read -r -d '' HYSTERIA2_CONFIG_YAML_TEMPLATE <<'EOM'
listen: __LISTEN__
tls:
  cert: __CERT_PATH__
  key: __KEY_PATH__
auth:
  type: password
  password: __PASSWORD__
masquerade:
  type: proxy
  proxy:
    url: https://www.macbed.com
    rewriteHost: true
    insecure: false
ignoreClientBandwidth: true
sniff:
  enable: true
  timeout: 2s
  rewriteDomain: true
  tcpPorts: 80,443,8000-9000
  __UDP_SNIFF_CONFIG__
__OUTBOUNDS_AND_ACL__
EOM

# Hysteria2 WARP 分流模板 
read -r -d '' HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK <<'EOM'
outbounds:
  - name: warp
    type: socks5
    socks5:
      addr: __WARP_SOCKS5_ADDR__
      udp: false
acl:
  inline:
    __WARP_GEOSITE_LIST_YAML__
    - direct(all)
EOM
HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_GEOSITE_LIST_YAML__/$WARP_GEOSITE_LIST_YAML}"

# Hysteria2 直连模板
read -r -d '' HYSTERIA2_DIRECT_ACL_BLOCK <<'EOM'
acl:
  inline:
    - direct(all)
EOM

# Xray VLESS+Reality 模板
read -r -d '' XRAY_VLESS_REALITY_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [
        {
            "listen": null,
            "port": __LISTEN_PORT__,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "__UUID__",
                        "flow": "__REALITY_FLOW__"
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "fingerprint": "__FINGERPRINT__",
                    "target": "__TARGET__",
                    "xver": 0,
                    "serverNames": [
                        "__SNI__"
                    ],
                    "privateKey": "__PRIVATE_KEY__",
                    "publicKey": "__PUBLIC_KEY__",
                    "minClientVer": "",
                    "maxClientVer": "",
                    "maxTimeDiff": 60000,
                    "shortIds": [
                        "__SHORT_ID__"
                    ]
                },
                "tcpSettings": {
                    "header": {
                        "type": "none"
                    }
                }
            },
            "tag": "inbound-__LISTEN_PORT__",
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls",
                    "quic"
                ]
            }
        }
    ],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# Xray VLESS+mKCP 模板
read -r -d '' XRAY_VLESS_MKCP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "vless",
        "settings": {
            "clients": [{ "id": "__UUID__" }],
            "decryption": "none"
        },
        "streamSettings": {
            "network": "kcp",
            "kcpSettings": {
                "mtu": 1200, "tti": 30, "uplinkCapacity": 25, "downlinkCapacity": 100, "congestion": true, "readBufferSize": 4, "writeBufferSize": 4,
                "header": { "type": "wechat-video" },
                "seed": "__MKCP_SEED__"
            }
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# [NEW] Xray Shadowsocks (TCP/UDP) 模板 (用于 KCPTUN / UDP2RAW 串联)
read -r -d '' XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "shadowsocks",
        "settings": {
            "method": "__SS_METHOD__",
            "password": "__SS_PASSWORD__",
            "network": "tcp,udp"
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# Xray WARP 分流模板
read -r -d '' XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "socks", "tag": "warp", "settings": { "servers": [{ "address": "__WARP_SOCKS5_ADDR__", "port": __WARP_SOCKS5_PORT__ }] } },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
        { "type": "field", "outboundTag": "warp", "domain": [ __WARP_GEOSITE_LIST_JSON__ ] },
        { "type": "field", "outboundTag": "warp", "domain": [ "suffix:ip-api.com" ] },
        { "type": "field", "outboundTag": "block", "domain": [ "geosite:category-ads-all" ] }
    ]
}
EOM
XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK="${XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK//__WARP_GEOSITE_LIST_JSON__/$WARP_GEOSITE_LIST_JSON}"

# Xray 直连模板
read -r -d '' XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": { "rules": [ { "type": "field", "outboundTag": "direct", "network": "tcp,udp" } ] }
EOM


# --- 10. 辅助工具函数 (颜色、日志、检查等) ---

# 绿色
green(){ echo -e "\033[0;32m$1\033[0m"; }
# 红色
red(){ echo -e "\033[0;31m$1\033[0m"; }
# 黄色 (橙色)
yellow(){ echo -e "\033[0;33m$1\033[0m"; }
# 青色
cyan(){ echo -e "\033[0;36m$1\033[0m"; }
# 粗体 (默认色)
bold(){ echo -e "\033[1m$1\033[0m"; }
# 淡化 (灰色)
dim(){ echo -e "\033[2m$1\033[0m"; }
# 日志格式
log(){ echo -e "[$(date '+%H:%M:%S')] $(bold "$1")"; }
# 检查是否已安装任何实例
is_installed(){ ls "$KCPTUN_INSTALL_DIR"/*.json >/dev/null 2>&1 || ls "$UDP2RAW_INSTALL_DIR"/*.conf >/dev/null 2>&1 || ls "$HY2_INSTALL_DIR"/*.yaml >/dev/null 2>&1 || ls "$XRAY_INSTALL_DIR"/*.json >/dev/null 2>&1; }

# 获取公网 IP 地址
get_public_ip() {
    if [[ -n "$PUBLIC_IP" ]]; then echo "$PUBLIC_IP"; return; fi
    PUBLIC_IP=$(curl -s4m2 $PUBLIC_IP_SERVICE_1 || curl -s4m2 $PUBLIC_IP_SERVICE_2)
    if [[ -z "$PUBLIC_IP" ]]; then PUBLIC_IP="127.0.0.1"; yellow "获取公网 IP 失败，将使用 127.0.0.1 作为备用。" >&2; fi
    echo "$PUBLIC_IP"
}

# 安装脚本所需的核心依赖
install_dependencies(){
    local packages_to_install=()
    ! command -v curl &>/dev/null && packages_to_install+=("curl")
    ! command -v wget &>/dev/null && packages_to_install+=("wget")
    ! command -v tar &>/dev/null && packages_to_install+=("tar")
    ! command -v unzip &>/dev/null && packages_to_install+=("unzip")
    ! command -v nano &>/dev/null && packages_to_install+=("nano")
    ! command -v iptables &>/dev/null && packages_to_install+=("iptables")
    ! command -v uuidgen &>/dev/null && packages_to_install+=("uuid-runtime")
    ! command -v openssl &>/dev/null && packages_to_install+=("openssl")
    ! command -v jq &>/dev/null && packages_to_install+=("jq")
    ! command -v socat &>/dev/null && packages_to_install+=("socat") # [新] ACME 80 端口模式依赖

    # [新] ACME DNS 模式依赖
    if ! command -v dig &>/dev/null; then
        if command -v apt-get &>/dev/null; then
            packages_to_install+=("dnsutils")
        elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then
            packages_to_install+=("bind-utils")
        fi
    fi

    if [ ${#packages_to_install[@]} -gt 0 ]; then
        log "更新软件包列表并安装核心依赖: ${packages_to_install[*]}..."
        (apt-get update && apt-get install -y "${packages_to_install[@]}") >/dev/null 2>&1 || \
        (yum install -y epel-release && yum install -y "${packages_to_install[@]}") >/dev/null 2>&1 || \
        (dnf install -y "${packages_to_install[@]}") >/dev/null 2>&1
    fi
}

# 带重试功能的下载函数
download_with_retry(){
    local url=$1 output=$2 retries=3 timeout=15
    for ((i=1; i<=retries; i++)); do
        log "下载 ($i/$retries)：$url"
        curl -L --connect-timeout 5 --max-time $timeout -o "$output" "$url" && return 0
        yellow "下载失败，正在重试..."
    done
    red "下载失败超过 $retries 次，请检查网络。"
    return 1
}

# 查找一个未被占用的随机端口
find_available_port() {
    local port
    while true; do
        port=$(( RANDOM % (RANDOM_PORT_MAX - RANDOM_PORT_MIN + 1) + RANDOM_PORT_MIN ))
        ! ss -tuln | grep -q ":${port} " && echo "$port" && return
    done
}

# 生成强密码 (UUID)
generate_strong_password() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    else
        log "uuidgen 未找到，生成备用 UUID..." >&2
        hexdump -n 16 -v -e '4/4 "%08x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 6/6 "%012x"' /dev/urandom | head -c 36
    fi
}

# 生成 Hysteria2 所需的自签名证书
generate_self_signed_cert() {
    if [[ -s "$HY2_CERT_PATH" && -s "$HY2_KEY_PATH" ]]; then return; fi
    log "正在为 ${HY2_SNI} 生成自签名证书..."
    mkdir -p "$(dirname "$HY2_KEY_PATH")"
    openssl ecparam -name prime256v1 -genkey -noout -out "$HY2_KEY_PATH"
    chmod 600 "$HY2_KEY_PATH"
    if [[ $? -ne 0 ]]; then red "错误: openssl ecparam 命令执行失败。"; exit 1; fi
    openssl req -new -x509 -days 36500 -key "$HY2_KEY_PATH" -out "$HY2_CERT_PATH" -subj "/CN=${HY2_SNI}" -nodes
    if [[ $? -ne 0 ]]; then red "错误: openssl req 命令执行失败。"; exit 1; fi
    if [[ ! -s "$HY2_CERT_PATH" || ! -s "$HY2_KEY_PATH" ]]; then red "错误: 证书文件生成失败或为空！"; exit 1; fi
    green "证书生成完毕。"
}

# 处理密码输入，支持自动生成和保存上次输入
handle_password_input() {
    local service_type=$1; local pass_file; local last_pass=""
    case "$service_type" in
        kcptun) mkdir -p "$KCPTUN_INSTALL_DIR"; pass_file="$KCPTUN_INSTALL_DIR/last_kcptun_pass.txt" ;;
        udp2raw) mkdir -p "$UDP2RAW_INSTALL_DIR"; pass_file="$UDP2RAW_INSTALL_DIR/last_udp2raw_pass.txt" ;;
        hysteria2) mkdir -p "$HY2_INSTALL_DIR"; pass_file="$HY2_INSTALL_DIR/last_hy2_pass.txt" ;;
        xray_mkcp) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_xray_mkcp_seed.txt" ;;
        shadowsocks) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_ss_pass.txt" ;;
    esac
    if [[ -f "$pass_file" ]]; then last_pass=$(cat "$pass_file"); fi
    local display_pass=${last_pass:-"无"}
    local prompt_text="请输入密码"

    # [新] 为 SS-2022 提供特定提示
    if [[ "$service_type" == "shadowsocks" ]]; then
         yellow "注意: SS-2022 (如 $SS_DEFAULT_METHOD) 必须使用 Base64 密钥。" >&2
         prompt_text="请输入 Base64 密钥"
    elif [[ "$service_type" == "xray_mkcp" ]]; then
         prompt_text="请输入 mKCP Seed"
    fi

    read -p "${prompt_text} (原有: ${display_pass}, 回车自动生成): " password

    if [[ -z "$password" ]]; then
        # [新] 修正 SS-2022 自动生成逻辑
        if [[ "$service_type" == "shadowsocks" ]]; then
            # SS-2022 requires specific key length
            local key_length=32 # 默认 32 字节 (用于 256-gcm)
            if [[ "$SS_DEFAULT_METHOD" == *"128-gcm"* ]]; then
                key_length=16 # 16 字节 (用于 128-gcm)
            fi
            
            if ! command -v openssl &>/dev/null; then
                red "错误: openssl 命令未找到，无法生成 SS-2022 密钥！" >&2
                return 1
            fi
            password=$(openssl rand -base64 $key_length)
            green "已为您自动生成 SS-2022 Base64 密钥: $password" >&2
        else
            # [原] 其他服务的逻辑
            password=$(generate_strong_password)
            green "已为您自动生成随机密码: $password" >&2
        fi
    else
        # [新] 警告手动输入的 SS-2022 密码
        if [[ "$service_type" == "shadowsocks" ]]; then
            yellow "警告: 已使用您输入的 '$password'。" >&2
            yellow "如果 Xray 启动失败，请检查这是否是有效的 Base64 密钥。" >&2
        fi
    fi

    echo "$password" > "$pass_file"
    chmod 600 "$pass_file" # [新] 增加文件权限保护
    echo "$password"
}

# 查找下一个可用的实例 ID (数字)
find_next_available_id() {
    local type=$1; local dir file_prefix file_ext; local i=1
    case "$type" in
        hysteria2) dir="$HY2_INSTALL_DIR"; file_prefix="hy2"; file_ext="yaml";;
        udp2raw) dir="$UDP2RAW_INSTALL_DIR"; file_prefix="udp2raw"; file_ext="conf";;
        kcptun) dir="$KCPTUN_INSTALL_DIR"; file_prefix="kcptun"; file_ext="json";;
        xray) dir="$XRAY_INSTALL_DIR"; file_prefix="xray"; file_ext="json";;
    esac
    while true; do
        if [[ ! -f "$dir/${file_prefix}_${i}.${file_ext}" && ! -f "$dir/${file_prefix}_c${i}.${file_ext}" && ! -f "$dir/${file_prefix}_vc${i}.${file_ext}" && ! -f "$dir/${file_prefix}_s3c${i}.${file_ext}" ]]; then
            echo "$i"; return
        fi
        i=$((i + 1))
    done
}

# --- [新] ACME 证书管理函数 ---

# 安装 acme.sh 客户端
install_acme_sh_client() {
    if [ -f "$ACME_SH_INSTALL_DIR" ]; then
        return 0 # 已安装
    fi
    log "正在安装 acme.sh 证书客户端..."
    
    local Aemail
    read -p "请输入注册 ACME 所需的邮箱 (回车自动生成): " Aemail
    if [ -z "$Aemail" ]; then
        local auto_email=$(date +%s%N | md5sum | cut -c 1-8)
        Aemail="$auto_email@gmail.com"
        yellow "已为您自动生成邮箱: $Aemail"
    fi

    # 使用 get.acme.sh 官方安装
    curl https://get.acme.sh | sh -s email=$Aemail
    if [ ! -f "$ACME_SH_INSTALL_DIR" ]; then
        red "acme.sh 客户端安装失败！"
        return 1
    fi
    
    "$ACME_SH_INSTALL_DIR" --upgrade --auto-upgrade
    "$ACME_SH_INSTALL_DIR" --set-default-ca --server letsencrypt
    green "acme.sh 客户端安装完成。"
}

# 检查 80 端口并释放 (改编自 acme-yg 的 acme2)
release_80_port() {
    log "正在检查 80 端口占用..."
    local pid=$(lsof -t -i:80)
    if [ -n "$pid" ]; then
        yellow "警告: 80 端口被进程 $pid 占用。"
        read -p "是否尝试强行释放 80 端口? (默认“是”) [Y/n]: " kill_confirm
        kill_confirm=${kill_confirm:-y} # Default to yes if empty
        if [[ "$kill_confirm" == "y" || "$kill_confirm" == "Y" ]]; then
            log "正在强行释放 80 端口..."
            kill -9 $pid
            sleep 2
            if lsof -t -i:80 >/dev/null; then
                red "80 端口释放失败！"
                return 1
            else
                green "80 端口已释放。"
            fi
        else
            red "80 端口被占用，ACME Standalone 模式无法继续。"
            return 1
        fi
    fi
    return 0
}

# 核心函数：获取或续订证书 (改编自 acme-yg 的 checkip, ACMEDNS 等)
ax_get_certificate() {
    local domain=$1
    local cert_dir="$AX_CERT_DIR/$domain"
    
    # 1. 检查证书是否已存在且有效
    if [ -f "$cert_dir/fullchain.cer" ]; then
        log "证书 $domain 已存在于 $cert_dir"
        return 0
    fi
    
    # 2. 确保 acme.sh 客户端已安装
    install_acme_sh_client || return 1
    
    # 3. 检查 DNS (checkip 逻辑)
    log "正在验证 $domain 的 DNS 解析..."
    local v4=$(curl -s4m2 $PUBLIC_IP_SERVICE_1 || curl -s4m2 $PUBLIC_IP_SERVICE_2)
    local v6=$(curl -s6m2 $PUBLIC_IP_SERVICE_1 || curl -s6m2 $PUBLIC_IP_SERVICE_2)
    local domainIP=$(dig @8.8.8.8 +time=2 +short "$domain" 2>/dev/null | grep -m1 '^[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+$')
    
    if [[ -z "$domainIP" && -n "$v6" ]]; then
        domainIP=$(dig @2001:4860:4860::8888 +time=2 aaaa +short "$domain" 2>/dev/null | grep -m1 ':')
    fi
    
    if [[ -z "$domainIP" ]]; then
        red "错误: 无法解析 $domain 的 IP 地址。"
        return 1
    fi
    
    if [[ "$domainIP" != "$v4" && "$domainIP" != "$v6" ]]; then
        red "错误: $domain 解析的 IP ($domainIP) 与本机 IP ($v4 / $v6) 不匹配！"
        yellow "请确保 DNS 记录已正确设置，且 CDN (小黄云) 已关闭。"
        return 1
    fi
    green "DNS 验证通过: $domain -> $domainIP"

    # 4. 选择 ACME 模式
    read -p "选择 ACME 验证模式: [1] 80 端口 (Standalone) [2] DNS API (推荐): " acme_mode
    local issue_cmd=""

    if [ "$acme_mode" == "1" ]; then
        # 80 端口模式
        release_80_port || return 1
        local listen_opt=""
        if [[ "$domainIP" == "$v6" ]]; then
            listen_opt="--listen-v6"
        fi
        issue_cmd="$ACME_SH_INSTALL_DIR --issue -d $domain --standalone -k ec-256 $listen_opt"
    
    elif [ "$acme_mode" == "2" ]; then
        # DNS API 模式
        read -p "选择 DNS 服务商: [1] Cloudflare [2] DNSPod [3] Aliyun: " dns_provider
        local dns_api_cmd=""
        yellow "警告: API 密钥将保存在 acme.sh 配置中 (~/.acme.sh/account.conf)"
        
        case $dns_provider in
            1) # Cloudflare
                read -s -p "请输入 Cloudflare Global API Key: " GAK; echo
                export CF_Key="$GAK"
                read -p "请输入 Cloudflare 注册邮箱: " CFemail
                export CF_Email="$CFemail"
                dns_api_cmd="--dns dns_cf"
                ;;
            2) # DNSPod
                read -s -p "请输入 DNSPod DP_Id: " DPID; echo
                export DP_Id="$DPID"
                read -s -p "请输入 DNSPod DP_Key: " DPKEY; echo
                export DP_Key="$DPKEY"
                dns_api_cmd="--dns dns_dp"
                ;;
            3) # Aliyun
                read -s -p "请输入 Aliyun Ali_Key: " ALKEY; echo
                export Ali_Key="$ALKEY"
                read -s -p "请输入 Aliyun Ali_Secret: " ALSER; echo
                export Ali_Secret="$ALSER"
                dns_api_cmd="--dns dns_ali"
                ;;
            *)
                red "无效的服务商选择。"
                return 1
                ;;
        esac
        issue_cmd="$ACME_SH_INSTALL_DIR --issue -d $domain $dns_api_cmd -k ec-256"
    
    else
        red "无效的模式选择。"
        return 1
    fi

    # 5. 执行申请
    log "正在执行 ACME 证书申请，请稍候..."
    eval $issue_cmd
    if [ $? -ne 0 ]; then
        red "ACME 证书申请失败！"
        return 1
    fi
    
    # 6. 安装证书到 ax 目录
    log "正在安装证书到 $cert_dir ..."
    mkdir -p "$cert_dir"
    "$ACME_SH_INSTALL_DIR" --install-cert -d "$domain" --ecc \
        --fullchain-file "$cert_dir/fullchain.cer" \
        --key-file "$cert_dir/private.key"
        
    if [ -f "$cert_dir/fullchain.cer" ]; then
        green "证书 $domain 已成功安装到 $cert_dir"
        # 确保 cron 任务已设置
        "$ACME_SH_INSTALL_DIR" --cron -f >/dev/null 2>&1
        return 0
    else
        red "证书安装失败！"
        return 1
    fi
}


# --- 11. 核心程序下载函数 ---

get_latest_github_tag() {
    local repo_name=$1
    # 使用 jq -r .tag_name 来安全、准确地获取标签名
    curl -s "$GITHUB_API_URL/$repo_name/releases/latest" | jq -r .tag_name
}

# 下载 KCPTUN 和 UDP2RAW (REFACTORED: 安装到根目录)
download_kcp_udp_binaries(){
    KCPTUN_LATEST=$(get_latest_github_tag "$KCPTUN_REPO")
    UDP2RAW_LATEST=$(get_latest_github_tag "$UDP2RAW_REPO")
    if [[ -z "$KCPTUN_LATEST" || -z "$UDP2RAW_LATEST" ]]; then red "获取 KCPTUN/UDP2RAW 版本号失败。"; return 1; fi
    mkdir -p "$KCP_UDP_INSTALL_DIR"
    log "下载 KCPTUN ($KCPTUN_LATEST)..."
    download_with_retry "$GITHUB_URL/$KCPTUN_REPO/releases/download/${KCPTUN_LATEST}/kcptun-linux-amd64-$(echo $KCPTUN_LATEST | sed 's/v//').tar.gz" /tmp/kcptun.tar.gz && \
    tar -xzf /tmp/kcptun.tar.gz -C "$KCP_UDP_INSTALL_DIR" server_linux_amd64 && mv "$KCP_UDP_INSTALL_DIR/server_linux_amd64" "$KCPTUN_INSTALL_DIR/kcptun_server" || { red "KCPTUN 解压或移动失败。"; return 1; }
    log "下载 UDP2RAW ($UDP2RAW_LATEST)..."
    download_with_retry "$GITHUB_URL/$UDP2RAW_REPO/releases/download/${UDP2RAW_LATEST}/udp2raw_binaries.tar.gz" /tmp/udp2raw.tar.gz && \
    tar -xzf /tmp/udp2raw.tar.gz -C "$KCP_UDP_INSTALL_DIR" udp2raw_amd64 && mv "$UDP2RAW_INSTALL_DIR/udp2raw_amd64" "$UDP2RAW_INSTALL_DIR/udp2raw" || { red "UDP2RAW 解压或移动失败。"; return 1; }
    chmod +x "$KCPTUN_INSTALL_DIR/kcptun_server" "$UDP2RAW_INSTALL_DIR/udp2raw"
}

# 下载 Hysteria2 (REFACTORED: 安装到根目录)
download_hysteria2_binary(){
    HY2_LATEST=$(get_latest_github_tag "$HY2_REPO")
    if [[ -z "$HY2_LATEST" ]]; then red "获取 Hysteria2 版本号失败。"; return 1; fi
    mkdir -p "$HY2_INSTALL_DIR"
    log "下载 Hysteria2 ($HY2_LATEST)..."
    local hy2_url="$GITHUB_URL/$HY2_REPO/releases/download/${HY2_LATEST}/hysteria-linux-amd64"
    download_with_retry "$hy2_url" "$HY2_INSTALL_DIR/hysteria" || { red "Hysteria2 下载失败。"; return 1; }
    chmod +x "$HY2_INSTALL_DIR/hysteria"
}

# 下载 Xray-core (REFACTORED: 安装到根目录, 增加 dat 文件权限)
download_xray_binary(){
    XRAY_LATEST=$(get_latest_github_tag "$XRAY_REPO")
    if [[ -z "$XRAY_LATEST" ]]; then red "获取 Xray-core 版本号失败。"; return 1; fi
    mkdir -p "$XRAY_INSTALL_DIR"
    log "下载 Xray-core ($XRAY_LATEST)..."
    local xray_url="$GITHUB_URL/$XRAY_REPO/releases/download/${XRAY_LATEST}/Xray-linux-64.zip"
    download_with_retry "$xray_url" /tmp/xray.zip || { red "Xray-core 下载失败。"; return 1; }
    unzip -o /tmp/xray.zip -d "$XRAY_INSTALL_DIR" xray geoip.dat geosite.dat || { red "Xray-core 解压失败。"; return 1; }
    chmod +x "$XRAY_INSTALL_DIR/xray"
    
    # [REFACTORED] 复制 geo dat 文件到 Hysteria2 根目录
    log "正在复制 geoip.dat / geosite.dat 到 Hysteria2 目录..."
    cp -n "$XRAY_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    cp -n "$XRAY_INSTALL_DIR/geosite.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    chmod 644 "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat" 2>/dev/null
}

# --- 12. Systemd 与服务状态管理 ---

# 确保所有 Systemd 模板文件都存在
ensure_template_files() {
    local changed=0
    if [[ ! -f "$KCPTUN_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$KCPTUN_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=KCPTUN Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$KCPTUN_INSTALL_DIR/kcptun_server -c $KCPTUN_INSTALL_DIR/kcptun_%i.json
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$UDP2RAW_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$UDP2RAW_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=UDP2RAW Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$UDP2RAW_INSTALL_DIR/udp2raw --conf-file $UDP2RAW_INSTALL_DIR/udp2raw_%i.conf
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$HY2_TEMPLATE_FILE" ]]; then
        changed=1
        generate_self_signed_cert
        cat > "$HY2_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Hysteria2 Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$HY2_INSTALL_DIR/hysteria -c $HY2_INSTALL_DIR/hy2_%i.yaml server
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$XRAY_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$XRAY_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Xray Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$XRAY_INSTALL_DIR/xray -c $XRAY_INSTALL_DIR/xray_%i.json
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ $changed -eq 1 ]]; then systemctl daemon-reload; fi
}

# 从配置文件中提取监听地址和端口
get_listen_info_from_conf() {
    local conf_path=$1
    if [[ ! -f "$conf_path" ]]; then echo "配置文件不存在"; return; fi

    if [[ "$conf_path" == *".json" ]]; then
        if grep -q '"smuxver"' "$conf_path" 2>/dev/null; then
            grep -Po '(?<="listen": ")[^"]+' "$conf_path"
        else
            local listen=$(jq -r '.inbounds[0].listen // "0.0.0.0"' "$conf_path" 2>/dev/null)
            local port=$(jq -r '.inbounds[0].port // 0' "$conf_path" 2>/dev/null)
            if [[ "$listen" == "null" || "$port" == "0" ]]; then echo "JSON解析错误"; else echo "${listen}:${port}"; fi
        fi
    elif [[ "$conf_path" == *".conf" ]]; then
        grep -Po '(?<=-l )[^ ]+' "$conf_path"
    elif [[ "$conf_path" == *".yaml" ]]; then
        local raw_listen=$(grep -Po '(?<=listen: ).*' "$conf_path" | tr -d '[:space:]')
        if [[ "$raw_listen" == :* ]]; then echo "0.0.0.0$raw_listen"; else echo "$raw_listen"; fi
    fi
}

# 从配置文件中检查 WARP 是否启用
get_warp_status_from_conf() {
    local conf_path=$1
    if [[ "$conf_path" == *".yaml" ]]; then
        if grep -q "name: warp" "$conf_path" 2>/dev/null; then echo "已启用WARP"; else echo "未启用WARP"; fi
    elif [[ "$conf_path" == *".json" ]]; then
        if jq -e '.outbounds[] | select(.tag == "warp")' "$conf_path" >/dev/null 2>&1; then echo "已启用WARP"; else echo "未启用WARP"; fi
    else
        echo ""
    fi
}

# 获取单个服务的运行状态字符串 (绿色或黄色)
get_service_status_string() {
    local service_name=$1
    if systemctl is-active --quiet "$service_name"; then echo "运行中"; else echo "未运行"; fi
}

# 获取串联实例的组合状态 (颜色, 状态1, 状态2)
get_chain_status_tuple() {
    local chain_type=$1 chain_id=$2
    local service1_name="" service2_name=""
    if [[ "$chain_type" == "hy2" ]]; then
        service1_name="hysteria2@${chain_id}.service"
        service2_name="udp2raw@${chain_id}.service"
    else # vless
        service1_name="ax-xray@${chain_id}.service"
        service2_name="udp2raw@${chain_id}.service"
    fi
    
    local s1_active=false s2_active=false status_color="yellow"
    if systemctl is-active --quiet "$service1_name"; then s1_active=true; fi
    if systemctl is-active --quiet "$service2_name"; then s2_active=true; fi
    if $s1_active && $s2_active; then status_color="cyan"; fi
    
    echo "$status_color $(get_service_status_string "$service1_name") $(get_service_status_string "$service2_name")"
}

# [NEW] 获取 3 组件串联实例的组合状态 (颜色, 状态1, 状态2, 状态3)
get_3_chain_status_tuple() {
    local chain_id=$1 # e.g., s3c1
    local service1_name="ax-xray@${chain_id}.service" # SS
    local service2_name="kcptun@${chain_id}.service"        # KCPTUN
    local service3_name="udp2raw@${chain_id}.service"        # UDP2RAW
    
    local s1_active=false s2_active=false s3_active=false status_color="yellow"
    if systemctl is-active --quiet "$service1_name"; then s1_active=true; fi
    if systemctl is-active --quiet "$service2_name"; then s2_active=true; fi
    if systemctl is-active --quiet "$service3_name"; then s3_active=true; fi
    
    if $s1_active && $s2_active && $s3_active; then status_color="cyan"; fi
    
    echo "$status_color $(get_service_status_string "$service1_name") $(get_service_status_string "$service2_name") $(get_service_status_string "$service3_name")"
}


# 显示单个实例的状态行 
display_instance_status_line() {
    local type=$1 id=$2 prefix=$3; local full_id="$id"; local line
    case "$type" in
        "hy2_chain")
            full_id="c${id}"
            read -r color hy2_status udp_status <<< "$(get_chain_status_tuple "hy2" "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$HY2_INSTALL_DIR/hy2_${full_id}.yaml")
            line="$($color "${prefix}Hysteria2 [${hy2_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "vless_chain")
            full_id="vc${id}"
            read -r color xray_status udp_status <<< "$(get_chain_status_tuple "vless" "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}VLESS_mKCP [${xray_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "ss_3_chain_chain")
            full_id="s3c${id}"
            read -r color s1_status s2_status s3_status <<< "$(get_3_chain_status_tuple "$full_id")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}SS [${s1_status}] + KCP [${s2_status}] + UDP2RAW [${s3_status}] ${udp_info} (${warp_status})")"
            ;;
        "hysteria2"|"udp2raw"|"kcptun"|"xray_reality"|"xray_mkcp"|"xray_ss")
            local conf_file service_prefix title; local color_func="yellow"
            case "$type" in
                hysteria2) conf_file="$HY2_INSTALL_DIR/hy2_${id}.yaml"; service_prefix="ax-hysteria2"; title="Hysteria2";;
                udp2raw) conf_file="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"; service_prefix="ax-udp2raw"; title="UDP2RAW";;
                kcptun) conf_file="$KCPTUN_INSTALL_DIR/kcptun_${id}.json"; service_prefix="ax-kcptun"; title="KCPTUN";;
                xray_reality) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="VLESS+Reality";;
                xray_mkcp) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="VLESS+mKCP";;
                xray_ss) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="Shadowsocks";;
            esac
            local status_info=$(get_listen_info_from_conf "$conf_file")
            local status_str=$(get_service_status_string "${service_prefix}@${id}.service")
            local extra_info=""
            if [[ "$type" == "hysteria2" || "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then
                extra_info=" ($(get_warp_status_from_conf "$conf_file"))"
            fi
            if [[ "$status_str" == "运行中" ]]; then color_func="cyan"; fi
            line="$($color_func "${prefix}${title} [${status_str}] ${status_info}${extra_info}")"
            ;;
    esac
    echo -e "$line"
}

# 内部函数：获取指定目录下的所有实例 ID
get_instances() {
    local dir=$1 pattern=$2
    ls -1 "$dir"/$pattern 2>/dev/null | sed -E "s/.*_([a-zA-Z0-9]+)\\..*/\1/" | sort -V
}

# 获取 *独立* 实例的 ID 列表 (过滤掉串联实例)
get_standalone_instances() {
    local type_lowercase=$1
    local dir="" pattern=""
    local standalone_instances=()
    
    case "$type_lowercase" in
        "hysteria2") dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml";;
        "xray_reality") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_mkcp") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_ss") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "udp2raw") dir="$UDP2RAW_INSTALL_DIR"; pattern="udp2raw_*.conf";;
        "kcptun") dir="$KCPTUN_INSTALL_DIR"; pattern="kcptun_*.json";;
    esac

    local all_instances=$(get_instances "$dir" "$pattern")
    for i in $all_instances; do
        if [[ "$type_lowercase" == "xray_reality" ]]; then
            grep -q '"security": "reality"' "$dir/xray_${i}.json" 2>/dev/null && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_mkcp" ]]; then
            grep -q '"network": "kcp"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^(vc|s3c)[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_ss" ]]; then
            grep -q '"protocol": "shadowsocks"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^s3c[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ ! "$i" =~ ^(c|vc|s3c)[0-9]+$ ]]; then
            standalone_instances+=($i)
        fi
    done
    echo "${standalone_instances[@]}"
}


# --- 13. (独立) 实例管理菜单与操作 ---

# 管理单个独立实例的子菜单
manage_instance_menu() {
    local type=$1 id=$2 service=$3 conf=$4
    while true; do
        clear; echo "=================================="; echo "      管理 ${type^^} 实例 $(dim "$id")"; echo "=================================="
        echo "状态：$(get_service_status_string "$service") $(dim "$(get_listen_info_from_conf "$conf")")"
        if [[ "$type" == "hysteria2" ]]; then cyan "订阅链接: $(generate_hy2_subscription_link $id)"; fi
        if [[ "$type" == "xray_reality" ]]; then cyan "分享链接: $(generate_xray_reality_link $id)"; fi
        if [[ "$type" == "xray_mkcp" ]]; then cyan "分享链接: $(generate_xray_mkcp_link $id)"; fi
        if [[ "$type" == "xray_ss" ]]; then cyan "分享链接: $(generate_xray_ss_link $id)"; fi
        echo "----------------------------------"; echo "1) 启动/重启"; echo "2) 停止"; echo "3) 查看实时日志"; echo "4) 编辑配置"; echo "5) 删除此实例"; echo "6) 查看客户端配置"; echo "0) 返回"
        read -p "请选择 [0-6]: " choice
        case $choice in
            1) log "正在启动/重启..."; systemctl restart "$service"; green "操作完成！";;
            2) log "正在停止..."; systemctl stop "$service"; green "操作完成！";;
            3) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪日志... (按 Ctrl+C 仅退出日志)"
                sleep 1
                local current_trap=$(trap -p SIGINT) # 保存当前 trap
                trap ':' SIGINT
                journalctl -u "$service" -f --since "1 hour ago"
                eval "$current_trap" # 恢复 trap
                ;;
            4) nano "$conf"; log "重启实例以应用配置..."; systemctl restart "$service"; green "配置已更新！";;
            5) read -p "确认彻底删除实例 ${id}？(默认“否”) [y/N]: " confirm; if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then log "停止并删除..."; systemctl stop "$service"; systemctl disable "$service" >/dev/null 2>&1; rm -f "$conf"; systemctl daemon-reload; green "实例 ${id} 已删除！"; break; fi;;
            6) clear; echo "--- ${type^^} 客户端配置 (实例 $id) ---"
               case "$type" in
                   "hysteria2") cyan "订阅链接: $(generate_hy2_subscription_link "$id")" ;;
                   "udp2raw") view_udp2raw_client_config "$id" ;;
                   "kcptun") view_kcptun_client_config "$id" ;;
                   "xray_reality") cyan "分享链接: $(generate_xray_reality_link "$id")" ;;
                   "xray_mkcp") cyan "分享链接: $(generate_xray_mkcp_link "$id")" ;;
                   "xray_ss") cyan "分享链接: $(generate_xray_ss_link "$id")" ;;
               esac
               read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$choice" == "1" || "$choice" == "2" || "$choice" == "4" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}

# 创建一个新的独立实例 (hy2, udp2raw, kcptun)
create_new_instance() {
    local type=$1; local next_id; local INSTALL_DIR SERVICE_PREFIX FILE_EXT TITLE CONFIG_TEMPLATE SYSTEMD_SERVICE_NAME
    declare -A replacements

    case "$type" in
        hysteria2) 
            TITLE="Hysteria2"
            INSTALL_DIR="$HY2_INSTALL_DIR"
            SERVICE_PREFIX="hy2"
            SYSTEMD_SERVICE_NAME="ax-hysteria2"
            FILE_EXT="yaml"
            CONFIG_TEMPLATE="$HYSTERIA2_CONFIG_YAML_TEMPLATE"

            # --- [新] ACME 与伪装逻辑 ---
            read -p "是否使用 ACME (Let's Encrypt) 证书? (否则将使用自签名证书) (默认“是”) [Y/n]: " use_acme
            use_acme=${use_acme:-y} # Default to yes
            
            local cert_path="" key_path="" sni="" masquerade_url=""
            
            if [[ "$use_acme" == "y" || "$use_acme" == "Y" ]]; then
                read -p "请输入您的域名 (DNS 必须指向本机): " domain_name
                if [[ -z "$domain_name" ]]; then
                    red "域名不能为空！已取消创建。"
                    return 1
                fi

                # 尝试申请证书，如果失败直接退出
                if ! ax_get_certificate "$domain_name"; then
                    red "ACME 证书申请流程失败，已取消创建实例。"
                    return 1
                fi
                
                # 双重检查文件是否存在
                if [ -f "$AX_CERT_DIR/$domain_name/fullchain.cer" ]; then
                    green "ACME 验证成功. Hysteria2 将使用 $domain_name"
                    cert_path="$AX_CERT_DIR/$domain_name/fullchain.cer"
                    key_path="$AX_CERT_DIR/$domain_name/private.key"
                    sni="$domain_name"
                    masquerade_url="https://$domain_name"
                else
                    red "错误：未找到申请的证书文件，已取消创建实例。"
                    return 1
                fi
            else
                # 用户明确选择“否”，使用自签名
                generate_self_signed_cert
                cert_path="$HY2_CERT_PATH"
                key_path="$HY2_KEY_PATH"
                sni="$HY2_SNI"
                masquerade_url="$HY2_MASQUERADE_URL"
            fi
            
            replacements["__CERT_PATH__"]="$cert_path"
            replacements["__KEY_PATH__"]="$key_path"
            replacements["__MASQUERADE_URL__"]="$masquerade_url"
            
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ${SYSTEMD_SERVICE_NAME}@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"

            read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN__"]=":${listen_port}"

            read -p "是否启用 WARP SOCKS5 分流 (默认“否”)？[y/N]: " enable_warp
            if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
                read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
                local current_warp_addr="${DEFAULT_WARP_SOCKS_ADDR}:${warp_port}"; replacements["__OUTBOUNDS_AND_ACL__"]="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_SOCKS5_ADDR__/${current_warp_addr}}"
                green "已启用 WARP SOCKS5 分流 (地址: ${current_warp_addr})。"
            else
                replacements["__OUTBOUNDS_AND_ACL__"]="${HYSTERIA2_DIRECT_ACL_BLOCK}"; yellow "已禁用 WARP SOCKS5 分流。"
            fi
            
            replacements["__UDP_SNIFF_CONFIG__"]=""
            local password=$(handle_password_input "hysteria2")
            replacements["__PASSWORD__"]="$password"
            ;;

        udp2raw) TITLE="UDP2RAW"; INSTALL_DIR="$KCP_UDP_INSTALL_DIR"; SERVICE_PREFIX="udp2raw"; SYSTEMD_SERVICE_NAME="ax-udp2raw"; FILE_EXT="conf"; CONFIG_TEMPLATE="$UDP2RAW_CONFIG_TEMPLATE" 
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ${SYSTEMD_SERVICE_NAME}@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"
            read -p "请输入监听地址 (默认: $DEFAULT_LISTEN_ADDR): " listen_addr_input; listen_addr=${listen_addr_input:-$DEFAULT_LISTEN_ADDR}
            read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN_ADDR__"]="${listen_addr}:${listen_port}"
            read -p "请输入目标地址 (默认: $DEFAULT_TARGET_ADDR): " target_host; target_host=${target_host:-$DEFAULT_TARGET_ADDR}
            read -p "请输入目标端口 (留空则随机生成): " target_port; if [[ -z "$target_port" ]]; then target_port=$(find_available_port); green "已为您随机选择目标端口: $target_port"; fi
            replacements["__TARGET_ADDR__"]="${target_host}:${target_port}"
            local password=$(handle_password_input "$type"); replacements["__PASSWORD__"]="$password"
            ;;
            
        kcptun) TITLE="KCPTUN"; INSTALL_DIR="$KCP_UDP_INSTALL_DIR"; SERVICE_PREFIX="kcptun"; SYSTEMD_SERVICE_NAME="ax-kcptun"; FILE_EXT="json"; CONFIG_TEMPLATE="$KCPTUN_CONFIG_JSON_TEMPLATE" 
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ${SYSTEMD_SERVICE_NAME}@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"
            read -p "请输入监听地址 (默认: $DEFAULT_LISTEN_ADDR): " listen_addr_input; listen_addr=${listen_addr_input:-$DEFAULT_LISTEN_ADDR}
            read -p "请输入监听端口 (留空则随机生成): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN__"]="${listen_addr}:${listen_port}"
            read -p "请输入目标地址 (默认: $DEFAULT_TARGET_ADDR): " target_host; target_host=${target_host:-$DEFAULT_TARGET_ADDR}
            read -p "请输入目标端口 (留空则随机生成): " target_port; if [[ -z "$target_port" ]]; then target_port=$(find_available_port); green "已为您随机选择目标端口: $target_port"; fi
            replacements["__TARGET__"]="${target_host}:${target_port}"
            read -p "请输入加速模式 (默认: $KCPTUN_DEFAULT_MODE): " mode; mode=${mode:-$KCPTUN_DEFAULT_MODE}; replacements["__MODE__"]="$mode"
            local password=$(handle_password_input "$type"); replacements["__KEY__"]="$password"
            ;;
            
        *) red "内部错误: 无效的实例类型 '$type'"; return 1 ;;
    esac

    log "生成配置文件..."; local temp_config="$CONFIG_TEMPLATE"; local conf_path="${INSTALL_DIR}/${SERVICE_PREFIX}_${next_id}.${FILE_EXT}"
    for placeholder in "${!replacements[@]}"; do temp_config="${temp_config//${placeholder}/${replacements[${placeholder}]}}"; done
    echo "$temp_config" > "$conf_path"

    sync; log "启动服务..."; systemctl enable --now "${SYSTEMD_SERVICE_NAME}@${next_id}.service"; sleep 1; green "实例 ${next_id} 已启动！"; echo
    case "$type" in
        hysteria2) local sub_link=""; local retries=5; for ((i=1; i<=retries; i++)); do sub_link=$(generate_hy2_subscription_link $next_id); if [[ "$sub_link" != "N/A" ]]; then break; fi; sleep 0.5; done; cyan "订阅链接: $sub_link";;
        udp2raw) view_udp2raw_client_config "$next_id" ;;
        kcptun) view_kcptun_client_config "$next_id" ;;
    esac
}

# 创建一个新的 Xray 实例 (Reality 或 mKCP)
create_new_xray_instance() {
    local type=$1; local next_id;
    next_id=$(find_next_available_id "xray")
    
    declare -A replacements
    local temp_config=""
    local title=""

    if [[ "$type" == "xray_reality" ]]; then
        title="VLESS+Reality"
        temp_config="$XRAY_VLESS_REALITY_TEMPLATE"
        log "启动一个新的 ${title} 实例 (ID: ${next_id})..."
        
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"
        
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        
        log "正在生成 Reality 密钥对..."
        local tmp_key=$("$XRAY_INSTALL_DIR/xray" x25519)
        local private_key=$(echo "$tmp_key" | grep "Private key" | cut -d: -f2- | tr -d '[:space:]')
        local public_key=$(echo "$tmp_key" | grep "Public key" | cut -d: -f2- | tr -d '[:space:]')

        if [[ -z "$private_key" ]]; then
            private_key=$(echo "$tmp_key" | grep "PrivateKey" | cut -d: -f2- | tr -d '[:space:]')
        fi
        if [[ -z "$public_key" ]]; then
            public_key=$(echo "$tmp_key" | grep "Password" | cut -d: -f2- | tr -d '[:space:]')
        fi

        if [[ -z "$private_key" || -z "$public_key" ]]; then
            red "错误: 无法生成或解析 Reality 密钥对！"
            log "Xray 命令输出 (Debug): $tmp_key" 
            return 1
        fi

        replacements["__PRIVATE_KEY__"]="$private_key"
        replacements["__PUBLIC_KEY__"]="$public_key"
                
        green "已使用默认 Reality 参数: SNI=${XRAY_REALITY_DEFAULT_SNI}, Target=${XRAY_REALITY_DEFAULT_TARGET}, Fingerprint=${XRAY_REALITY_DEFAULT_FP}"
        replacements["__SNI__"]="$XRAY_REALITY_DEFAULT_SNI"
        replacements["__TARGET__"]="$XRAY_REALITY_DEFAULT_TARGET"
        replacements["__FINGERPRINT__"]="$XRAY_REALITY_DEFAULT_FP"
        replacements["__REALITY_FLOW__"]="$XRAY_REALITY_DEFAULT_FLOW"
        
        local short_id=$(openssl rand -hex 8); replacements["__SHORT_ID__"]="$short_id"
    
    elif [[ "$type" == "xray_mkcp" ]]; then
        title="VLESS+mKCP"
        temp_config="$XRAY_VLESS_MKCP_TEMPLATE"
        log "启动一个新的 ${title} 实例 (ID: ${next_id})..."
        
        read -p "请输入监听 IP (默认: $DEFAULT_LISTEN_ADDR): " listen_addr; listen_addr=${listen_addr:-$DEFAULT_LISTEN_ADDR}; replacements["__LISTEN_ADDR__"]="$listen_addr"
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"
        
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        local mkcp_seed=$(handle_password_input "xray_mkcp"); replacements["__MKCP_SEED__"]="$mkcp_seed"
    
    elif [[ "$type" == "xray_ss" ]]; then
        title="Shadowsocks"
        temp_config="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE"
        log "启动一个新的 ${title} 实例 (ID: ${next_id})..."

        read -p "请输入监听 IP (默认: $DEFAULT_LISTEN_ADDR): " listen_addr; listen_addr=${listen_addr:-$DEFAULT_LISTEN_ADDR}; replacements["__LISTEN_ADDR__"]="$listen_addr"
        read -p "请输入监听端口 (留空则随机): " listen_port; if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已随机选择端口: $listen_port"; fi
        replacements["__LISTEN_PORT__"]="$listen_port"

        read -p "请输入加密方式 (默认: $SS_DEFAULT_METHOD): " ss_method; ss_method=${ss_method:-$SS_DEFAULT_METHOD}; replacements["__SS_METHOD__"]="$ss_method"
        local ss_password=$(handle_password_input "shadowsocks"); replacements["__SS_PASSWORD__"]="$ss_password"
    fi

    read -p "是否启用 WARP SOCKS5 分流 (默认“否”)？[y/N]: " enable_warp
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # [新] 自动使用默认地址
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        local warp_config=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
        warp_config=${warp_config/__WARP_SOCKS5_ADDR__/$warp_addr}
        warp_config=${warp_config/__WARP_SOCKS5_PORT__/$warp_port}
        replacements["__OUTBOUNDS_AND_ROUTING__"]="$warp_config"
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        replacements["__OUTBOUNDS_AND_ROUTING__"]="$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK"
        yellow "已禁用 WARP SOCKS5 分流。"
    fi

    log "生成配置文件..."; local conf_path="${XRAY_INSTALL_DIR}/xray_${next_id}.json"
    for placeholder in "${!replacements[@]}"; do
        temp_config="${temp_config//${placeholder}/${replacements[${placeholder}]}}"
    done
    echo "$temp_config" > "$conf_path"

    sync; log "启动服务..."; systemctl enable --now "ax-xray@${next_id}.service"; sleep 1;
    if ! systemctl is-active --quiet "ax-xray@${next_id}.service"; then
        red "实例 ${next_id} 启动失败！请检查配置或日志。"
    else
        green "实例 ${next_id} 已启动！"; echo
        if [[ "$type" == "xray_reality" ]]; then
            cyan "分享链接: $(generate_xray_reality_link "$next_id")"
        elif [[ "$type" == "xray_mkcp" ]]; then
            cyan "分享链接: $(generate_xray_mkcp_link "$next_id")"
        elif [[ "$type" == "xray_ss" ]]; then
            cyan "分享链接: $(generate_xray_ss_link "$next_id")"
        fi
    fi
}
# --- 14. 客户端配置查看器 ---

# 生成 Hysteria2 订阅链接
generate_hy2_subscription_link() {
    local id=$1; local conf="$HY2_INSTALL_DIR/hy2_${id}.yaml"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    
    local password=$(grep -Po '(?<=password: ).*' "$conf" | tr -d '[:space:]')
    local port_info=$(get_listen_info_from_conf "$conf")
    local port=$(echo "$port_info" | awk -F':' '{print $NF}')
    local ip=$(get_public_ip)
    
    # [新] 动态决定 SNI 和 insecure 标记
    local cert_path=$(grep -Po '(?<=cert: ).*' "$conf" | tr -d '[:space:]')
    local sni=""
    local insecure_flag=0 # 默认安全
    
    if [[ "$cert_path" == *"$AX_CERT_DIR"* ]]; then
        # 是 ACME 证书, 从路径中提取域名
        sni=$(echo "$cert_path" | cut -d'/' -f4)
        insecure_flag=0 # 真实证书，安全
    else
        # 是自签名证书
        sni="$HY2_SNI" # 默认 bing.com
        insecure_flag=$HY2_CLIENT_INSECURE # 使用全局不安全标记 (1)
    fi
    
    # [新] 使用 sni 作为标识 (如果有)
    local host_label=$ip
    if [[ "$sni" != "$HY2_SNI" && -n "$sni" ]]; then
        host_label=$sni
    fi

    echo "hysteria2://${password}@${ip}:${port}?sni=${sni}&insecure=${insecure_flag}#hy2_${host_label}_${id}"
}

# 生成 VLESS+Reality 分享链接
generate_xray_reality_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local sni=$(jq -r '.inbounds[0].streamSettings.realitySettings.serverNames[0]' "$conf")
    local pbk=$(jq -r '.inbounds[0].streamSettings.realitySettings.publicKey' "$conf")
    local sid=$(jq -r '.inbounds[0].streamSettings.realitySettings.shortIds[0]' "$conf")
    local flow=$(jq -r '.inbounds[0].settings.clients[0].flow' "$conf")
    local fp=$(jq -r '.inbounds[0].streamSettings.realitySettings.fingerprint' "$conf")

    local link="vless://${uuid}@${ip}:${port}?type=tcp&security=reality&sni=${sni}&pbk=${pbk}&flow=${flow}&sid=${sid}&fp=${fp}#Xray_Reality_${ip}_${id}"
    echo "$link"
}

# 生成 VLESS+mKCP 分享链接
generate_xray_mkcp_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$conf")
    local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$conf")
    
    local link="vless://${uuid}@${ip}:${port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}#Xray_mKCP_${ip}_${id}"
    echo "$link"
}

# [NEW] 生成 Shadowsocks 分享链接
generate_xray_ss_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port_info=$(get_listen_info_from_conf "$conf")
    local port=$(echo "$port_info" | awk -F':' '{print $NF}')
    local password=$(jq -r '.inbounds[0].settings.password' "$conf")
    local method=$(jq -r '.inbounds[0].settings.method' "$conf")
    
    # Base64 encode: method:password
    local user_info=$(echo -n "${method}:${password}" | base64 | tr -d '\n' | sed 's/=*$//') # Remove padding
    
    local link="ss://${user_info}@${ip}:${port}#SS_${ip}_${id}"
    echo "$link"
}

# 查看所有 Hysteria2 独立实例的订阅链接
view_all_hy2_subscriptions() {
    local INSTANCES=$(get_standalone_instances "hysteria2"); if [[ -z "$INSTANCES" ]]; then yellow "未找到任何 Hysteria2 独立实例。"; return; fi
    cyan "--- Hysteria2 独立实例订阅链接 ---"; for id in $INSTANCES; do green "实例 ${id}: $(generate_hy2_subscription_link $id)"; done
}

# 查看 UDP2RAW 客户端配置
view_udp2raw_client_config(){
    local id=$1; local conf="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    local ip=$(get_public_ip); local port=$(get_listen_info_from_conf "$conf" | awk -F':' '{print $NF}'); local password=$(grep -Po '(?<=-k )[^ ]+' "$conf")
    
    cyan "--- UDP2RAW 实例 ${id} 客户端配置 ---";  echo
    green "${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${port} -l ${CLIENT_UDP2RAW_LISTEN_ADDR} -k ${password}"
}

# 查看 KCPTUN 客户端配置
view_kcptun_client_config(){
    local id=$1; local conf="$KCPTUN_INSTALL_DIR/kcptun_${id}.json"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    if ! command -v jq &>/dev/null; then red "错误: jq 未安装，无法解析配置。"; return; fi
    local ip=$(get_public_ip); local server_listen=$(jq -r '.listen' "$conf"); local server_port=$(echo "$server_listen" | awk -F':' '{print $NF}'); cyan "--- KCPTUN 实例 ${id} 客户端配置 ---"; echo
    yellow "方法一: 使用 JSON 配置文件 (推荐)"; yellow "将以下内容保存为客户端的 config.json (本地监听地址 ${CLIENT_KCPTUN_LISTEN_ADDR} 可自行修改):"; green "$(jq --arg listen "${CLIENT_KCPTUN_LISTEN_ADDR}" --arg target "${ip}:${server_port}" '.listen = $listen | .target = $target' "$conf")"; echo
    yellow "方法二: 使用命令行参数"; yellow "在客户端使用以下命令行参数 (本地监听地址 ${CLIENT_KCPTUN_LISTEN_ADDR} 可自行修改):";local args="--listen ${CLIENT_KCPTUN_LISTEN_ADDR} --target ${ip}:${server_port}"
    for key in $(jq -r 'keys_unsorted | .[]' "$conf"); do if [[ "$key" != "listen" && "$key" != "target" ]]; then local value=$(jq -r --arg k "$key" '.[$k]' "$conf"); args+=" --${key} ${value}"; fi; done; green "$args"; echo
}

# --- 15. 组件串联实例管理 (SS+KCP+UDP) ---

# [NEW] 获取 3 组件串联实例ID列表 (ss_3_chain)
get_chain_instances_3() {
    local instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances2=$(ls -1 "$KCP_UDP_INSTALL_DIR"/kcptun_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances3=$(ls -1 "$KCP_UDP_INSTALL_DIR"/udp2raw_s3c*.conf 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    echo "$instances1 $instances2 $instances3" | tr ' ' '\n' | sort -un
}

# 查看 3 组件串联实例的客户端配置
view_chain_client_config_3() {
    local id_num=$1
    local id="s3c${id_num}"
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${id}.json"
    local kcptun_conf_path="$KCPTUN_INSTALL_DIR/kcptun_${id}.json"
    local udp2raw_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"
    
    if [[ ! -f "$ss_conf_path" || ! -f "$kcptun_conf_path" || ! -f "$udp2raw_conf_path" ]]; then
        red "串联实例 ${id} 的配置文件不完整。"; return
    fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf_path" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf_path")
    local kcptun_password=$(jq -r '.key' "$kcptun_conf_path")
    local ss_method=$(jq -r '.inbounds[0].settings.method' "$ss_conf_path")
    local ss_password=$(jq -r '.inbounds[0].settings.password' "$ss_conf_path")
    
    cyan "--- SS+KCP+UDP 实例 ${id} 客户端配置 ---"; echo
    
    yellow "步骤 1: 运行 UDP2RAW (客户端)"
    yellow " (它会监听 ${CLIENT_SS_3_CHAIN_KCP_TARGET}, 作为 KCPTUN 的目标)"
    local client_args_udp2raw="${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${udp2raw_port} -l ${CLIENT_SS_3_CHAIN_KCP_TARGET} -k ${udp2raw_password}"
    green "$client_args_udp2raw"; echo
    
    yellow "步骤 2: 运行 KCPTUN (客户端)"
    yellow " (它会监听 ${CLIENT_SS_3_CHAIN_SS_TARGET}, 作为 SS 的目标)"

    local kcp_args="--listen ${CLIENT_SS_3_CHAIN_SS_TARGET} --target ${CLIENT_SS_3_CHAIN_KCP_TARGET}"
    # 解析 JSON 并将所有其他键附加为参数
    for key in $(jq -r 'keys_unsorted | .[]' "$kcptun_conf_path"); do
        if [[ "$key" != "listen" && "$key" != "target" ]]; then
            local value=$(jq -r --arg k "$key" '.[$k]' "$kcptun_conf_path")
            kcp_args+=" --${key} ${value}"
        fi
    done
    green "$kcp_args"; echo
    
    yellow "步骤 3: SS 客户端配置 (指向本地 KCPTUN)"
    local ss_user_info=$(echo -n "${ss_method}:${ss_password}" | base64 | tr -d '\n' | sed 's/=*$//')
    local ss_host=$(echo "$CLIENT_SS_3_CHAIN_SS_TARGET" | cut -d: -f1)
    local ss_port=$(echo "$CLIENT_SS_3_CHAIN_SS_TARGET" | cut -d: -f2)
    
    # [修改点] 统一命名格式为 Chain_ss_kcp_... +UDP2RAW
    local sub_link="ss://${ss_user_info}@${ss_host}:${ss_port}#Chain_ss_kcp_${ip}_${id}+UDP2RAW"
    green "$sub_link"; echo
    
    echo
    yellow "[SS+KCPTUN+UDP2RAW] 合并订阅链接 (复制以下整行):"
    green "CHAIN##${sub_link} && KCPTUN://${kcp_args} && UDP2RAW://${client_args_udp2raw}"
    echo
}

# 启动一个新的 3 组件串联实例 (SS+KCP+UDP)
start_new_chain_instance_3() {
    local i=1
    while true; do if [[ ! -f "$XRAY_INSTALL_DIR/xray_s3c${i}.json" ]]; then break; fi; i=$((i + 1)); done
    
    local chain_id="s3c${i}"
    log "启动一个新的 SS+KCP+UDP 串联实例 (全自动)..."
    green "新串联实例将被创建为: ${chain_id}"
    
    read -p "请输入对外监听端口 (UDP2RAW) (留空则随机): " udp2raw_listen_port
    if [[ -z "$udp2raw_listen_port" ]]; then 
        udp2raw_listen_port=$(find_available_port); 
        green "已自动选择对外端口 (UDP2RAW): $udp2raw_listen_port"
    else
        green "已指定对外端口 (UDP2RAW): $udp2raw_listen_port"
    fi
    
    local kcptun_listen_port=$(find_available_port); green "已自动选择内联端口 (KCPTUN): $kcptun_listen_port"
    local ss_listen_port=$(find_available_port); green "已自动选择内联端口 (SS): $ss_listen_port"
    
    log "正在自动生成所有密码..."
    local udp2raw_password=$(generate_strong_password)
    green "已自动生成 UDP2RAW 密码: $udp2raw_password"
    
    local kcptun_password=$(generate_strong_password)
    green "已自动生成 KCPTUN 密码: $kcptun_password"

    if ! command -v openssl &>/dev/null; then 
        red "错误: openssl 未安装, 无法生成 SS 密钥！"; return 1; 
    fi
    local ss_password=$(openssl rand -base64 32)
    green "已自动生成 SS-2022 Base64 密钥: $ss_password"
    
    # 1. 配置 Xray (Shadowsocks)
    local ss_config="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE"
    ss_config=${ss_config/__LISTEN_ADDR__/127.0.0.1}
    ss_config=${ss_config/__LISTEN_PORT__/$ss_listen_port}
    ss_config=${ss_config/__SS_METHOD__/$SS_DEFAULT_METHOD}
    ss_config=${ss_config/__SS_PASSWORD__/$ss_password}
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${chain_id}.json"
    
    # 2. 配置 KCPTUN
    local kcp_config="$KCPTUN_CONFIG_JSON_TEMPLATE"
    kcp_config=${kcp_config/__LISTEN__/127.0.0.1:${kcptun_listen_port}}
    kcp_config=${kcp_config/__TARGET__/127.0.0.1:${ss_listen_port}}
    kcp_config=${kcp_config/__KEY__/$kcptun_password}
    kcp_config=${kcp_config/__MODE__/$KCPTUN_DEFAULT_MODE}
    local kcp_conf_path="$KCPTUN_INSTALL_DIR/kcptun_${chain_id}.json"
    
    # 3. 配置 UDP2RAW
    local udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    udp_config="${udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    udp_config="${udp_config//__TARGET_ADDR__/127.0.0.1:${kcptun_listen_port}}"
    udp_config="${udp_config//__PASSWORD__/${udp2raw_password}}"
    local udp_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${chain_id}.conf"

    # 处理 WARP
    read -p "是否启用 WARP SOCKS5 分流 (默认“否”)？[y/N]: " enable_warp
    local warp_config_block=""
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # [新] 自动使用默认地址
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        
        warp_config_block=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
        warp_config_block=${warp_config_block/__WARP_SOCKS5_ADDR__/$warp_addr}
        warp_config_block=${warp_config_block/__WARP_SOCKS5_PORT__/$warp_port}
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        warp_config_block=$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK
        yellow "已禁用 WARP SOCKS5 分流。"
    fi
    ss_config=${ss_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
    
    # 写入所有配置
    log "生成配置文件..."
    echo "$ss_config" > "$ss_conf_path"
    echo "$kcp_config" > "$kcp_conf_path"
    echo "$udp_config" > "$udp_conf_path"
    
    sync; log "启动串联服务...";
    systemctl enable --now "ax-xray@${chain_id}.service"
    systemctl enable --now "kcptun@${chain_id}.service"
    systemctl enable --now "udp2raw@${chain_id}.service"
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config_3 "$i"
}

# [NEW] 管理一个已存在的 3 组件串联实例
manage_chain_instance_3() {
    local id_num=$1
    local manage_id="s3c${id_num}"
    
    local service1_full="ax-xray@${manage_id}.service" # SS
    local service2_full="kcptun@${manage_id}.service"        # KCP
    local service3_full="udp2raw@${manage_id}.service"        # UDP2RAW
    
    local conf1_path="$XRAY_INSTALL_DIR/xray_${manage_id}.json"
    local conf2_path="$KCPTUN_INSTALL_DIR/kcptun_${manage_id}.json"
    local conf3_path="$UDP2RAW_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "   管理 SS+KCP+UDP $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status s3_status <<< "$(get_3_chain_status_tuple "$manage_id")"
        local udp2raw_info=$(get_listen_info_from_conf "$conf3_path")
        
        $color "状态: SS [${s1_status}] + KCP [${s2_status}] + UDP2RAW [${s3_status}] $(dim "$udp2raw_info")"

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 SS (Xray) 日志"; echo "5) 查看 KCPTUN 日志"; echo "6) 查看 UDP2RAW 日志"; echo "7) 编辑 SS (Xray) 配置文件"; echo "8) 编辑 KCPTUN 配置文件"; echo "9) 编辑 UDP2RAW 配置文件"; echo "10) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full" "$service3_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full" "$service3_full";;
            3) view_chain_client_config_3 "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) log "正在实时跟踪 SS (Xray) 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service1_full" -f; eval "$ct";;
            5) log "正在实时跟踪 KCPTUN 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service2_full" -f; eval "$ct";;
            6) log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service3_full" -f; eval "$ct";;
            7) nano "$conf1_path"; systemctl restart "$service1_full";;
            8) nano "$conf2_path"; systemctl restart "$service2_full";;
            9) nano "$conf3_path"; systemctl restart "$service3_full";;
            10) read -p "确认删除串联实例 ${manage_id}？(默认“否”) [y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full" "$service3_full"; 
                systemctl disable "$service1_full" "$service2_full" "$service3_full" >/dev/null 2>&1; 
                rm -f "$conf1_path" "$conf2_path" "$conf3_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "7" || "$manage_choice" == "8" || "$manage_choice" == "9" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}


# --- 16. [合并] 2 组件串联实例管理 (Hysteria2 / VLESS) ---

# 获取 2 组件串联实例ID列表 (hy2 或 vless)
get_chain_instances() {
    local chain_type=$1
    local instances1="" instances2=""
    if [[ "$chain_type" == "hy2" ]]; then
        instances1=$(ls -1 "$HY2_INSTALL_DIR"/hy2_c*.yaml 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
        instances2=$(ls -1 "$KCP_UDP_INSTALL_DIR"/udp2raw_c*.conf 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
    else # vless
        instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_vc*.json 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
        instances2=$(ls -1 "$KCP_UDP_INSTALL_DIR"/udp2raw_vc*.conf 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
    fi
    echo "$instances1 $instances2" | tr ' ' '\n' | sort -un
}

# 查看 2 组件串联实例的客户端配置
# 查看 2 组件串联实例的客户端配置
view_chain_client_config() {
    local chain_type=$1 id_num=$2
    local id_prefix="" main_conf_path="" client_listen_addr="" title=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"; client_listen_addr="$CLIENT_UDP2RAW_LISTEN_ADDR"
    else
        id_prefix="vc"; title="VLESS_mKCP"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"; client_listen_addr="$CLIENT_VLESS_UDP2RAW_LISTEN_ADDR"
    fi
    local id="${id_prefix}${id_num}"
    local udp2raw_conf="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"
    if [[ ! -f "$main_conf_path" || ! -f "$udp2raw_conf" ]]; then red "串联实例 ${id} 的配置文件不完整。"; return; fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf")
    
    local client_args="${UDP2RAW_CLIENT_BASE_ARGS} -r ${ip}:${udp2raw_port} -l ${client_listen_addr} -k ${udp2raw_password}"
    local client_udp2raw_host=$(echo "$client_listen_addr" | cut -d: -f1)
    local client_udp2raw_port=$(echo "$client_listen_addr" | cut -d: -f2)
    local sub_link=""
    local display_title=""
    local host_label=$ip

    if [[ "$chain_type" == "hy2" ]]; then
        display_title="[hy2+UDP2RAW]"
        local hy2_password=$(grep -Po '(?<=password: ).*' "$main_conf_path" | tr -d '[:space:]')
        
        # [新] 动态提取 SNI
        local cert_path=$(grep -Po '(?<=cert: ).*' "$main_conf_path" | tr -d '[:space:]')
        local sni=""
        local insecure_flag=0
        
        if [[ "$cert_path" == *"$AX_CERT_DIR"* ]]; then
            # 是 ACME 证书
            sni=$(echo "$cert_path" | cut -d'/' -f4)
            insecure_flag=0
        else
            # 自签名
            sni="$HY2_SNI"
            insecure_flag=$HY2_CLIENT_INSECURE
        fi
        
        # [新] 如果有真实域名，UDP2RAW 和 链接备注都使用域名
        local server_addr=$ip
        if [[ "$sni" != "$HY2_SNI" && -n "$sni" ]]; then
            server_addr=$sni
            host_label=$sni
            # 更新 client_args 使用域名
            client_args="${UDP2RAW_CLIENT_BASE_ARGS} -r ${server_addr}:${udp2raw_port} -l ${client_listen_addr} -k ${udp2raw_password}"
        fi
        
        # [修改点] 更改了节点备注格式：Chain_hy2_... +UDP2RAW
        sub_link="hysteria2://${hy2_password}@${client_udp2raw_host}:${client_udp2raw_port}?sni=${sni}&insecure=${insecure_flag}#Chain_hy2_${host_label}_${id}+UDP2RAW"
    else # vless
        display_title="[VLESS_mKCP+UDP2RAW]"
        local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$main_conf_path")
        local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$main_conf_path")
        local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$main_conf_path")
        
        # [修改点] 更改了节点备注格式：Chain_vless_kcp_... +UDP2RAW
        sub_link="vless://${uuid}@${client_udp2raw_host}:${client_udp2raw_port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}#Chain_vless_kcp_${host_label}_${id}+UDP2RAW"
    fi

    cyan "--- ${title} 串联实例 ${id} 客户端配置 ---"; echo
    
    yellow "1. ${title} 客户端 (指向本地):"
    green "$sub_link"; echo
    
    yellow "2. UDP2RAW 客户端 (连接公网):"
    green "$client_args"; echo
    
    yellow "$display_title 合并订阅链接 (复制以下整行):"
    green "CHAIN##${sub_link} && UDP2RAW://${client_args}"
    echo
}

# 启动一个新的 2 组件串联实例 (hy2 或 vless)
start_new_chain_instance() {
    local chain_type=$1
    local i=1 id_prefix="" title="" main_conf_dir="" main_conf_template=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2+UDP"; main_conf_dir="$HY2_INSTALL_DIR"; main_conf_template="$HYSTERIA2_CONFIG_YAML_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/hy2_c${i}.yaml" ]]; then break; fi; i=$((i + 1)); done
    else # vless
        id_prefix="vc"; title="VLESS_mKCP+UDP"; main_conf_dir="$XRAY_INSTALL_DIR"; main_conf_template="$XRAY_VLESS_MKCP_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/xray_vc${i}.json" ]]; then break; fi; i=$((i + 1)); done
    fi
    
    local chain_id="${id_prefix}${i}"
    log "启动一个新的 ${title} 串联实例 (全自动)..."
    green "新串联实例将被创建为: ${chain_id}"
    local udp2raw_listen_port=$(find_available_port); green "已自动选择对外端口: $udp2raw_listen_port"
    local internal_listen_port=$(find_available_port); green "已自动选择内联端口: $internal_listen_port"
    local udp2raw_password=$(generate_strong_password); echo -n "已自动生成 UDP2RAW 密码: "; green "$udp2raw_password"
    
    local main_config="$main_conf_template"
    local main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        local hy2_password=$(generate_strong_password); echo -n "已自动生成 Hysteria2 密码: "; green "$hy2_password"
        
        # --- [新] ACME 证书支持 (串联模式 - 健壮性增强版) ---
        read -p "是否使用 ACME (Let's Encrypt) 证书? (否则将使用自签名证书) (默认“是”) [Y/n]: " use_acme
        use_acme=${use_acme:-y} # 回车默认为 y
        
        local cert_path="" key_path="" masquerade_url=""
        
        if [[ "$use_acme" == "y" || "$use_acme" == "Y" ]]; then
            read -p "请输入您的域名 (DNS 必须指向本机): " domain_name
            if [[ -z "$domain_name" ]]; then
                red "域名不能为空！已取消创建。"
                return 1
            fi

            # 尝试申请证书，如果失败直接退出
            if ! ax_get_certificate "$domain_name"; then
                red "ACME 证书申请流程失败，已取消创建实例。"
                return 1
            fi
            
            if [ -f "$AX_CERT_DIR/$domain_name/fullchain.cer" ]; then
                green "ACME 验证成功. Hysteria2 将使用 $domain_name"
                cert_path="$AX_CERT_DIR/$domain_name/fullchain.cer"
                key_path="$AX_CERT_DIR/$domain_name/private.key"
                masquerade_url="https://$domain_name"
            else
                red "错误：未找到申请的证书文件，已取消创建实例。"
                return 1
            fi
        else
            # 用户明确选择“否”
            generate_self_signed_cert
            cert_path="$HY2_CERT_PATH"
            key_path="$HY2_KEY_PATH"
            masquerade_url="$HY2_MASQUERADE_URL"
        fi
        # ------------------------------------
        
        main_config="${main_config//__LISTEN__/127.0.0.1:${internal_listen_port}}"
        main_config="${main_config//__CERT_PATH__/${cert_path}}"
        main_config="${main_config//__KEY_PATH__/${key_path}}"
        main_config="${main_config//__PASSWORD__/${hy2_password}}"
        main_config="${main_config//__MASQUERADE_URL__/${masquerade_url}}"
        main_config="${main_config/__UDP_SNIFF_CONFIG__/udpPorts: all}"
        main_conf_path="$main_conf_dir/hy2_${chain_id}.yaml"
    else # vless
        local uuid=$(generate_strong_password); echo -n "已自动生成 VLESS UUID: "; green "$uuid"
        local mkcp_seed=$(generate_strong_password); echo -n "已自动生成 mKCP Seed: "; green "$mkcp_seed"
        main_config=${main_config/__LISTEN_ADDR__/127.0.0.1}
        main_config=${main_config/__LISTEN_PORT__/$internal_listen_port}
        main_config=${main_config/__UUID__/$uuid}
        main_config=${main_config/__MKCP_SEED__/$mkcp_seed}
        main_conf_path="$main_conf_dir/xray_${chain_id}.json"
    fi
    
    read -p "是否启用 WARP SOCKS5 分流 (默认“否”)？[y/N]: " enable_warp
    local warp_config_block=""
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # [新] 自动使用默认地址
        read -p "请输入 WARP SOCKS5 端口 (默认: $DEFAULT_WARP_SOCKS_PORT): " warp_port; warp_port=${warp_port:-$DEFAULT_WARP_SOCKS_PORT}
        
        if [[ "$chain_type" == "hy2" ]]; then
            warp_config_block="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_SOCKS5_ADDR__/${warp_addr}:${warp_port}}"
        else # vless
            warp_config_block=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
            warp_config_block=${warp_config_block/__WARP_SOCKS5_ADDR__/$warp_addr}
            warp_config_block=${warp_config_block/__WARP_SOCKS5_PORT__/$warp_port}
        fi
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        if [[ "$chain_type" == "hy2" ]]; then
            warp_config_block=$HYSTERIA2_DIRECT_ACL_BLOCK
        else # vless
            warp_config_block=$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK
        fi
        yellow "已禁用 WARP SOCKS5 分流。"
    fi
    
    if [[ "$chain_type" == "hy2" ]]; then
        main_config=${main_config/__OUTBOUNDS_AND_ACL__/$warp_config_block}
    else # vless
        main_config=${main_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
    fi
    
    echo "$main_config" > "$main_conf_path"
    
    log "生成 UDP2RAW 配置文件: udp2raw_${chain_id}.conf..."; local temp_udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    temp_udp_config="${temp_udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    temp_udp_config="${temp_udp_config//__TARGET_ADDR__/127.0.0.1:${internal_listen_port}}"
    temp_udp_config="${temp_udp_config//__PASSWORD__/${udp2raw_password}}"
    echo "$temp_udp_config" > "$UDP2RAW_INSTALL_DIR/udp2raw_${chain_id}.conf"
    
    sync; log "启动串联服务...";
    if [[ "$chain_type" == "hy2" ]]; then
        systemctl enable --now "hysteria2@${chain_id}.service"
    else # vless
        systemctl enable --now "ax-xray@${chain_id}.service"
    fi
    systemctl enable --now "udp2raw@${chain_id}.service"
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config "$chain_type" "$i"
}

# 管理一个已存在的 2 组件串联实例
manage_chain_instance() {
    local chain_type=$1 id_num=$2
    local id_prefix="" title="" service1_name="" service2_name="" main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; service1_name="ax-hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"
    else # vless
        id_prefix="vc"; title="VLESS_mKCP"; service1_name="ax-xray"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"
    fi
    
    local manage_id="${id_prefix}${id_num}"
    service2_name="ax-udp2raw"
    local service1_full="${service1_name}@${manage_id}.service"
    local service2_full="${service2_name}@${manage_id}.service"
    local udp2raw_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "      管理${title}串联实例 $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status <<< "$(get_chain_status_tuple "$chain_type" "$manage_id")"
        local udp2raw_info=$(get_listen_info_from_conf "$udp2raw_conf_path")
        
        if [[ "$chain_type" == "hy2" ]]; then
            $color "状态: Hysteria2 [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        else
            $color "状态: VLESS_mKCP [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        fi

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 ${title} 日志"; echo "5) 查看 UDP2RAW 日志"; echo "6) 编辑 ${title} 配置文件 (高级)"; echo "7) 编辑 UDP2RAW 配置文件 (高级)"; echo "8) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full";;
            3) view_chain_client_config "$chain_type" "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 ${title} 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service1_full" -f
                eval "$current_trap"
                ;;
            5) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service2_full" -f
                eval "$current_trap"
                ;;
            6) nano "$main_conf_path"; systemctl restart "$service1_full";;
            7) nano "$udp2raw_conf_path"; systemctl restart "$service2_full";;
            8) read -p "确认删除串联实例 ${manage_id}？(默认“否”) [y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full"; 
                systemctl disable "$service1_full" "$service2_full" >/dev/null 2>&1; 
                rm -f "$main_conf_path" "$udp2raw_conf_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "6" || "$manage_choice" == "7" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}

# [Bugfix] 3 组件串联实例的通用管理菜单
chain_manager_menu_3() {
    local title="SS+KCP+UDP 一键串联"
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances_3)
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "ss_3_chain_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的串联实例。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的串联实例"; echo "2) 管理一个已存在的串联实例"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance_3; read -p $'\n按任意键返回...' -n1 -s;;
            2) 
                if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi
                read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num
                # 简单的存在性检查
                if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then 
                    manage_chain_instance_3 "$manage_id_num"
                else 
                    red "无效的实例ID！"; sleep 2
                fi
                ;;
            3) 
                if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi
                local i; for i in $INSTANCES; do view_chain_client_config_3 "$i"; done
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# 2 组件串联实例的通用管理菜单
chain_manager_menu() {
    local chain_type=$1
    local title=""
    if [[ "$chain_type" == "hy2" ]]; then
        title="Hysteria2+UDP一键串联"
    else # vless
        title="VLESS_mKCP+UDP一键串联"
    fi
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances "$chain_type")
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "${chain_type}_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的串联实例。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的串联实例"; echo "2) 管理一个已存在的串联实例"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance "$chain_type"; read -p $'\n按任意键返回...' -n1 -s;;
            2) if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi; read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num; if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then manage_chain_instance "$chain_type" "$manage_id_num"; else red "无效的实例ID！"; sleep 2; fi;;
            3) if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi; local i; for i in $INSTANCES; do view_chain_client_config "$chain_type" $i; done; read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# 独立实例总管理菜单 (循环)
main_manager_loop() {
    local type=$1; local title dir pattern service_prefix type_lowercase
    case $type in 
        hysteria2) title="Hysteria2 (独立)"; dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml"; service_prefix="ax-hysteria2"; type_lowercase="hysteria2";;
        udp2raw) title="UDP2RAW (独立)"; dir="$UDP2RAW_INSTALL_DIR"; pattern="udp2raw_*.conf"; service_prefix="ax-udp2raw"; type_lowercase="udp2raw";;
        kcptun) title="KCPTUN (独立)"; dir="$KCPTUN_INSTALL_DIR"; pattern="kcptun_*.json"; service_prefix="ax-kcptun"; type_lowercase="kcptun";;
        xray_reality) title="VLESS+Reality (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_reality";;
        xray_mkcp) title="VLESS+mKCP (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_mkcp";;
        xray_ss) title="Shadowsocks (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_ss";;
    esac
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "     安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#INSTANCES[@]} -gt 0 ]]; then
            echo "$(bold "--- 已存在的实例 ---")"; for i in "${INSTANCES[@]}"; do display_instance_status_line "$type_lowercase" "$i" "  "; done
        else
            yellow "当前没有已创建的 $title 实例。"
        fi

        echo "----------------------------------"; local menu_options=("1) 启动一个新的实例" "2) 管理一个已存在的实例")
        if [[ "$type" == "hysteria2" ]]; then menu_options+=("3) 查看hy2订阅地址");
        elif [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then menu_options+=("3) 查看分享链接");
        elif [[ "$type" == "udp2raw" || "$type" == "kcptun" ]]; then menu_options+=("3) 查看客户端配置"); fi
        menu_options+=("0) 返回主菜单"); for opt in "${menu_options[@]}"; do echo "$opt"; done
        read -p "请选择: " choice
        case $choice in
            1)
                if [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then create_new_xray_instance "$type_lowercase"; else create_new_instance "$type_lowercase"; fi
                read -p $'\n按任意键返回...' -n1 -s;;
            2)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi
                local manage_id; read -p "请输入您想管理的实例ID [$(echo "${INSTANCES[@]}")]: " manage_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$manage_id" ]]; then is_valid=true; break; fi; done
                if [[ "$is_valid" == true ]]; then
                    local conf_path
                    case $type in
                        hysteria2) conf_path="$dir/hy2_${manage_id}.yaml";;
                        udp2raw) conf_path="$dir/udp2raw_${manage_id}.conf";;
                        kcptun) conf_path="$dir/kcptun_${manage_id}.json";;
                        xray_reality|xray_mkcp|xray_ss) conf_path="$dir/xray_${manage_id}.json";;
                    esac
                    manage_instance_menu "$type_lowercase" "$manage_id" "${service_prefix}@${manage_id}" "$conf_path"
                else red "无效的实例ID！"; sleep 2; fi;;
            3)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi
                if [[ "$type" == "hysteria2" ]]; then view_all_hy2_subscriptions
                else
                    local view_id; read -p "请输入您想查看的实例ID [$(echo "${INSTANCES[@]}")]: " view_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$view_id" ]]; then is_valid=true; break; fi; done
                    if [[ "$is_valid" == true ]]; then
                        case "$type" in
                            udp2raw) view_udp2raw_client_config "$view_id" ;;
                            kcptun) view_kcptun_client_config "$view_id" ;;
                            xray_reality) cyan "$(generate_xray_reality_link "$view_id")" ;;
                            xray_mkcp) cyan "$(generate_xray_mkcp_link "$view_id")" ;;
                            xray_ss) cyan "$(generate_xray_ss_link "$view_id")" ;;
                        esac
                    else red "无效的实例ID！"; fi
                fi
                read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# --- 17. 全局操作 (查看全部/重启/更新/卸载) ---

# [新] 显示全局 TLS 证书状态
show_global_tls_status() {
    echo "--- TLS 证书状态 ---"
    
    # 检查 ACME 证书目录
    if [ ! -d "$AX_CERT_DIR" ] || [ -z "$(ls -A $AX_CERT_DIR)" ]; then
        yellow "  未找到 $AX_CERT_DIR 目录, 未管理任何 ACME 证书。"
    else
        # 遍历 $AX_CERT_DIR 下的每个域名目录
        for domain_dir in "$AX_CERT_DIR"/*; do
            if [ -d "$domain_dir" ]; then
                local domain=$(basename "$domain_dir")
                local cert_file="$domain_dir/fullchain.cer"
                local key_file="$domain_dir/private.key"
                
                if [ -f "$cert_file" ] && [ -f "$key_file" ]; then
                    local expiry_date_str
                    local days_remaining="N/A"
                    
                    # 尝试获取到期天数
                    if command -v openssl &>/dev/null; then
                        expiry_date_str=$(openssl x509 -in "$cert_file" -noout -enddate 2>/dev/null | cut -d= -f2)
                        if [ -n "$expiry_date_str" ]; then
                            local expiry_epoch=$(date -d "$expiry_date_str" +%s 2>/dev/null)
                            local now_epoch=$(date +%s)
                            if [ -n "$expiry_epoch" ]; then
                                days_remaining=$(((expiry_epoch - now_epoch) / 86400))
                                days_remaining="(剩余 ${days_remaining} 天)"
                            fi
                        fi
                    fi
                    
                    cyan "[域名] $domain $days_remaining"
                    echo "  公钥 (Cert): $cert_file"
                    echo "  私钥 (Key):  $key_file"
                fi
            fi
        done
    fi
}

# 查看全部实例的客户端配置
view_all_configs() {
    clear; echo "=================================="; echo "        查看全部实例配置"; echo "=================================="; echo
    
    local ss_3_chain_instances=$(get_chain_instances_3); if [[ -n "$ss_3_chain_instances" ]]; then for i in $ss_3_chain_instances; do view_chain_client_config_3 "$i"; echo "----------------------------------"; done; fi
    local hy2_chain_instances=$(get_chain_instances "hy2"); if [[ -n "$hy2_chain_instances" ]]; then for i in $hy2_chain_instances; do view_chain_client_config "hy2" "$i"; echo "----------------------------------"; done; fi
    local vless_chain_instances=$(get_chain_instances "vless"); if [[ -n "$vless_chain_instances" ]]; then for i in $vless_chain_instances; do echo; view_chain_client_config "vless" "$i"; echo "----------------------------------"; done; fi
    
    local standalone_hy2=($(get_standalone_instances "hysteria2")); if [[ ${#standalone_hy2[@]} -gt 0 ]]; then echo; cyan "--- Hysteria2 (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_hy2[@]}"; do green "$(generate_hy2_subscription_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_reality=($(get_standalone_instances "xray_reality")); if [[ ${#standalone_reality[@]} -gt 0 ]]; then echo; cyan "--- VLESS+Reality (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_reality[@]}"; do green "$(generate_xray_reality_link $id)"; done; echo "----------------------------------"; fi
    local standalone_mkcp=($(get_standalone_instances "xray_mkcp")); if [[ ${#standalone_mkcp[@]} -gt 0 ]]; then echo; cyan "--- VLESS+mKCP (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_mkcp[@]}"; do green "$(generate_xray_mkcp_link $id)"; done; echo "----------------------------------"; fi
    local standalone_ss=($(get_standalone_instances "xray_ss")); if [[ ${#standalone_ss[@]} -gt 0 ]]; then echo; cyan "--- Shadowsocks (独立) 实例订阅链接 ---"; echo
    for id in "${standalone_ss[@]}"; do green "$(generate_xray_ss_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_udp2raw=($(get_standalone_instances "udp2raw")); if [[ ${#standalone_udp2raw[@]} -gt 0 ]]; then echo; for id in "${standalone_udp2raw[@]}"; do view_udp2raw_client_config "$id"; echo; done; echo "----------------------------------"; fi
    local standalone_kcptun=($(get_standalone_instances "kcptun")); if [[ ${#standalone_kcptun[@]} -gt 0 ]]; then echo; for id in "${standalone_kcptun[@]}"; do view_kcptun_client_config "$id"; echo; done; fi

    if ! is_installed; then yellow "系统中没有任何已配置的实例。"; fi
}

# 重启所有服务
restart_all_services(){ log "正在重启所有正在运行的实例..."; systemctl restart kcptun@*.service udp2raw@*.service hysteria2@*.service ax-xray@*.service 2>/dev/null; green "操作完成！"; sleep 2; }

# 检查并更新所有核心程序
check_for_updates(){ log "检查更新..."; download_kcp_udp_binaries; download_hysteria2_binary; download_xray_binary; log "所有程序已更新到最新版本，重启所有服务以应用..."; restart_all_services; sleep 2;}

# [NEW] 安装 VPS 一键优化脚本
install_sys_opt() {
    echo "----------------------------------------------------------------"
    log "即将开始下载并运行 VPS 一键优化脚本 (vps_optimizert.sh) ..."
    
    # 运行用户提供的命令
    wget --no-check-certificate -O vps_optimizert.sh "https://raw.githubusercontent.com/halibotee/scripts/main/vps_optimizert.sh" && chmod +x vps_optimizert.sh && ./vps_optimizert.sh
    
    # 检查脚本是否成功下载（作为执行后的一个简单反馈）
    if [ ! -f "vps_optimizert.sh" ]; then
         echo "----------------------------------------------------------------"
         red "错误：下载 vps_optimizert.sh 失败或脚本未正确执行。"
         log "即将返回主菜单..."
         return 1 # 返回错误状态
    fi

    echo "----------------------------------------------------------------"
    green "VPS 一键优化脚本 (vps_optimizert.sh) 执行完毕。"
    log "即将返回主菜单..."
}

# [NEW] 安装 warp-socket5 脚本
install_warp_yg() {
    echo "----------------------------------------------------------------"
    log "即将开始下载并运行 warp-socket5.sh 脚本..."
    
    # 运行用户提供的命令
    wget --no-check-certificate -O warp-socket5.sh "https://raw.githubusercontent.com/halibotee/scripts/main/warp-socket5.sh" && chmod +x warp-socket5.sh && ./warp-socket5.sh
    
    if [ ! -f "warp-socket5.sh" ]; then
         echo "----------------------------------------------------------------"
         red "错误：下载 warp-socket5.sh 失败或脚本未正确执行。"
         log "即将返回主菜单..."
         return 1 # 返回错误状态
    fi
    
    echo "----------------------------------------------------------------"
    green "warp-socket5.sh 脚本 执行完毕。"
    log "即将返回主菜单..."
}

# [NEW] ACME 证书管理菜单
acme_certificate_menu() {
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回主菜单...${reset}"; sleep 1; break' SIGINT
        clear
        echo "=================================="
        echo "      ACME 证书管理"
        echo "=================================="
        
        # 显示当前证书状态
        show_global_tls_status
        
        echo "----------------------------------"
        echo "1) 申请新证书"
        echo "2) 续订证书"
        echo "3) 删除证书"
        echo "4) 查看证书详情"
        echo "5) 安装/重装 ACME.sh 客户端"
        echo "0) 返回主菜单"
        echo "----------------------------------"
        read -p "请选择 [0-5]: " acme_choice
        
        case $acme_choice in
            1)
                # 申请新证书
                read -p "请输入域名: " domain_name
                if [[ -z "$domain_name" ]]; then
                    red "域名不能为空！"
                    sleep 2
                    continue
                fi
                ax_get_certificate "$domain_name"
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            2)
                # 续订证书
                if [ ! -d "$AX_CERT_DIR" ] || [ -z "$(ls -A $AX_CERT_DIR 2>/dev/null)" ]; then
                    yellow "没有找到任何证书。"
                    sleep 2
                    continue
                fi
                
                local domains=()
                for domain_dir in "$AX_CERT_DIR"/*; do
                    if [ -d "$domain_dir" ]; then
                        domains+=($(basename "$domain_dir"))
                    fi
                done
                
                if [ ${#domains[@]} -eq 0 ]; then
                    yellow "没有找到任何证书。"
                    sleep 2
                    continue
                fi
                
                echo "已有证书的域名:"
                for i in "${!domains[@]}"; do
                    echo "$((i+1))) ${domains[$i]}"
                done
                read -p "选择要续订的域名编号: " cert_num
                
                if [[ "$cert_num" =~ ^[0-9]+$ ]] && [ "$cert_num" -ge 1 ] && [ "$cert_num" -le "${#domains[@]}" ]; then
                    local selected_domain="${domains[$((cert_num-1))]}"
                    log "正在续订 $selected_domain 的证书..."
                    if [ -f "$ACME_SH_INSTALL_DIR" ]; then
                        "$ACME_SH_INSTALL_DIR" --renew -d "$selected_domain" --ecc --force
                        green "证书续订完成！"
                    else
                        red "ACME.sh 未安装！"
                    fi
                else
                    red "无效的选择！"
                fi
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            3)
                # 删除证书
                if [ ! -d "$AX_CERT_DIR" ] || [ -z "$(ls -A $AX_CERT_DIR 2>/dev/null)" ]; then
                    yellow "没有找到任何证书。"
                    sleep 2
                    continue
                fi
                
                local domains=()
                for domain_dir in "$AX_CERT_DIR"/*; do
                    if [ -d "$domain_dir" ]; then
                        domains+=($(basename "$domain_dir"))
                    fi
                done
                
                if [ ${#domains[@]} -eq 0 ]; then
                    yellow "没有找到任何证书。"
                    sleep 2
                    continue
                fi
                
                echo "已有证书的域名:"
                for i in "${!domains[@]}"; do
                    echo "$((i+1))) ${domains[$i]}"
                done
                read -p "选择要删除的域名编号: " cert_num
                
                if [[ "$cert_num" =~ ^[0-9]+$ ]] && [ "$cert_num" -ge 1 ] && [ "$cert_num" -le "${#domains[@]}" ]; then
                    local selected_domain="${domains[$((cert_num-1))]}"
                    read -p "确认删除 $selected_domain 的证书？[y/N]: " confirm_del
                    if [[ "$confirm_del" == "y" || "$confirm_del" == "Y" ]]; then
                        rm -rf "$AX_CERT_DIR/$selected_domain"
                        if [ -f "$ACME_SH_INSTALL_DIR" ]; then
                            "$ACME_SH_INSTALL_DIR" --remove -d "$selected_domain" --ecc 2>/dev/null
                        fi
                        green "证书已删除！"
                    fi
                else
                    red "无效的选择！"
                fi
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            4)
                # 查看证书详情
                if [ ! -d "$AX_CERT_DIR" ] || [ -z "$(ls -A $AX_CERT_DIR 2>/dev/null)" ]; then
                    yellow "没有找到任何证书。"
                    sleep 2
                    continue
                fi
                
                for domain_dir in "$AX_CERT_DIR"/*; do
                    if [ -d "$domain_dir" ]; then
                        local domain=$(basename "$domain_dir")
                        local cert_file="$domain_dir/fullchain.cer"
                        
                        if [ -f "$cert_file" ]; then
                            echo "=================================="
                            cyan "[域名] $domain"
                            echo "----------------------------------"
                            if command -v openssl &>/dev/null; then
                                openssl x509 -in "$cert_file" -noout -dates -subject -issuer 2>/dev/null
                            fi
                            echo "证书位置: $cert_file"
                            echo "私钥位置: $domain_dir/private.key"
                            echo "=================================="
                            echo
                        fi
                    fi
                done
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            5)
                # 安装/重装 ACME.sh
                install_acme_sh_client
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            0)
                break
                ;;
            *)
                red "无效选择!"
                sleep 1
                ;;
        esac
    done
    trap - SIGINT
}


# 卸载所有
uninstall_all() {
    read -p "确认要卸载吗？(默认"否") [y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then 
        yellow "操作已取消。"
        return 1
    fi
    
    read -p "是否要执行彻底清理（删除所有配置文件和证书）？(默认"否") [y/N]: " nuke_choice
    log "开始卸载流程..."
    
    log "步骤 1: 停止并禁用所有相关服务..."
    systemctl stop "ax-kcptun@*.service" "ax-udp2raw@*.service" "ax-hysteria2@*.service" "ax-xray@*.service" "hysteria-server@*.service" 2>/dev/null
    systemctl disable "ax-kcptun@*.service" "ax-udp2raw@*.service" "ax-hysteria2@*.service" "ax-xray@*.service" "hysteria-server@*.service" 2>/dev/null
    green "服务已停止并禁用。"
    
    log "步骤 2: 删除所有 systemd 服务文件..."
    rm -f /etc/systemd/system/ax-kcptun@.service \
          /etc/systemd/system/ax-udp2raw@.service \
          /etc/systemd/system/ax-hysteria2@.service \
          /etc/systemd/system/ax-xray@.service \
          /etc/systemd/system/hysteria-server@*.service \
          /etc/systemd/system/kcptun@.service \
          /etc/systemd/system/udp2raw@.service \
          /etc/systemd/system/hysteria2@.service
    green "Systemd 服务文件已删除。"
    
    if [[ "$nuke_choice" == "y" || "$nuke_choice" == "Y" ]]; then
        log "步骤 3: 执行彻底清理..."
        rm -rf "$KCPTUN_INSTALL_DIR" "$UDP2RAW_INSTALL_DIR" "$HY2_INSTALL_DIR" "$XRAY_INSTALL_DIR" "$AX_CERT_DIR"
        green "程序和配置文件目录已删除。"
        
        log "步骤 4: 删除生成的证书..."
        rm -f /etc/ssl/private/bing.com.crt /etc/ssl/private/bing.com.key
        green "自签名证书已删除。"
        
        log "步骤 5: 删除 ACME.sh..."
        if [ -d "$HOME/.acme.sh" ]; then
            "$HOME/.acme.sh/acme.sh" --uninstall 2>/dev/null || true
            rm -rf "$HOME/.acme.sh"
            green "ACME.sh 已卸载。"
        fi
    else
        log "步骤 3: 执行软卸载 (仅删除二进制文件和 dat 文件)..."
        rm -f "$KCPTUN_INSTALL_DIR/kcptun_server" "$UDP2RAW_INSTALL_DIR/udp2raw"
        rm -f "$HY2_INSTALL_DIR/hysteria" "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat"
        rm -f "$XRAY_INSTALL_DIR/xray" "$XRAY_INSTALL_DIR/geoip.dat" "$XRAY_INSTALL_DIR/geosite.dat"
        green "程序文件已删除。"
    fi
    
    log "步骤 6: 清理残留的二进制文件..."
    rm -f /usr/local/bin/hysteria
    green "残留二进制文件已清理。"
    
    log "步骤 7: 清理临时文件..."
    rm -f /tmp/kcptun.tar.gz /tmp/udp2raw.tar.gz /tmp/xray.zip
    rm -f vps_optimizert.sh warp-socket5.sh 2>/dev/null
    
    log "步骤 8: 重载 systemd 并清理状态..."
    systemctl daemon-reload; systemctl reset-failed
    green "Systemd 已重载并清理。"
    
    echo
    green "==== 卸载完成！ ===="
    if [[ "$nuke_choice" == "y" || "$nuke_choice" == "Y" ]]; then
        cyan "已完全清理所有配置文件、证书和数据。"
    else
        cyan "已保留配置文件，仅删除程序文件。"
        yellow "提示：配置目录仍保留在："
        echo "  - $KCPTUN_INSTALL_DIR"
        echo "  - $UDP2RAW_INSTALL_DIR"
        echo "  - $HY2_INSTALL_DIR"
        echo "  - $XRAY_INSTALL_DIR"
        echo "  - $AX_CERT_DIR"
    fi
    yellow "提示：依赖包 (如 curl, openssl, jq) 未被卸载。"
    yellow "提示：请手动删除此脚本文件。"
    sleep 3
    return 0
}

# --- 18. 脚本入口与初始化  ---

# --- 系统兼容性检查函数 ---
check_system_compatibility() {
    # 检查是否为root用户
    if [[ $EUID -ne 0 ]]; then
        red "错误: 此脚本必须以root用户身份运行"
        exit 1
    fi
    
    # 检查系统是否使用systemd
    if ! command -v systemctl &> /dev/null; then
        red "错误: 此脚本需要systemd支持，但您的系统似乎没有安装systemd"
        exit 1
    fi
    
    # 检查必要的命令是否可用
    local required_commands=("curl" "wget" "jq" "openssl")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        yellow "警告: 以下必要命令在系统中不可用:"
        for cmd in "${missing_commands[@]}"; do
            echo "  - $cmd"
        done
        yellow "将尝试在初始化过程中安装这些依赖"
    fi
}

# 首次运行检查和安装核心程序
initial_check_and_install() {
    # 添加系统兼容性检查
    check_system_compatibility
    
    install_dependencies
    local has_configs=false
    if is_installed; then has_configs=true; fi
    
    # [REFACTORED] 检查根目录下的文件
    local kcp_udp_ok=true; if [[ ! -f "$KCPTUN_INSTALL_DIR/kcptun_server" || ! -f "$UDP2RAW_INSTALL_DIR/udp2raw" ]]; then kcp_udp_ok=false; fi
    local hy2_ok=true; if [[ ! -f "$HY2_INSTALL_DIR/hysteria" ]]; then hy2_ok=false; fi
    local xray_ok=true; if [[ ! -f "$XRAY_INSTALL_DIR/xray" ]]; then xray_ok=false; fi
    
    if [[ "$has_configs" == true && ( "$kcp_udp_ok" == false || "$hy2_ok" == false || "$xray_ok" == false ) ]]; then
        clear; yellow "检测到已存在的配置文件，但核心程序文件不完整。"; read -p "是否保留配置并仅重新安装核心程序？(默认“是”) [Y/n]: " choice
        if [[ "$choice" != "n" && "$choice" != "N" ]]; then
            log "正在重新安装核心程序..."
            [[ "$kcp_udp_ok" == false ]] && download_kcp_udp_binaries
            [[ "$hy2_ok" == false ]] && download_hysteria2_binary
            [[ "$xray_ok" == false ]] && download_xray_binary
            green "核心程序重装完成。"; sleep 2
        else
            uninstall_all; exit 0
        fi
    elif [[ "$kcp_udp_ok" == false || "$hy2_ok" == false || "$xray_ok" == false ]]; then
        clear; yellow "首次运行或程序不完整，需要下载核心程序文件。"; log "正在自动下载所有核心程序..."
        [[ "$kcp_udp_ok" == false ]] && (download_kcp_udp_binaries || { red "KCP/UDP 下载失败，退出。"; exit 1; })
        [[ "$hy2_ok" == false ]] && (download_hysteria2_binary || { red "Hysteria2 下载失败，退出。"; exit 1; })
        [[ "$xray_ok" == false ]] && (download_xray_binary || { red "Xray-core 下载失败，退出。"; exit 1; })
        green "核心程序准备就绪。"; sleep 1
        
        # 询问是否安装 ACME 证书工具
        echo
        read -p "是否安装 ACME.sh 证书管理工具？(推荐用于 Hysteria2/VLESS 真实证书) [Y/n]: " install_acme_choice
        install_acme_choice=${install_acme_choice:-y}
        if [[ "$install_acme_choice" == "y" || "$install_acme_choice" == "Y" ]]; then
            install_acme_sh_client && green "ACME.sh 安装成功！" || yellow "ACME.sh 安装失败，可稍后通过菜单安装。"
        fi
        
        # 询问是否安装 WARP
        echo
        read -p "是否安装 WARP-Socks5 分流工具？(推荐用于解锁流媒体) [Y/n]: " install_warp_choice
        install_warp_choice=${install_warp_choice:-y}
        if [[ "$install_warp_choice" == "y" || "$install_warp_choice" == "Y" ]]; then
            install_warp_yg && green "WARP 安装成功！" || yellow "WARP 安装失败，可稍后通过菜单安装。"
        fi
        
        sleep 2
    fi
    ensure_template_files; sleep 1
}

# 主菜单状态总览 (使用粗体标题)
show_status_summary() {
    local menu_index=21; echo "--- 当前状态 (输入序号可直接管理) ---"; if ! is_installed; then yellow "未安装任何组件。"; return; fi
    
    local ss_3_chain_instances=$(get_chain_instances_3)
    if [[ -n "$ss_3_chain_instances" ]]; then
        echo "$(bold "SS+KCP+UDP 串联实例:")"
        for i in $ss_3_chain_instances; do display_instance_status_line "ss_3_chain_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="ss_3_chain_chain"; menu_index=$((menu_index + 1)); done
    fi
    local hy2_chain_instances=$(get_chain_instances "hy2")
    if [[ -n "$hy2_chain_instances" ]]; then
        echo "$(bold "Hysteria2+UDP 串联实例:")"
        for i in $hy2_chain_instances; do display_instance_status_line "hy2_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="hy2_chain"; menu_index=$((menu_index + 1)); done
    fi
    local vless_chain_instances=$(get_chain_instances "vless")
    if [[ -n "$vless_chain_instances" ]]; then
        echo "$(bold "VLESS_mKCP+UDP 串联实例:")"
        for i in $vless_chain_instances; do display_instance_status_line "vless_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="vless_chain"; menu_index=$((menu_index + 1)); done
    fi

    for type in "Hysteria2" "VLESS+Reality" "VLESS+mKCP" "Shadowsocks" "UDP2RAW" "KCPTUN"; do
        local type_lowercase=""
        case "$type" in
            "Hysteria2") type_lowercase="hysteria2";;
            "VLESS+Reality") type_lowercase="xray_reality";;
            "VLESS+mKCP") type_lowercase="xray_mkcp";;
            "Shadowsocks") type_lowercase="xray_ss";;
            "UDP2RAW") type_lowercase="udp2raw";;
            "KCPTUN") type_lowercase="kcptun";;
        esac
        
        local standalone_instances=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#standalone_instances[@]} -gt 0 ]]; then
            echo "$(bold "${type} (独立) 实例:")"
            for i in "${standalone_instances[@]}"; do
                display_instance_status_line "$type_lowercase" "$i" "$menu_index) "
                QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="$type_lowercase"; menu_index=$((menu_index + 1))
            done
        fi
    done
}

# 主菜单 
main_menu(){
    declare -A QUICK_MANAGE_MAP_ID; declare -A QUICK_MANAGE_MAP_TYPE
    while true; do
        QUICK_MANAGE_MAP_ID=(); QUICK_MANAGE_MAP_TYPE=()
        trap '' SIGINT
        clear; echo "=================================="; echo "  多合一隧道管理脚本 V$SCRIPT_VERSION"; echo "=================================="
        cyan "--- 串联管理 ---"
        echo " 1) Hysteria2+UDP2RAW 串联"
        echo " 2) VLESS_mKCP+UDP2RAW 串联"
        echo " 3) Shadowsocks+KCP+UDP 串联"
        cyan "--- 独立实例管理 ---"
        echo " 4) Hysteria2"
        echo " 5) VLESS+Reality"
        echo " 6) VLESS+mKCP"
        echo " 7) Shadowsocks"
        cyan "--- 加速管理 ---"
        echo " 8) UDP2RAW"
        echo " 9) KCPTUN"
        echo "----------------------------------"
        cyan "--- 全局操作 ---"
        echo " 10) 查看全部配置"
        echo " 11) 重启全部服务"
        echo " 12) 检查更新程序" 
        cyan "--- 工具管理 ---"
        echo " 13) 优化VPS系统"
        echo " 14) 安装warp-Socks5"
        echo " 15) ACME证书管理"
        echo "----------------------------------"   
        echo " 99) 卸载"
        echo " 0) 退出"
        
        # --- [新] 全局 TLS 状态 (位于 0 和 "当前状态" 之间) ---
        echo "----------------------------------"
        show_global_tls_status
        # --- ACME 状态结束 ---
        
        echo "----------------------------------"
        show_status_summary
        local num_items=${#QUICK_MANAGE_MAP_ID[@]}; local max_index=$((20 + num_items))
        echo "----------------------------------"
        # [MODIFIED] 更改提示符范围
        local prompt="请选择 [0-15, 99"; if [[ $num_items -gt 0 ]]; then prompt+=", 21-${max_index}]"; else prompt+="]"; fi
        read -p "$prompt： " choice
        
        if [[ -n "${QUICK_MANAGE_MAP_ID[$choice]}" ]]; then
            local real_id="${QUICK_MANAGE_MAP_ID[$choice]}"; local type="${QUICK_MANAGE_MAP_TYPE[$choice]}"
            case "$type" in
                "ss_3_chain_chain") manage_chain_instance_3 "$real_id" ;;
                "hy2_chain") manage_chain_instance "hy2" "$real_id" ;;
                "vless_chain") manage_chain_instance "vless" "$real_id" ;;
                "hysteria2") manage_instance_menu "hysteria2" "$real_id" "hysteria2@${real_id}" "$HY2_INSTALL_DIR/hy2_${real_id}.yaml" ;;
                "xray_reality") manage_instance_menu "xray_reality" "$real_id" "ax-xray@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "xray_mkcp") manage_instance_menu "xray_mkcp" "$real_id" "ax-xray@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "xray_ss") manage_instance_menu "xray_ss" "$real_id" "ax-xray@${real_id}" "$XRAY_INSTALL_DIR/xray_${real_id}.json" ;;
                "udp2raw") manage_instance_menu "udp2raw" "$real_id" "udp2raw@${real_id}" "$UDP2RAW_INSTALL_DIR/udp2raw_${real_id}.conf" ;;
                "kcptun") manage_instance_menu "kcptun" "$real_id" "kcptun@${real_id}" "$KCPTUN_INSTALL_DIR/kcptun_${real_id}.json" ;;
            esac
            continue
        fi
        
        case $choice in
            1) chain_manager_menu "hy2" ;;
            2) chain_manager_menu "vless" ;;
            3) chain_manager_menu_3 ;;
            4) main_manager_loop "hysteria2" ;; 
            5) main_manager_loop "xray_reality" ;;
            6) main_manager_loop "xray_mkcp" ;; 
            7) main_manager_loop "xray_ss" ;;
            8) main_manager_loop "udp2raw" ;;
            9) main_manager_loop "kcptun" ;;
            10) view_all_configs; read -p $'\n按任意键返回...' -n1 -s;;
            11) restart_all_services ;;
            12) check_for_updates; read -p "按任意键继续..." -n1 -s ;;
            13) clear; install_sys_opt; read -p $'\n按任意键返回...' -n1 -s ;;
            14) clear; install_warp_yg; read -p $'\n按任意键返回...' -n1 -s ;;
            15) acme_certificate_menu ;;
            99) uninstall_all; if [[ $? -eq 0 ]]; then exit 0; fi ;;
            0) trap - SIGINT; exit 0 ;; 
            *) red "无效选择!"; sleep 1 ;;
        esac
    done
}

# --- 19. 脚本执行入口 ---
echo -e "\033[1;36m[INFO] 脚本启动... 当前版本: v${SCRIPT_VERSION}\033[0m"
sleep 2

# 捕获 Ctrl+C 信号，以便在脚本主体执行期间优雅退出
trap 'echo -e "\n\n${yellow}操作被中断，退出脚本。${reset}"; trap - SIGINT; exit 1' SIGINT
# 初始化检查和安装
initial_check_and_install
# 显示主菜单
main_menu
