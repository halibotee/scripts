#!/bin/bash
# Xray（Vless、SS）、Hysteria2, UDP2RAW 、 KCPTUN 实例管理脚本
# Generated by github.com/halibotee

# --- 全局变量配置 ---
SCRIPT_VERSION="1.3.7"

# 安装目录配置
KCPTUN_INSTALL_DIR="/etc/kcptun"
UDP2RAW_INSTALL_DIR="/etc/udp2raw"
HY2_INSTALL_DIR="/etc/hysteria2"
XRAY_INSTALL_DIR="/etc/xray"

# ACME 证书相关路径
ACME_SH_INSTALL_DIR="/root/.acme.sh/acme.sh"
AX_CERT_DIR="/etc/ax-certs"

# Systemd 服务模板路径
KCPTUN_TEMPLATE_FILE="/etc/systemd/system/ax-kcptun@.service"
UDP2RAW_TEMPLATE_FILE="/etc/systemd/system/ax-udp2raw@.service"
HY2_TEMPLATE_FILE="/etc/systemd/system/ax-hysteria2@.service"
XRAY_TEMPLATE_FILE="/etc/systemd/system/ax-xray@.service"

# 网络默认配置
PUBLIC_IP=""  # 公网IP地址（自动获取）
DEFAULT_LISTEN_ADDR="0.0.0.0"  # 默认监听地址
DEFAULT_TARGET_ADDR="127.0.0.1"  # 默认目标地址
RANDOM_PORT_MIN=10000  # 随机端口范围最小值
RANDOM_PORT_MAX=65535  # 随机端口范围最大值
PUBLIC_IP_SERVICE_1="ip.sb"  # 公网IP查询服务1
PUBLIC_IP_SERVICE_2="ipinfo.io/ip"  # 公网IP查询服务2

# Hysteria2 默认配置
HY2_SNI="bing.com"  # 默认SNI（自签名证书使用）
HY2_CERT_PATH="/etc/ssl/private/${HY2_SNI}.crt"  # 自签名证书路径
HY2_KEY_PATH="/etc/ssl/private/${HY2_SNI}.key"  # 自签名密钥路径
HY2_MASQUERADE_URL="https://www.bing.com"  # 伪装网站URL
HY2_CLIENT_INSECURE="1"  # 客户端不验证证书（自签名时使用）

# Xray VLESS 默认配置
XRAY_REALITY_DEFAULT_SNI="www.apple.com"  # Reality默认SNI
XRAY_REALITY_DEFAULT_FP="chrome"  # Reality指纹伪装
XRAY_REALITY_DEFAULT_TARGET="www.apple.com:443"  # Reality目标地址
XRAY_REALITY_DEFAULT_FLOW="xtls-rprx-vision"  # Reality流控模式
KCPTUN_DEFAULT_MODE="fast3"  # KCPTUN默认模式
SS_DEFAULT_METHOD="2022-blake3-aes-256-gcm"  # Shadowsocks默认加密方式

# WARP 分流配置
DEFAULT_WARP_SOCKS_ADDR="127.0.0.1"  # WARP SOCKS5代理地址
DEFAULT_WARP_SOCKS_PORT="40000"  # WARP SOCKS5代理端口
WARP_GEOSITE_LIST_JSON='"geosite:google","geosite:openai","geosite:perplexity"'
WARP_GEOSITE_LIST_YAML='- warp(suffix:ip-api.com)
    - warp(geosite:google)
    - warp(geoip:google)
    - warp(suffix:google.com)
    - warp(geosite:openai)
    - warp(suffix:openai.com)
    - warp(suffix:chatgpt.com)
    - warp(geosite:perplexity)
    - warp(suffix:perplexity.com)'

# 软件源配置
KCPTUN_REPO="xtaci/kcptun"
UDP2RAW_REPO="wangyu-/udp2raw"
HY2_REPO="apernet/hysteria"
XRAY_REPO="XTLS/Xray-core"
GITHUB_API_URL="https://api.github.com/repos"
GITHUB_URL="https://github.com"

# 客户端默认监听端口（用于生成客户端配置示例）
CLIENT_KCPTUN_LISTEN_ADDR="127.0.0.1:1091"  # KCPTUN客户端监听地址
CLIENT_UDP2RAW_LISTEN_ADDR="127.0.0.1:1093"  # UDP2RAW客户端监听地址
CLIENT_VLESS_UDP2RAW_LISTEN_ADDR="127.0.0.1:1094"  # VLESS+UDP2RAW客户端监听地址
CLIENT_SS_3_CHAIN_KCP_TARGET="127.0.0.1:1095"  # SS三层串联KCPTUN目标地址
CLIENT_SS_3_CHAIN_SS_TARGET="127.0.0.1:1096"  # SS三层串联SS目标地址

UDP2RAW_COMMON_ARGS="--raw-mode faketcp --cipher-mode aes128cbc --auth-mode hmac_sha1 --seq-mode 4 -a --keep-rule --fix-gro"
UDP2RAW_CLIENT_BASE_ARGS="-c ${UDP2RAW_COMMON_ARGS}"

# --- 配置文件模板 ---

# KCPTUN 配置文件模板
read -r -d '' KCPTUN_CONFIG_JSON_TEMPLATE <<'EOM'
{
    "listen": "__LISTEN__", "target": "__TARGET__", "key": "__KEY__", "crypt": "__CRYPT__", "mode": "__MODE__", "smuxver": 2, "mtu": __MTU__, "sndwnd": __SNDWND__, "rcvwnd": __RCVWND__, "datashard": __DATASHARD__, "parityshard": __PARITYSHARD__, "dscp": 46, "nocomp": true, "acknodelay": false, "nodelay": 1, "interval": 20, "resend": 2, "nc": 1, "sockbuf": 16777217, "smuxbuf": 16777217, "streambuf": 4194304, "keepalive": 5, "autoexpire": 600, "quiet": false, "tcp": __TCP__
}
EOM

# UDP2RAW 配置文件模板
read -r -d '' UDP2RAW_CONFIG_TEMPLATE <<'EOM'
-s
-l __LISTEN_ADDR__
-r __TARGET_ADDR__
-k __PASSWORD__
--raw-mode __RAW_MODE__
--cipher-mode __CIPHER_MODE__
--auth-mode __AUTH_MODE__
--seq-mode 4
-a
--keep-rule
--fix-gro
EOM

# Hysteria2 配置文件模板
read -r -d '' HYSTERIA2_CONFIG_YAML_TEMPLATE <<'EOM'
listen: __LISTEN__
tls:
  cert: __CERT_PATH__
  key: __KEY_PATH__
auth:
  type: password
  password: __PASSWORD__
masquerade:
  type: proxy
  proxy:
    url: https://www.macbed.com
    rewriteHost: true
    insecure: false
ignoreClientBandwidth: __IGNORE_BW__
sniff:
  enable: true
  timeout: 2s
  rewriteDomain: true
  tcpPorts: 80,443,8000-9000
  __UDP_SNIFF_CONFIG__
__OUTBOUNDS_AND_ACL__
EOM

# Hysteria2 WARP 分流 ACL
read -r -d '' HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK <<'EOM'
outbounds:
  - name: warp
    type: socks5
    socks5:
      addr: __WARP_SOCKS5_ADDR__
      udp: false
acl:
  inline:
    __WARP_GEOSITE_LIST_YAML__
    - direct(all)
EOM
HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_GEOSITE_LIST_YAML__/$WARP_GEOSITE_LIST_YAML}"

# Hysteria2 直连 ACL
read -r -d '' HYSTERIA2_DIRECT_ACL_BLOCK <<'EOM'
acl:
  inline:
    - direct(all)
EOM

# Xray VLESS+Reality 配置文件模板
read -r -d '' XRAY_VLESS_REALITY_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [
        {
            "listen": null,
            "port": __LISTEN_PORT__,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "__UUID__",
                        "flow": "__REALITY_FLOW__"
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "fingerprint": "__FINGERPRINT__",
                    "target": "__TARGET__",
                    "xver": 0,
                    "serverNames": [
                        "__SNI__"
                    ],
                    "privateKey": "__PRIVATE_KEY__",
                    "publicKey": "__PUBLIC_KEY__",
                    "minClientVer": "",
                    "maxClientVer": "",
                    "maxTimeDiff": 60000,
                    "shortIds": [
                        "__SHORT_ID__"
                    ]
                },
                "tcpSettings": {
                    "header": {
                        "type": "none"
                    }
                }
            },
            "tag": "inbound-__LISTEN_PORT__",
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls",
                    "quic"
                ]
            }
        }
    ],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# Xray VLESS+mKCP 配置文件模板
read -r -d '' XRAY_VLESS_MKCP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "vless",
        "settings": {
            "clients": [{ "id": "__UUID__" }],
            "decryption": "none"
        },
        "streamSettings": {
            "network": "kcp",
            "kcpSettings": {
                "mtu": __MTU__, "tti": __TTI__, "uplinkCapacity": __UPLINK__, "downlinkCapacity": __DOWNLINK__, "congestion": __CONGESTION__, "readBufferSize": __READ_BUF__, "writeBufferSize": __WRITE_BUF__,
                "header": { "type": "__HEADER_TYPE__" },
                "seed": "__MKCP_SEED__"
            }
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# Xray Shadowsocks 配置文件模板
read -r -d '' XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE <<'EOM'
{
    "log": { "loglevel": "warning" },
    "inbounds": [{
        "listen": "__LISTEN_ADDR__",
        "port": __LISTEN_PORT__,
        "protocol": "shadowsocks",
        "settings": {
            "method": "__SS_METHOD__",
            "password": "__SS_PASSWORD__",
            "network": "tcp,udp"
        },
        "sniffing": { "enabled": true, "destOverride": [ "http", "tls" ] }
    }],
    __OUTBOUNDS_AND_ROUTING__
}
EOM

# Xray WARP 分流路由配置
read -r -d '' XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "socks", "tag": "warp", "settings": { "servers": [{ "address": "__WARP_SOCKS5_ADDR__", "port": __WARP_SOCKS5_PORT__ }] } },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
        { "type": "field", "outboundTag": "warp", "domain": [ __WARP_GEOSITE_LIST_JSON__ ] },
        { "type": "field", "outboundTag": "warp", "domain": [ "suffix:ip-api.com" ] },
        { "type": "field", "outboundTag": "block", "domain": [ "geosite:category-ads-all" ] }
    ]
}
EOM
XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK="${XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK//__WARP_GEOSITE_LIST_JSON__/$WARP_GEOSITE_LIST_JSON}"

# Xray 直连路由配置
read -r -d '' XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK <<'EOM'
"outbounds": [
    { "protocol": "freedom", "tag": "direct" },
    { "protocol": "blackhole", "tag": "block" }
],
"routing": { "rules": [ { "type": "field", "outboundTag": "direct", "network": "tcp,udp" } ] }
EOM


# --- 辅助工具函数 ---

# 绿色
green(){ echo -e "\033[0;32m$1\033[0m"; }
# 红色
red(){ echo -e "\033[0;31m$1\033[0m"; }
# 黄色 (橙色)
yellow(){ echo -e "\033[0;33m$1\033[0m"; }
# 青色
cyan(){ echo -e "\033[0;36m$1\033[0m"; }
# 粗体 (默认色)
bold(){ echo -e "\033[1m$1\033[0m"; }
# 淡化 (灰色)
dim(){ echo -e "\033[2m$1\033[0m"; }
# 日志格式
log(){ echo -e "[$(date '+%H:%M:%S')] $(bold "$1")"; }
# 检查是否已安装任何实例
is_installed(){ ls "$KCPTUN_INSTALL_DIR"/*.json >/dev/null 2>&1 || ls "$UDP2RAW_INSTALL_DIR"/*.conf >/dev/null 2>&1 || ls "$HY2_INSTALL_DIR"/*.yaml >/dev/null 2>&1 || ls "$XRAY_INSTALL_DIR"/*.json >/dev/null 2>&1; }

# 获取公网 IP 地址
get_public_ip() {
    if [[ -n "$PUBLIC_IP" ]]; then echo "$PUBLIC_IP"; return; fi
    PUBLIC_IP=$(curl -s4m2 $PUBLIC_IP_SERVICE_1 || curl -s4m2 $PUBLIC_IP_SERVICE_2)
    if [[ -z "$PUBLIC_IP" ]]; then yellow "无法自动获取公网 IP，请手动输入或检查网络。"; read -p "请输入公网 IP: " PUBLIC_IP; if [[ -z "$PUBLIC_IP" ]]; then red "错误：必须提供 IP。"; exit 1; fi; fi
    echo "$PUBLIC_IP"
}

# 安装脚本所需的核心依赖
install_dependencies(){
    local packages_to_install=()
    ! command -v curl &>/dev/null && packages_to_install+=("curl")
    ! command -v wget &>/dev/null && packages_to_install+=("wget")
    ! command -v tar &>/dev/null && packages_to_install+=("tar")
    ! command -v unzip &>/dev/null && packages_to_install+=("unzip")
    ! command -v nano &>/dev/null && packages_to_install+=("nano")
    ! command -v iptables &>/dev/null && packages_to_install+=("iptables")
    ! command -v uuidgen &>/dev/null && packages_to_install+=("uuid-runtime")
    ! command -v openssl &>/dev/null && packages_to_install+=("openssl")
    ! command -v jq &>/dev/null && packages_to_install+=("jq")
    ! command -v socat &>/dev/null && packages_to_install+=("socat" "lsof")

    # ACME DNS 模式依赖
    if ! command -v dig &>/dev/null; then
        if command -v apt-get &>/dev/null; then
            packages_to_install+=("dnsutils")
        elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then
            packages_to_install+=("bind-utils")
        fi
    fi

    if [ ${#packages_to_install[@]} -gt 0 ]; then
        log "更新软件包列表并安装核心依赖: ${packages_to_install[*]}..."
        (apt-get update && apt-get install -y "${packages_to_install[@]}") >/dev/null 2>&1 || \
        (yum install -y epel-release && yum install -y "${packages_to_install[@]}") >/dev/null 2>&1 || \
        (dnf install -y "${packages_to_install[@]}") >/dev/null 2>&1
    fi
}

# 带重试功能的下载函数
download_with_retry(){
    local url=$1 output=$2 retries=3 timeout=15
    for ((i=1; i<=retries; i++)); do
        log "下载 ($i/$retries)：$url"
        curl -L --connect-timeout 5 --max-time $timeout -o "$output" "$url" && return 0
        yellow "下载失败，正在重试..."
    done
    red "下载失败超过 $retries 次，请检查网络。"
    return 1
}

# 查找一个未被占用的随机端口
find_available_port() {
    local port
    while true; do
        port=$(( RANDOM % (RANDOM_PORT_MAX - RANDOM_PORT_MIN + 1) + RANDOM_PORT_MIN ))
        if ! check_port_occupied "$port"; then
            echo "$port"
            return
        fi
    done
}

# 通用服务部署函数
deploy_service_instance() {
    local service_name=$1
    local conf_path=$2
    local config_content=$3
    
    log "正在写入配置文件..."
    echo "$config_content" > "$conf_path"
    
    sync
    log "启动服务: $service_name ..."
    systemctl enable --now "$service_name"
    sleep 1
    
    if systemctl is-active --quiet "$service_name"; then
        green "服务 $service_name 已成功启动！"
        return 0
    else
        red "服务 $service_name 启动失败！请检查日志。"
        return 1
    fi
}

# 检查端口是否被占用
check_port_occupied() {
    local port=$1
    if ss -tuln | grep -q ":${port} "; then
        return 0 # Occupied
    else
        return 1 # Free
    fi
}

# 通用输入读取函数
read_input() {
    local prompt="$1"
    local default_value="$2"
    local input_var
    
    if [[ -n "$default_value" ]]; then
        read -p "${prompt} (默认: ${default_value}): " input_var
        echo "${input_var:-$default_value}"
    else
        read -p "${prompt}: " input_var
        echo "$input_var"
    fi
}

# 读取带选项的输入
# 用法: read_input_with_options "提示信息" "默认选项(数字)" "选项1描述" "选项2描述" ...
read_input_with_options() {
    local prompt="$1"
    local default_index="$2"
    shift 2
    local options=("$@")
    
    echo "$prompt" >&2
    for i in "${!options[@]}"; do
        echo "  $((i+1)). ${options[$i]}" >&2
    done
    
    local choice
    read -p "请选择 [1-${#options[@]}] (默认: $default_index): " choice
    choice="${choice:-$default_index}"
    
    if [[ ! "$choice" =~ ^[0-9]+$ ]] || (( choice < 1 || choice > ${#options[@]} )); then
        echo "$default_index" # Invalid input, return default
    else
        echo "$choice"
    fi
}

# 检查单个服务状态
check_service_status() {
    local service_name=$1
    if systemctl is-active --quiet "$service_name"; then
        echo "运行中"
    else
        echo "未运行"
    fi
}

# 检查多个服务状态 (全部运行才算运行中)
check_services_status() {
    local services=("$@")
    local all_active=true
    local status_details=""
    
    for service in "${services[@]}"; do
        local status=$(check_service_status "$service")
        status_details+="${status} "
        if [[ "$status" != "运行中" ]]; then
            all_active=false
        fi
    done
    
    if $all_active; then
        echo "cyan ${status_details}"
    else
        echo "yellow ${status_details}"
    fi
}

# 生成强密码 (UUID)
generate_strong_password() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    else
        log "uuidgen 未找到，生成备用 UUID..." >&2
        hexdump -n 16 -v -e '4/4 "%08x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 2/2 "%04x" "-" 6/6 "%012x"' /dev/urandom | head -c 36
    fi
}
# 生成 Hysteria2 自签名证书
generate_self_signed_cert() {
    if [[ -s "$HY2_CERT_PATH" && -s "$HY2_KEY_PATH" ]]; then return; fi
    log "正在为 ${HY2_SNI} 生成自签名证书..."
    mkdir -p "$(dirname "$HY2_KEY_PATH")"
    openssl ecparam -name prime256v1 -genkey -noout -out "$HY2_KEY_PATH"
    chmod 600 "$HY2_KEY_PATH"
    if [[ $? -ne 0 ]]; then red "错误: openssl ecparam 命令执行失败。"; exit 1; fi
    openssl req -new -x509 -days 36500 -key "$HY2_KEY_PATH" -out "$HY2_CERT_PATH" -subj "/CN=${HY2_SNI}" -nodes
    if [[ $? -ne 0 ]]; then red "错误: openssl req 命令执行失败。"; exit 1; fi
    if [[ ! -s "$HY2_CERT_PATH" || ! -s "$HY2_KEY_PATH" ]]; then red "错误: 证书文件生成失败或为空！"; exit 1; fi
    green "证书生成完毕。"
}

# 处理密码输入 (支持自动生成和保存)
handle_password_input() {
    local service_type=$1
    local ss_method=$2
    local pass_file
    local last_pass=""
    
    # 确定文件路径
    case "$service_type" in
        kcptun) mkdir -p "$KCPTUN_INSTALL_DIR"; pass_file="$KCPTUN_INSTALL_DIR/last_kcptun_pass.txt" ;;
        udp2raw) mkdir -p "$UDP2RAW_INSTALL_DIR"; pass_file="$UDP2RAW_INSTALL_DIR/last_udp2raw_pass.txt" ;;
        hysteria2) mkdir -p "$HY2_INSTALL_DIR"; pass_file="$HY2_INSTALL_DIR/last_hy2_pass.txt" ;;
        xray_mkcp) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_xray_mkcp_seed.txt" ;;
        shadowsocks) mkdir -p "$XRAY_INSTALL_DIR"; pass_file="$XRAY_INSTALL_DIR/last_ss_pass.txt" ;;
    esac
    
    if [[ -f "$pass_file" ]]; then last_pass=$(cat "$pass_file"); fi

    # 提示文本
    local prompt_label="密码"
    if [[ "$service_type" == "shadowsocks" ]]; then prompt_label="Base64 密钥"; fi
    if [[ "$service_type" == "xray_mkcp" ]]; then prompt_label="mKCP Seed"; fi

    echo "请选择 ${prompt_label} 生成方式:"
    local options=("自动生成 ${prompt_label}")
    local default_opt="1"
    
    if [[ -n "$last_pass" ]]; then
        options+=("保留原有 ${prompt_label} (当前: ${last_pass:0:10}...)")
        default_opt="1" # 依然默认自动，或者用户习惯保留? 用户原话默认1(自动)
    fi
    options+=("手动输入 ${prompt_label}")
    
    local choice_idx=$(read_input_with_options "请选择 [1-${#options[@]}]" "$default_opt" "${options[@]}")
    
    # 映射选择到逻辑
    # options下标从0开始，但read_input返回 1,2,3
    # 如果有 last_pass: 1=Auto, 2=Keep, 3=Manual
    # 如果无 last_pass: 1=Auto, 2=Manual
    
    local final_password=""
    local is_manual=false
    
    if [[ -n "$last_pass" ]]; then
        if [[ "$choice_idx" == "1" ]]; then is_manual=false; # Auto
        elif [[ "$choice_idx" == "2" ]]; then final_password="$last_pass"; # Keep
        else is_manual=true; fi # Manual
    else
        if [[ "$choice_idx" == "1" ]]; then is_manual=false; # Auto
        else is_manual=true; fi # Manual
    fi

    if [[ "$is_manual" == "true" ]]; then
        read -p "请输入 ${prompt_label}: " final_password
        if [[ -z "$final_password" ]]; then red "输入不能为空！"; return 1; fi
    elif [[ -z "$final_password" ]]; then
        # 执行自动生成
        if [[ "$service_type" == "shadowsocks" ]]; then
            local key_length=32 # 默认 32 (2022-blake3-aes-256-gcm / chacha20)
            # 根据 method 判断长度
            if [[ "$ss_method" == *"aes-128-gcm"* ]]; then
                key_length=16
            fi
            # 检查是否需要 Base64 (SS-2022 强制需要，旧版可以用任意字符串但 Base64 兼容性最好)
            if ! command -v openssl &>/dev/null; then
                red "错误: 未找到 openssl，无法生成密钥。"
                final_password=$(generate_strong_password)
            else
                final_password=$(openssl rand -base64 $key_length)
            fi
            green "已自动生成 Shadowsocks 密钥: $final_password" >&2
        else
            final_password=$(generate_strong_password)
            green "已自动生成随机密码: $final_password" >&2
        fi
    fi

    # 保存并返回
    echo "$final_password" > "$pass_file"
    chmod 600 "$pass_file"
    echo "$final_password"
}

find_next_available_id() {
    local type=$1; local dir file_prefix file_ext; local i=1
    case "$type" in
        hysteria2) dir="$HY2_INSTALL_DIR"; file_prefix="hy2"; file_ext="yaml";;
        udp2raw) dir="$UDP2RAW_INSTALL_DIR"; file_prefix="udp2raw"; file_ext="conf";;
        kcptun) dir="$KCPTUN_INSTALL_DIR"; file_prefix="kcptun"; file_ext="json";;
        xray) dir="$XRAY_INSTALL_DIR"; file_prefix="xray"; file_ext="json";;
    esac
    while true; do
        if [[ ! -f "$dir/${file_prefix}_${i}.${file_ext}" && ! -f "$dir/${file_prefix}_c${i}.${file_ext}" && ! -f "$dir/${file_prefix}_vc${i}.${file_ext}" && ! -f "$dir/${file_prefix}_s3c${i}.${file_ext}" ]]; then
            echo "$i"; return
        fi
        i=$((i + 1))
    done
}

# --- ACME 证书管理函数 ---

# 安装 acme.sh 客户端
install_acme_sh_client() {
    if [ -f "$ACME_SH_INSTALL_DIR" ]; then
        return 0 # 已安装
    fi
    log "正在安装 acme.sh 证书客户端..."
    
    local Aemail=$(read_input "请输入注册 ACME 所需的邮箱 (回车自动生成)" "")
    if [ -z "$Aemail" ]; then
        local auto_email=$(date +%s%N | md5sum | cut -c 1-8)
        Aemail="$auto_email@gmail.com"
        yellow "已为您自动生成邮箱: $Aemail"
    fi

    # 使用 get.acme.sh 官方安装
    curl https://get.acme.sh | sh -s email=$Aemail
    if [ ! -f "$ACME_SH_INSTALL_DIR" ]; then
        red "acme.sh 客户端安装失败！"
        return 1
    fi
    
    "$ACME_SH_INSTALL_DIR" --upgrade --auto-upgrade
    "$ACME_SH_INSTALL_DIR" --set-default-ca --server letsencrypt
    green "acme.sh 客户端安装完成。"
}

# 检查并释放 80 端口 (用于 ACME Standalone 模式)
release_80_port() {
    log "正在检查 80 端口占用..."
    local pid=$(lsof -t -i:80)
    if [ -n "$pid" ]; then
        yellow "警告: 80 端口被进程 $pid 占用。"
        read -p "是否尝试强行释放 80 端口? (默认“否”) [Y/n]: " kill_confirm
        kill_confirm=${kill_confirm:-n}
        if [[ "$kill_confirm" == "y" || "$kill_confirm" == "Y" ]]; then
            log "正在强行释放 80 端口..."
            kill -9 $pid
            sleep 2
            if lsof -t -i:80 >/dev/null; then
                red "80 端口释放失败！"
                return 1
            else
                green "80 端口已释放。"
            fi
        else
            red "80 端口被占用，ACME Standalone 模式无法继续。"
            return 1
        fi
    fi
    return 0
}

# 获取或续订证书 (支持 DNS API 和 Standalone)
ax_get_certificate() {
    local domain=$1
    local cert_dir="$AX_CERT_DIR/$domain"
    
    # 1. 检查证书是否已存在且有效
    if [ -f "$cert_dir/fullchain.cer" ]; then
        log "证书 $domain 已存在于 $cert_dir"
        return 0
    fi
    
    # 2. 确保 acme.sh 客户端已安装
    install_acme_sh_client || return 1
    
    # 3. 检查 DNS 解析
    log "正在验证 $domain 的 DNS 解析..."
    local v4=$(curl -s4m2 $PUBLIC_IP_SERVICE_1 || curl -s4m2 $PUBLIC_IP_SERVICE_2)
    local v6=$(curl -s6m2 $PUBLIC_IP_SERVICE_1 || curl -s6m2 $PUBLIC_IP_SERVICE_2)
    local domainIP=$(dig @8.8.8.8 +time=2 +short "$domain" 2>/dev/null | grep -m1 '^[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+$')
    
    if [[ -z "$domainIP" && -n "$v6" ]]; then
        domainIP=$(dig @2001:4860:4860::8888 +time=2 aaaa +short "$domain" 2>/dev/null | grep -m1 ':')
    fi
    
    if [[ -z "$domainIP" ]]; then
        red "错误: 无法解析 $domain 的 IP 地址。"
        return 1
    fi
    
    if [[ "$domainIP" != "$v4" && "$domainIP" != "$v6" ]]; then
        red "错误: $domain 解析的 IP ($domainIP) 与本机 IP ($v4 / $v6) 不匹配！"
        yellow "请确保 DNS 记录已正确设置，且 CDN (小黄云) 已关闭。"
        return 1
    fi
    green "DNS 验证通过: $domain -> $domainIP"

    # 4. 选择 ACME 模式
    read -p "选择 ACME 验证模式: [1] 80 端口 (Standalone) [2] DNS API (推荐): " acme_mode
    local issue_cmd=""

    if [ "$acme_mode" == "1" ]; then
        # 80 端口模式
        release_80_port || return 1
        local listen_opt=""
        if [[ "$domainIP" == "$v6" ]]; then
            listen_opt="--listen-v6"
        fi
        issue_cmd="$ACME_SH_INSTALL_DIR --issue -d $domain --standalone -k ec-256 $listen_opt"
    
    elif [ "$acme_mode" == "2" ]; then
        # DNS API 模式
        read -p "选择 DNS 服务商: [1] Cloudflare [2] DNSPod [3] Aliyun: " dns_provider
        local dns_api_cmd=""
        yellow "警告: API 密钥将保存在 acme.sh 配置中 (~/.acme.sh/account.conf)"
        
        case $dns_provider in
            1) # Cloudflare
                read -s -p "请输入 Cloudflare Global API Key: " GAK; echo
                export CF_Key="$GAK"
                read -p "请输入 Cloudflare 注册邮箱: " CFemail
                export CF_Email="$CFemail"
                dns_api_cmd="--dns dns_cf"
                ;;
            2) # DNSPod
                read -s -p "请输入 DNSPod DP_Id: " DPID; echo
                export DP_Id="$DPID"
                read -s -p "请输入 DNSPod DP_Key: " DPKEY; echo
                export DP_Key="$DPKEY"
                dns_api_cmd="--dns dns_dp"
                ;;
            3) # Aliyun
                read -s -p "请输入 Aliyun Ali_Key: " ALKEY; echo
                export Ali_Key="$ALKEY"
                read -s -p "请输入 Aliyun Ali_Secret: " ALSER; echo
                export Ali_Secret="$ALSER"
                dns_api_cmd="--dns dns_ali"
                ;;
            *)
                red "无效的服务商选择。"
                return 1
                ;;
        esac
        issue_cmd="$ACME_SH_INSTALL_DIR --issue -d $domain $dns_api_cmd -k ec-256"
    
    else
        red "无效的模式选择。"
        return 1
    fi

    # 5. 执行申请
    log "正在执行 ACME 证书申请，请稍候..."
    eval $issue_cmd
    if [ $? -ne 0 ]; then
        red "ACME 证书申请失败！"
        return 1
    fi
    
    # 6. 安装证书到 ax 目录
    log "正在安装证书到 $cert_dir ..."
    mkdir -p "$cert_dir"
    "$ACME_SH_INSTALL_DIR" --install-cert -d "$domain" --ecc \
        --fullchain-file "$cert_dir/fullchain.cer" \
        --key-file "$cert_dir/private.key"
        
    if [ -f "$cert_dir/fullchain.cer" ]; then
        green "证书 $domain 已成功安装到 $cert_dir"
        # 确保 cron 任务已设置
        "$ACME_SH_INSTALL_DIR" --cron -f >/dev/null 2>&1
        return 0
    else
        red "证书安装失败！"
        return 1
    fi
}


# --- 核心程序下载函数 ---

get_latest_github_tag() {
    local repo_name=$1
    # 使用 jq 获取最新 tag
    curl -s "$GITHUB_API_URL/$repo_name/releases/latest" | jq -r .tag_name
}

# 下载 KCPTUN 和 UDP2RAW
download_kcp_udp_binaries(){
    KCPTUN_LATEST=$(get_latest_github_tag "$KCPTUN_REPO")
    UDP2RAW_LATEST=$(get_latest_github_tag "$UDP2RAW_REPO")
    if [[ -z "$KCPTUN_LATEST" || -z "$UDP2RAW_LATEST" ]]; then red "获取 KCPTUN/UDP2RAW 版本号失败。"; return 1; fi
    mkdir -p "$KCPTUN_INSTALL_DIR" "$UDP2RAW_INSTALL_DIR"
    
    log "下载 KCPTUN ($KCPTUN_LATEST)..."
    download_with_retry "$GITHUB_URL/$KCPTUN_REPO/releases/download/${KCPTUN_LATEST}/kcptun-linux-amd64-$(echo $KCPTUN_LATEST | sed 's/v//').tar.gz" /tmp/kcptun.tar.gz && \
    tar -xzf /tmp/kcptun.tar.gz -C "$KCPTUN_INSTALL_DIR" server_linux_amd64 && mv "$KCPTUN_INSTALL_DIR/server_linux_amd64" "$KCPTUN_INSTALL_DIR/kcptun_server" || { red "KCPTUN 解压或移动失败。"; return 1; }
    
    log "下载 UDP2RAW ($UDP2RAW_LATEST)..."
    download_with_retry "$GITHUB_URL/$UDP2RAW_REPO/releases/download/${UDP2RAW_LATEST}/udp2raw_binaries.tar.gz" /tmp/udp2raw.tar.gz && \
    tar -xzf /tmp/udp2raw.tar.gz -C "$UDP2RAW_INSTALL_DIR" udp2raw_amd64 && mv "$UDP2RAW_INSTALL_DIR/udp2raw_amd64" "$UDP2RAW_INSTALL_DIR/udp2raw" || { red "UDP2RAW 解压或移动失败。"; return 1; }
    
    chmod +x "$KCPTUN_INSTALL_DIR/kcptun_server" "$UDP2RAW_INSTALL_DIR/udp2raw"
}

# 下载 Hysteria2
download_hysteria2_binary(){
    HY2_LATEST=$(get_latest_github_tag "$HY2_REPO")
    if [[ -z "$HY2_LATEST" ]]; then red "获取 Hysteria2 版本号失败。"; return 1; fi
    mkdir -p "$HY2_INSTALL_DIR"
    log "下载 Hysteria2 ($HY2_LATEST)..."
    local hy2_url="$GITHUB_URL/$HY2_REPO/releases/download/${HY2_LATEST}/hysteria-linux-amd64"
    download_with_retry "$hy2_url" "$HY2_INSTALL_DIR/hysteria" || { red "Hysteria2 下载失败。"; return 1; }
    chmod +x "$HY2_INSTALL_DIR/hysteria"
}

# 下载 Xray-core
download_xray_binary(){
    XRAY_LATEST=$(get_latest_github_tag "$XRAY_REPO")
    if [[ -z "$XRAY_LATEST" ]]; then red "获取 Xray-core 版本号失败。"; return 1; fi
    mkdir -p "$XRAY_INSTALL_DIR"
    log "下载 Xray-core ($XRAY_LATEST)..."
    local xray_url="$GITHUB_URL/$XRAY_REPO/releases/download/${XRAY_LATEST}/Xray-linux-64.zip"
    download_with_retry "$xray_url" /tmp/xray.zip || { red "Xray-core 下载失败。"; return 1; }
    unzip -o /tmp/xray.zip -d "$XRAY_INSTALL_DIR" xray geoip.dat geosite.dat || { red "Xray-core 解压失败。"; return 1; }
    chmod +x "$XRAY_INSTALL_DIR/xray"
    
    # 复制 geo dat 文件到 Hysteria2 根目录
    log "正在复制 geoip.dat / geosite.dat 到 Hysteria2 目录..."
    cp -n "$XRAY_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    cp -n "$XRAY_INSTALL_DIR/geosite.dat" "$HY2_INSTALL_DIR/" 2>/dev/null
    chmod 644 "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat" 2>/dev/null
}

# --- Systemd 与服务状态管理 ---

# 确保所有 Systemd 模板文件都存在
ensure_template_files() {
    local changed=0
    if [[ ! -f "$KCPTUN_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$KCPTUN_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=KCPTUN Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$KCPTUN_INSTALL_DIR/kcptun_server -c $KCPTUN_INSTALL_DIR/kcptun_%i.json
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$UDP2RAW_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$UDP2RAW_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=UDP2RAW Instance Server (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$UDP2RAW_INSTALL_DIR/udp2raw --conf-file $UDP2RAW_INSTALL_DIR/udp2raw_%i.conf
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$HY2_TEMPLATE_FILE" ]]; then
        changed=1
        generate_self_signed_cert
        cat > "$HY2_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Hysteria2 Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$HY2_INSTALL_DIR/hysteria -c $HY2_INSTALL_DIR/hy2_%i.yaml server
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ ! -f "$XRAY_TEMPLATE_FILE" ]]; then
        changed=1
        cat > "$XRAY_TEMPLATE_FILE" <<E_O_F
[Unit]
Description=Xray Service (Instance %i)
After=network.target
[Service]
Type=simple
ExecStart=$XRAY_INSTALL_DIR/xray -c $XRAY_INSTALL_DIR/xray_%i.json
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
Restart=always
RestartSec=3
[Install]
WantedBy=multi-user.target
E_O_F
    fi
    if [[ $changed -eq 1 ]]; then systemctl daemon-reload; fi
}

# 从配置文件提取监听信息
get_listen_info_from_conf() {
    local conf_path=$1
    if [[ ! -f "$conf_path" ]]; then echo "配置文件不存在"; return; fi

    if [[ "$conf_path" == *".json" ]]; then
        if grep -q '"smuxver"' "$conf_path" 2>/dev/null; then
            grep -Po '(?<="listen": ")[^"]+' "$conf_path"
        else
            local listen=$(jq -r '.inbounds[0].listen // "0.0.0.0"' "$conf_path" 2>/dev/null)
            local port=$(jq -r '.inbounds[0].port // 0' "$conf_path" 2>/dev/null)
            if [[ "$listen" == "null" || "$port" == "0" ]]; then echo "JSON解析错误"; else echo "${listen}:${port}"; fi
        fi
    elif [[ "$conf_path" == *".conf" ]]; then
        grep -Po '(?<=-l )[^ ]+' "$conf_path"
    elif [[ "$conf_path" == *".yaml" ]]; then
        local raw_listen=$(grep -Po '(?<=listen: ).*' "$conf_path" | tr -d '[:space:]')
        if [[ "$raw_listen" == :* ]]; then echo "0.0.0.0$raw_listen"; else echo "$raw_listen"; fi
    fi
}

# 检查 WARP 状态
get_warp_status_from_conf() {
    local conf_path=$1
    if [[ "$conf_path" == *".yaml" ]]; then
        if grep -q "name: warp" "$conf_path" 2>/dev/null; then echo "已启用WARP"; else echo "未启用WARP"; fi
    elif [[ "$conf_path" == *".json" ]]; then
        if jq -e '.outbounds[] | select(.tag == "warp")' "$conf_path" >/dev/null 2>&1; then echo "已启用WARP"; else echo "未启用WARP"; fi
    else
        echo ""
    fi
}

# 显示实例状态行
display_instance_status_line() {
    local type=$1 id=$2 prefix=$3; local full_id="$id"; local line
    case "$type" in
        "hy2_chain")
            full_id="c${id}"
            read -r color hy2_status udp_status <<< "$(check_services_status "ax-hysteria2@${full_id}.service" "ax-udp2raw@${full_id}.service")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$HY2_INSTALL_DIR/hy2_${full_id}.yaml")
            line="$($color "${prefix}Hysteria2 [${hy2_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "vless_chain")
            full_id="vc${id}"
            read -r color vless_status udp_status <<< "$(check_services_status "ax-xray@${full_id}.service" "ax-udp2raw@${full_id}.service")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}VLESS_mKCP [${vless_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "ss_3_chain_chain")
            full_id="s3c${id}"
            read -r color ss_status kcp_status udp_status <<< "$(check_services_status "ax-xray@${full_id}.service" "ax-kcptun@${full_id}.service" "ax-udp2raw@${full_id}.service")"
            local udp_info=$(get_listen_info_from_conf "$UDP2RAW_INSTALL_DIR/udp2raw_${full_id}.conf")
            local warp_status=$(get_warp_status_from_conf "$XRAY_INSTALL_DIR/xray_${full_id}.json")
            line="$($color "${prefix}SS [${ss_status}] + KCP [${kcp_status}] + UDP2RAW [${udp_status}] ${udp_info} (${warp_status})")"
            ;;
        "hysteria2"|"udp2raw"|"kcptun"|"xray_reality"|"xray_mkcp"|"xray_ss")
            local conf_file service_prefix title; local color_func="yellow"
            case "$type" in
                hysteria2) conf_file="$HY2_INSTALL_DIR/hy2_${id}.yaml"; service_prefix="ax-hysteria2"; title="Hysteria2";;
                udp2raw) conf_file="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"; service_prefix="ax-udp2raw"; title="UDP2RAW";;
                kcptun) conf_file="$KCPTUN_INSTALL_DIR/kcptun_${id}.json"; service_prefix="ax-kcptun"; title="KCPTUN";;
                xray_reality) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="VLESS+Reality";;
                xray_mkcp) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="VLESS+mKCP";;
                xray_ss) conf_file="$XRAY_INSTALL_DIR/xray_${id}.json"; service_prefix="ax-xray"; title="Shadowsocks";;
            esac
            local status_info=$(get_listen_info_from_conf "$conf_file")
            local status_str=$(check_service_status "${service_prefix}@${id}.service")
            local extra_info=""
            if [[ "$type" == "hysteria2" || "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then
                extra_info=" ($(get_warp_status_from_conf "$conf_file"))"
            fi
            if [[ "$status_str" == "运行中" ]]; then color_func="cyan"; fi
            line="$($color_func "${prefix}${title} [${status_str}] ${status_info}${extra_info}")"
            ;;
    esac
    echo -e "$line"
}


# 内部函数：获取指定目录下的所有实例 ID
get_instances() {
    local dir=$1 pattern=$2
    ls -1 "$dir"/$pattern 2>/dev/null | sed -E "s/.*_([a-zA-Z0-9]+)\\..*/\1/" | sort -V
}

# 获取 *独立* 实例的 ID 列表 (过滤掉串联实例)
get_standalone_instances() {
    local type_lowercase=$1
    local dir="" pattern=""
    local standalone_instances=()
    
    case "$type_lowercase" in
        "hysteria2") dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml";;
        "xray_reality") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_mkcp") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "xray_ss") dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json";;
        "udp2raw") dir="$UDP2RAW_INSTALL_DIR"; pattern="udp2raw_*.conf";;
        "kcptun") dir="$KCPTUN_INSTALL_DIR"; pattern="kcptun_*.json";;
    esac

    local all_instances=$(get_instances "$dir" "$pattern")
    for i in $all_instances; do
        if [[ "$type_lowercase" == "xray_reality" ]]; then
            grep -q '"security": "reality"' "$dir/xray_${i}.json" 2>/dev/null && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_mkcp" ]]; then
            grep -q '"network": "kcp"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^(vc|s3c)[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ "$type_lowercase" == "xray_ss" ]]; then
            grep -q '"protocol": "shadowsocks"' "$dir/xray_${i}.json" 2>/dev/null && [[ ! "$i" =~ ^s3c[0-9]+$ ]] && standalone_instances+=($i)
        elif [[ ! "$i" =~ ^(c|vc|s3c)[0-9]+$ ]]; then
            standalone_instances+=($i)
        fi
    done
    echo "${standalone_instances[@]}"
}


# --- 13. (独立) 实例管理菜单与操作 ---

# 管理单个独立实例的子菜单
manage_instance_menu() {
    local type=$1 id=$2 service=$3 conf=$4
    while true; do
        clear; echo "=================================="; echo "      管理 ${type^^} 实例 $(dim "$id")"; echo "=================================="
        echo "状态：$(check_service_status "$service") $(dim "$(get_listen_info_from_conf "$conf")")"
        if [[ "$type" == "hysteria2" ]]; then cyan "订阅链接: $(generate_hy2_subscription_link $id)"; fi
        if [[ "$type" == "xray_reality" ]]; then cyan "分享链接: $(generate_xray_reality_link $id)"; fi
        if [[ "$type" == "xray_mkcp" ]]; then cyan "分享链接: $(generate_xray_mkcp_link $id)"; fi
        if [[ "$type" == "xray_ss" ]]; then cyan "分享链接: $(generate_xray_ss_link $id)"; fi
        echo "----------------------------------"; echo "1) 启动/重启"; echo "2) 停止"; echo "3) 查看实时日志"; echo "4) 编辑配置"; echo "6) 查看客户端配置"; echo "99) 删除此实例"; echo "0) 返回"
        read -p "请选择 [0-6]: " choice
        case $choice in
            1) log "正在启动/重启..."; systemctl restart "$service"; green "操作完成！";;
            2) log "正在停止..."; systemctl stop "$service"; green "操作完成！";;
            3) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪日志... (按 Ctrl+C 仅退出日志)"
                sleep 1
                local current_trap=$(trap -p SIGINT) # 保存当前 trap
                trap ':' SIGINT
                journalctl -u "$service" -f --since "1 hour ago"
                eval "$current_trap" # 恢复 trap
                ;;
            4) nano "$conf"; log "重启实例以应用配置..."; systemctl restart "$service"; green "配置已更新！";;
            99) read -p "确认彻底删除实例 ${id}？(默认“否”) [y/N]: " confirm; if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then log "停止并删除..."; systemctl stop "$service"; systemctl disable "$service" >/dev/null 2>&1; rm -f "$conf"; systemctl daemon-reload; green "实例 ${id} 已删除！"; break; fi;;
            6) clear; echo "--- ${type^^} 客户端配置 (实例 $id) ---"
               case "$type" in
                   "hysteria2") cyan "订阅链接: $(generate_hy2_subscription_link "$id")" ;;
                   "udp2raw") view_udp2raw_client_config "$id" ;;
                   "kcptun") view_kcptun_client_config "$id" ;;
                   "xray_reality") cyan "分享链接: $(generate_xray_reality_link "$id")" ;;
                   "xray_mkcp") cyan "分享链接: $(generate_xray_mkcp_link "$id")" ;;
                   "xray_ss") cyan "分享链接: $(generate_xray_ss_link "$id")" ;;
               esac
               read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$choice" == "1" || "$choice" == "2" || "$choice" == "4" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}


# --- JQ 安全辅助函数 ---
escape_json_val() {
    local val="$1"
    if command -v jq >/dev/null; then
        echo -n "$val" | jq -R -s '.' | sed 's/^"//;s/"$//'
    else
        echo -n "$val"
    fi
}
# 创建一个新的独立实例 (hy2, udp2raw, kcptun)
create_new_instance() {
    local type=$1; local next_id; local INSTALL_DIR SERVICE_PREFIX FILE_EXT TITLE CONFIG_TEMPLATE SYSTEMD_SERVICE_NAME
    declare -A replacements

    case "$type" in
        hysteria2) 
            TITLE="Hysteria2"
            INSTALL_DIR="$HY2_INSTALL_DIR"
            SERVICE_PREFIX="hy2"
            SYSTEMD_SERVICE_NAME="ax-hysteria2"
            FILE_EXT="yaml"
            CONFIG_TEMPLATE="$HYSTERIA2_CONFIG_YAML_TEMPLATE"

            # --- ACME 与伪装逻辑 ---
            local use_acme=$(read_input "是否使用 ACME (Let's Encrypt) 证书? (否则将使用自签名证书) [Y/n]" "y")
            
            local cert_path="" key_path="" sni="" masquerade_url=""
            
            if [[ "$use_acme" == "y" || "$use_acme" == "Y" ]]; then
                local domain_name=$(read_input "请输入您的域名 (DNS 必须指向本机)" "")
                if [[ -z "$domain_name" ]]; then
                    red "域名不能为空！已取消创建。"
                    return 1
                fi

                # 尝试申请证书，如果失败直接退出
                if ! ax_get_certificate "$domain_name"; then
                    red "ACME 证书申请流程失败，已取消创建实例。"
                    return 1
                fi
                
                # 双重检查文件是否存在
                if [ -f "$AX_CERT_DIR/$domain_name/fullchain.cer" ]; then
                    green "ACME 验证成功. Hysteria2 将使用 $domain_name"
                    cert_path="$AX_CERT_DIR/$domain_name/fullchain.cer"
                    key_path="$AX_CERT_DIR/$domain_name/private.key"
                    sni="$domain_name"
                    masquerade_url="https://$domain_name"
                else
                    red "错误：未找到申请的证书文件，已取消创建实例。"
                    return 1
                fi
            else
                # 用户明确选择“否”，使用自签名
                generate_self_signed_cert
                cert_path="$HY2_CERT_PATH"
                key_path="$HY2_KEY_PATH"
                sni="$HY2_SNI"
                masquerade_url="$HY2_MASQUERADE_URL"
            fi
            
            replacements["__CERT_PATH__"]="$cert_path"
            replacements["__KEY_PATH__"]="$key_path"
            replacements["__MASQUERADE_URL__"]="$masquerade_url"
            
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ${SYSTEMD_SERVICE_NAME}@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"

            local listen_port=$(read_input "请输入监听端口 (留空则随机生成)" "")
            if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN__"]=":${listen_port}"
            
            # 忽略客户端带宽
            local ignore_bw_choice=$(read_input_with_options "是否忽略客户端带宽建议 (ignoreClientBandwidth)?" "1" "是 (true, 推荐)" "否 (false)")
            if [[ "$ignore_bw_choice" == "1" ]]; then replacements["__IGNORE_BW__"]="true"; else replacements["__IGNORE_BW__"]="false"; fi

            
    # --- [OPT] 汇总显示自动生成的参数 ---
    echo
    cyan "=== 自动生成的配置参数 ==="
    green "对外监听端口 (UDP2RAW): $udp2raw_listen_port"
    green "内部监听端口: $internal_listen_port"
    green "UDP2RAW 密码: $udp2raw_password"
    if [[ "$chain_type" == "hy2" ]]; then
        green "Hysteria2 密码: $hy2_password"
    else
        green "VLESS UUID: $uuid"
        green "mKCP Seed: $mkcp_seed"
    fi
    echo
    local enable_warp=$(read_input "是否启用 WARP SOCKS5 分流 [y/N]" "n")
            if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
                local warp_port=$(read_input "请输入 WARP SOCKS5 端口" "$DEFAULT_WARP_SOCKS_PORT")
                local current_warp_addr="${DEFAULT_WARP_SOCKS_ADDR}:${warp_port}"; replacements["__OUTBOUNDS_AND_ACL__"]="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_SOCKS5_ADDR__/${current_warp_addr}}"
                green "已启用 WARP SOCKS5 分流 (地址: ${current_warp_addr})。"
            else
                replacements["__OUTBOUNDS_AND_ACL__"]="${HYSTERIA2_DIRECT_ACL_BLOCK}"; yellow "已禁用 WARP SOCKS5 分流。"
            fi
            
            replacements["__UDP_SNIFF_CONFIG__"]=""
            local password=$(handle_password_input "hysteria2")
            replacements["__PASSWORD__"]="$password"
            ;;

        udp2raw) TITLE="UDP2RAW"; INSTALL_DIR="$UDP2RAW_INSTALL_DIR"; SERVICE_PREFIX="udp2raw"; SYSTEMD_SERVICE_NAME="ax-udp2raw"; FILE_EXT="conf"; CONFIG_TEMPLATE="$UDP2RAW_CONFIG_TEMPLATE" 
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ${SYSTEMD_SERVICE_NAME}@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"
            local listen_addr=$(read_input "请输入监听地址" "$DEFAULT_LISTEN_ADDR")
            local listen_port=$(read_input "请输入监听端口 (留空则随机生成)" "")
            if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN_ADDR__"]="${listen_addr}:${listen_port}"
            local target_host=$(read_input "请输入目标地址" "$DEFAULT_TARGET_ADDR")
            local target_port=$(read_input "请输入目标端口 (留空则随机生成)" "")
            if [[ -z "$target_port" ]]; then target_port=$(find_available_port); green "已为您随机选择目标端口: $target_port"; fi
            replacements["__TARGET_ADDR__"]="${target_host}:${target_port}"
            
        # UDP2RAW 关键参数
            local raw_mode_opts=("faketcp" "udp" "icmp")
            local raw_mode_idx=$(read_input_with_options "请选择 raw-mode (伪装模式):" "1" "${raw_mode_opts[@]}")
            replacements["__RAW_MODE__"]="${raw_mode_opts[$((raw_mode_idx-1))]}"
            
            local cipher_mode_opts=("aes128cbc" "xor" "none")
            local cipher_mode_idx=$(read_input_with_options "请选择 cipher-mode (加密模式):" "1" "${cipher_mode_opts[@]}")
            replacements["__CIPHER_MODE__"]="${cipher_mode_opts[$((cipher_mode_idx-1))]}"
            
            local auth_mode_opts=("hmac_sha1" "md5" "crc32" "simple" "none")
            local auth_mode_idx=$(read_input_with_options "请选择 auth-mode (认证模式):" "1" "${auth_mode_opts[@]}")
            replacements["__AUTH_MODE__"]="${auth_mode_opts[$((auth_mode_idx-1))]}"

            local password=$(handle_password_input "$type"); replacements["__PASSWORD__"]="$password"
            ;;
            
        kcptun) TITLE="KCPTUN"; INSTALL_DIR="$KCPTUN_INSTALL_DIR"; SERVICE_PREFIX="kcptun"; SYSTEMD_SERVICE_NAME="ax-kcptun"; FILE_EXT="json"; CONFIG_TEMPLATE="$KCPTUN_CONFIG_JSON_TEMPLATE" 
            log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "$type")
            green "新实例将被创建为: ${SYSTEMD_SERVICE_NAME}@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"
            local listen_addr=$(read_input "请输入监听地址" "$DEFAULT_LISTEN_ADDR")
            local listen_port=$(read_input "请输入监听端口 (留空则随机生成)" "")
            if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
            replacements["__LISTEN__"]="${listen_addr}:${listen_port}"
            local target_host=$(read_input "请输入目标地址" "$DEFAULT_TARGET_ADDR")
            local target_port=$(read_input "请输入目标端口 (留空则随机生成)" "")
            if [[ -z "$target_port" ]]; then target_port=$(find_available_port); green "已为您随机选择目标端口: $target_port"; fi
            replacements["__TARGET__"]="${target_host}:${target_port}"
            local mode_opts=("fast" "fast2" "fast3" "manual")
            local mode_idx=$(read_input_with_options "请选择加速模式 (mode):" "3" "${mode_opts[@]}")
            replacements["__MODE__"]="${mode_opts[$((mode_idx-1))]}"
            local mtu=$(read_input "请输入 MTU [默认:1350]" "1350")
            replacements["__MTU__"]="$mtu"
            local crypt_opts=("aes-128" "aes-192" "aes-256" "none")
            local crypt_idx=$(read_input_with_options "请选择加密方式 (crypt):" "1" "${crypt_opts[@]}")
            replacements["__CRYPT__"]="${crypt_opts[$((crypt_idx-1))]}"
            local sndwnd=$(read_input "请输入发送窗口大小 (sndwnd) [默认:256]" "256")
            replacements["__SNDWND__"]="$sndwnd"
            local rcvwnd=$(read_input "请输入接收窗口大小 (rcvwnd) [默认:2048]" "2048")
            replacements["__RCVWND__"]="$rcvwnd"
            local datashard=$(read_input "请输入数据分片数 (datashard) [默认:10]" "10")
            replacements["__DATASHARD__"]="$datashard"
            local parityshard=$(read_input "请输入纠错分片数 (parityshard) [默认:3]" "3")
            replacements["__PARITYSHARD__"]="$parityshard"
            local tcp=$(read_input "是否启用TCP模式 (tcp) [默认:false] (true/false)" "false")
            replacements["__TCP__"]="$tcp"
            local password=$(handle_password_input "$type"); replacements["__KEY__"]="$password"
            ;;
            
        *) red "内部错误: 无效的实例类型 '$type'"; return 1 ;;
    esac

    log "生成配置文件..."; local temp_config="$CONFIG_TEMPLATE"; local conf_path="${INSTALL_DIR}/${SERVICE_PREFIX}_${next_id}.${FILE_EXT}"
# --- JQ Patch Start ---
    for placeholder in "${!replacements[@]}"; do 
        local raw_val="${replacements[${placeholder}]}"
        local safe_val="$raw_val"
        if [[ "$FILE_EXT" == "json" ]]; then safe_val=$(escape_json_val "$raw_val"); fi
        temp_config="${temp_config//${placeholder}/${safe_val}}"
    done
    if [[ "$FILE_EXT" == "json" ]] && command -v jq >/dev/null; then
        if ! echo "$temp_config" | jq . >/dev/null 2>&1; then
            red "严重错误: 生成的 JSON 配置语法校验失败！保留配置供调试。"
        fi
    fi
    # --- JQ Patch End ---
    
    deploy_service_instance "${SYSTEMD_SERVICE_NAME}@${next_id}.service" "$conf_path" "$temp_config" || return 1
    echo

    case "$type" in
        hysteria2) local sub_link=""; local retries=5; for ((i=1; i<=retries; i++)); do sub_link=$(generate_hy2_subscription_link $next_id); if [[ "$sub_link" != "N/A" ]]; then break; fi; sleep 0.5; done; cyan "订阅链接: $sub_link";;
        udp2raw) view_udp2raw_client_config "$next_id" ;;
        kcptun) view_kcptun_client_config "$next_id" ;;
    esac
}

# 创建新的 Xray 实例 (VLESS+Reality, VLESS+mKCP, Shadowsocks)
create_new_xray_instance() {
    local type=$1; local next_id; local CONFIG_TEMPLATE TITLE
    declare -A replacements

    case "$type" in
        xray_reality) TITLE="VLESS+Reality"; CONFIG_TEMPLATE="$XRAY_VLESS_REALITY_TEMPLATE" ;;
        xray_mkcp) TITLE="VLESS+mKCP"; CONFIG_TEMPLATE="$XRAY_VLESS_MKCP_TEMPLATE" ;;
        xray_ss) TITLE="Shadowsocks"; CONFIG_TEMPLATE="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE" ;;
        *) red "内部错误: 无效的 Xray 类型 '$type'"; return 1 ;;
    esac

    log "启动一个新的 ${TITLE} 实例..."; next_id=$(find_next_available_id "xray")
    green "新实例将被创建为: ax-xray@${next_id}.service"; cyan "--- 配置新实例 (ID: ${next_id}) ---"

    local listen_addr=$(read_input "请输入监听地址" "$DEFAULT_LISTEN_ADDR")
    local listen_port=$(read_input "请输入监听端口 (留空则随机生成)" "")
    if [[ -z "$listen_port" ]]; then listen_port=$(find_available_port); green "已为您随机选择端口: $listen_port"; fi
    
    replacements["__LISTEN_ADDR__"]="$listen_addr"
    replacements["__LISTEN_PORT__"]="$listen_port"

    # WARP 分流设置
    
    # --- [OPT] 汇总显示自动生成的参数 ---
    echo
    cyan "=== 自动生成的配置参数 ==="
    green "对外监听端口 (UDP2RAW): $udp2raw_listen_port"
    green "内部监听端口: $internal_listen_port"
    green "UDP2RAW 密码: $udp2raw_password"
    if [[ "$chain_type" == "hy2" ]]; then
        green "Hysteria2 密码: $hy2_password"
    else
        green "VLESS UUID: $uuid"
        green "mKCP Seed: $mkcp_seed"
    fi
    echo
    local enable_warp=$(read_input "是否启用 WARP SOCKS5 分流 [y/N]" "n")
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_port=$(read_input "请输入 WARP SOCKS5 端口" "$DEFAULT_WARP_SOCKS_PORT")
        local current_warp_addr="${DEFAULT_WARP_SOCKS_ADDR}"; 
        replacements["__OUTBOUNDS_AND_ROUTING__"]="${XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK//__WARP_SOCKS5_ADDR__/${current_warp_addr}}"
        replacements["__OUTBOUNDS_AND_ROUTING__"]="${replacements[__OUTBOUNDS_AND_ROUTING__]//__WARP_SOCKS5_PORT__/${warp_port}}"
        green "已启用 WARP SOCKS5 分流 (地址: ${current_warp_addr}:${warp_port})。"
    else
        replacements["__OUTBOUNDS_AND_ROUTING__"]="${XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK}"; yellow "已禁用 WARP SOCKS5 分流。"
    fi

    # 协议特定配置
    if [[ "$type" == "xray_reality" ]]; then
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        local sni=$(read_input "请输入目标网站 (SNI/Target)" "$XRAY_REALITY_DEFAULT_SNI")
        replacements["__SNI__"]="$sni"; replacements["__TARGET__"]="${sni}:443"
        
        local key_pair=$("$XRAY_INSTALL_DIR/xray" x25519)
        local private_key=$(echo "$key_pair" | grep "Private" | awk '{print $3}')
        local public_key=$(echo "$key_pair" | grep "Public" | awk '{print $3}')
        replacements["__PRIVATE_KEY__"]="$private_key"; replacements["__PUBLIC_KEY__"]="$public_key"
        
        local short_id=$(openssl rand -hex 8); replacements["__SHORT_ID__"]="$short_id"
        replacements["__REALITY_FLOW__"]="$XRAY_REALITY_DEFAULT_FLOW"
        replacements["__FINGERPRINT__"]="$XRAY_REALITY_DEFAULT_FP"
        
    elif [[ "$type" == "xray_mkcp" ]]; then
        local uuid=$(generate_strong_password); replacements["__UUID__"]="$uuid"
        local seed=$(handle_password_input "xray_mkcp"); replacements["__MKCP_SEED__"]="$seed"
        
        # mKCP 关键参数
        local mtu=$(read_input "请输入 MTU (最大传输单元)" "1350"); replacements["__MTU__"]="$mtu"
        local tti=$(read_input "请输入 TTI (传输时间间隔 ms)" "20"); replacements["__TTI__"]="$tti"
        local uplink=$(read_input "请输入 uplinkCapacity (上行容量 MB/s)" "5"); replacements["__UPLINK__"]="$uplink"
        local downlink=$(read_input "请输入 downlinkCapacity (下行容量 MB/s)" "20"); replacements["__DOWNLINK__"]="$downlink"
        
        local congestion_choice=$(read_input_with_options "是否启用拥塞控制 (congestion)?" "2" "是 (true)" "否 (false, 推荐)")
        if [[ "$congestion_choice" == "1" ]]; then replacements["__CONGESTION__"]="true"; else replacements["__CONGESTION__"]="false"; fi
        
        local read_buf=$(read_input "请输入 readBufferSize (读取缓冲区 MB)" "2"); replacements["__READ_BUF__"]="$read_buf"
        local write_buf=$(read_input "请输入 writeBufferSize (写入缓冲区 MB)" "2"); replacements["__WRITE_BUF__"]="$write_buf"
        
        local header_opts=("none" "srtp" "utp" "wechat-video" "dtls" "wireguard")
        local header_idx=$(read_input_with_options "请选择伪装头类型 (header type):" "4" "${header_opts[@]}")
        replacements["__HEADER_TYPE__"]="${header_opts[$((header_idx-1))]}"

        elif [[ "$type" == "xray_ss" ]]; then
        local ss_method_opts=("2022-blake3-aes-128-gcm" "2022-blake3-aes-256-gcm" "2022-blake3-chacha20-poly1305" "aes-128-gcm" "aes-256-gcm" "chacha20-ietf-poly1305")
        local ss_method_idx=$(read_input_with_options "请选择 Shadowsocks 加密方式:" "2" "${ss_method_opts[@]}")
        local method="${ss_method_opts[$((ss_method_idx-1))]}"
        replacements["__SS_METHOD__"]="$method"
        
        local password=$(handle_password_input "shadowsocks" "$method")
        replacements["__SS_PASSWORD__"]="$password"
    fi

    log "生成配置文件..."; local temp_config="$CONFIG_TEMPLATE"; local conf_path="${XRAY_INSTALL_DIR}/xray_${next_id}.json"
# --- JQ Patch Start ---
    for placeholder in "${!replacements[@]}"; do 
        local raw_val="${replacements[${placeholder}]}"
        local safe_val="$raw_val"
        if [[ "$FILE_EXT" == "json" ]]; then safe_val=$(escape_json_val "$raw_val"); fi
        temp_config="${temp_config//${placeholder}/${safe_val}}"
    done
    if [[ "$FILE_EXT" == "json" ]] && command -v jq >/dev/null; then
        if ! echo "$temp_config" | jq . >/dev/null 2>&1; then
            red "严重错误: 生成的 JSON 配置语法校验失败！保留配置供调试。"
        fi
    fi
    # --- JQ Patch End ---

    deploy_service_instance "ax-xray@${next_id}.service" "$conf_path" "$temp_config" || return 1
    echo

    case "$type" in
        xray_reality) green "VLESS+Reality 链接: $(generate_xray_reality_link $next_id)";;
        xray_mkcp) green "VLESS+mKCP 链接: $(generate_xray_mkcp_link $next_id)";;
        xray_ss) green "Shadowsocks 链接: $(generate_xray_ss_link $next_id)";;
    esac
}
# --- 14. 客户端配置查看器 ---

# 生成 Hysteria2 订阅链接
generate_hy2_subscription_link() {
    local id=$1; local conf="$HY2_INSTALL_DIR/hy2_${id}.yaml"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    
    local password=$(grep -Po '(?<=password: ).*' "$conf" | tr -d '[:space:]')
    local port_info=$(get_listen_info_from_conf "$conf")
    local port=$(echo "$port_info" | awk -F':' '{print $NF}')
    local ip=$(get_public_ip)
    
    # 动态决定 SNI 和 insecure 标记
    local cert_path=$(grep -Po '(?<=cert: ).*' "$conf" | tr -d '[:space:]')
    local sni=""
    local insecure_flag=0 # 默认安全
    
    if [[ "$cert_path" == *"$AX_CERT_DIR"* ]]; then
        # 是 ACME 证书, 从路径中提取域名
        sni=$(echo "$cert_path" | cut -d'/' -f4)
        insecure_flag=0 # 真实证书，安全
    else
        # 是自签名证书
        sni="$HY2_SNI" # 默认 bing.com
        insecure_flag=$HY2_CLIENT_INSECURE # 使用全局不安全标记 (1)
    fi
    
    # 使用 sni 作为标识 (如果有)
    local host_label=$ip
    if [[ "$sni" != "$HY2_SNI" && -n "$sni" ]]; then
        host_label=$sni
    fi

    echo "hysteria2://${password}@${ip}:${port}?sni=${sni}&insecure=${insecure_flag}#hy2_${host_label}_${id}"
}

# 生成 VLESS+Reality 分享链接
generate_xray_reality_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local sni=$(jq -r '.inbounds[0].streamSettings.realitySettings.serverNames[0]' "$conf")
    local pbk=$(jq -r '.inbounds[0].streamSettings.realitySettings.publicKey' "$conf")
    local sid=$(jq -r '.inbounds[0].streamSettings.realitySettings.shortIds[0]' "$conf")
    local flow=$(jq -r '.inbounds[0].settings.clients[0].flow' "$conf")
    local fp=$(jq -r '.inbounds[0].streamSettings.realitySettings.fingerprint' "$conf")

    local link="vless://${uuid}@${ip}:${port}?type=tcp&security=reality&sni=${sni}&pbk=${pbk}&flow=${flow}&sid=${sid}&fp=${fp}#Xray_Reality_${ip}_${id}"
    echo "$link"
}

# 生成 VLESS+mKCP 分享链接
generate_xray_mkcp_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port=$(jq -r '.inbounds[0].port' "$conf")
    local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$conf")
    local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$conf")
    local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$conf")
    
    local link="vless://${uuid}@${ip}:${port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}#Xray_mKCP_${ip}_${id}"
    echo "$link"
}

# 生成 Shadowsocks 分享链接
generate_xray_ss_link() {
    local id=$1; local conf="$XRAY_INSTALL_DIR/xray_${id}.json"; if [[ ! -s "$conf" ]]; then echo "N/A"; return; fi
    local ip=$(get_public_ip)
    local port_info=$(get_listen_info_from_conf "$conf")
    local port=$(echo "$port_info" | awk -F':' '{print $NF}')
    local password=$(jq -r '.inbounds[0].settings.password' "$conf")
    local method=$(jq -r '.inbounds[0].settings.method' "$conf")
    
    # Base64 encode: method:password
    local user_info=$(echo -n "${method}:${password}" | base64 | tr -d '\n' | sed 's/=*$//') # Remove padding
    
    local link="ss://${user_info}@${ip}:${port}#SS_${ip}_${id}"
    echo "$link"
}

# 查看所有 Hysteria2 独立实例的订阅链接
view_all_hy2_subscriptions() {
    local INSTANCES=$(get_standalone_instances "hysteria2"); if [[ -z "$INSTANCES" ]]; then yellow "未找到任何 Hysteria2 独立实例。"; return; fi
    cyan "--- Hysteria2 独立实例订阅链接 ---"; for id in $INSTANCES; do green "实例 ${id}: $(generate_hy2_subscription_link $id)"; done
}

# 查看 UDP2RAW 客户端配置
view_udp2raw_client_config(){
    local id=$1; local conf="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    local ip=$(get_public_ip); local port=$(get_listen_info_from_conf "$conf" | awk -F':' '{print $NF}')
    local password=$(grep -Po '(?<=-k )[^ ]+' "$conf")
    local raw_mode=$(grep -Po '(?<=--raw-mode )[^ ]+' "$conf")
    local cipher_mode=$(grep -Po '(?<=--cipher-mode )[^ ]+' "$conf")
    local auth_mode=$(grep -Po '(?<=--auth-mode )[^ ]+' "$conf")
    
    local args="-c -l ${CLIENT_UDP2RAW_LISTEN_ADDR} -r ${ip}:${port} -k ${password} --raw-mode ${raw_mode} --cipher-mode ${cipher_mode} --auth-mode ${auth_mode} --seq-mode 4 -a --keep-rule --fix-gro"
    
    cyan "--- UDP2RAW 实例 ${id} 客户端配置 ---";  echo
    green "$args"
}

# 查看 KCPTUN 客户端配置
view_kcptun_client_config(){
    local id=$1; local conf="$KCPTUN_INSTALL_DIR/kcptun_${id}.json"; if [[ ! -s "$conf" ]]; then red "错误: 未找到实例 $id 的配置文件或文件为空。"; return; fi
    if ! command -v jq &>/dev/null; then red "错误: jq 未安装，无法解析配置。"; return; fi
    local ip=$(get_public_ip); local server_listen=$(jq -r '.listen' "$conf"); local server_port=$(echo "$server_listen" | awk -F':' '{print $NF}'); cyan "--- KCPTUN 实例 ${id} 客户端配置 ---"; echo
    
    yellow "方法一: 使用配置文件 (推荐)"; yellow "保存以下内容为 client.json，然后运行: kcptun_client -c client.json"; 
    # 生成对应的客户端 JSON (反转 listen/target)
    jq --arg ip "$ip" --arg port "$server_port" --arg listen "$CLIENT_KCPTUN_LISTEN_ADDR" '.remote = ($ip + ":" + $port) | .local = $listen | del(.listen, .target)' "$conf" | green_cat
    echo
    yellow "方法二: 使用命令行参数"; yellow "在客户端使用以下命令行参数 (本地监听地址 ${CLIENT_KCPTUN_LISTEN_ADDR} 可自行修改):";local args="--listen ${CLIENT_KCPTUN_LISTEN_ADDR} --target ${ip}:${server_port}"
    for key in $(jq -r 'keys_unsorted | .[]' "$conf"); do if [[ "$key" != "listen" && "$key" != "target" ]]; then local value=$(jq -r --arg k "$key" '.[$k]' "$conf"); args+=" --${key} ${value}"; fi; done; green "$args"; echo
}

# --- 15. 组件串联实例管理 (SS+KCP+UDP) ---

# 获取 3 组件串联实例ID列表 (ss_3_chain)
get_chain_instances_3() {
    local instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances2=$(ls -1 "$KCPTUN_INSTALL_DIR"/kcptun_s3c*.json 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    local instances3=$(ls -1 "$UDP2RAW_INSTALL_DIR"/udp2raw_s3c*.conf 2>/dev/null | sed -E 's/.*_s3c([0-9]+).*/\1/')
    echo "$instances1 $instances2 $instances3" | tr ' ' '\n' | sort -un
}

# 查看 3 组件串联实例的客户端配置
view_chain_client_config_3() {
    local id_num=$1
    local id="s3c${id_num}"
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${id}.json"
    local kcptun_conf_path="$KCPTUN_INSTALL_DIR/kcptun_${id}.json"
    local udp2raw_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"
    
    if [[ ! -f "$ss_conf_path" || ! -f "$kcptun_conf_path" || ! -f "$udp2raw_conf_path" ]]; then
        red "串联实例 ${id} 的配置文件不完整。"; return
    fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf_path" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf_path")
    local raw_mode=$(grep -Po '(?<=--raw-mode )[^ ]+' "$udp2raw_conf_path")
    local cipher_mode=$(grep -Po '(?<=--cipher-mode )[^ ]+' "$udp2raw_conf_path")
    local auth_mode=$(grep -Po '(?<=--auth-mode )[^ ]+' "$udp2raw_conf_path")
    
    local client_args_udp2raw="-c -r ${ip}:${udp2raw_port} -l ${CLIENT_SS_3_CHAIN_UDP2RAW_LISTEN_ADDR} -k ${udp2raw_password} --raw-mode ${raw_mode} --cipher-mode ${cipher_mode} --auth-mode ${auth_mode} --seq-mode 4 -a --keep-rule --fix-gro"
    local client_udp2raw_host="127.0.0.1"
    local client_udp2raw_port=$(echo "$CLIENT_SS_3_CHAIN_UDP2RAW_LISTEN_ADDR" | cut -d: -f2)
    
    local kcp_args="--listen ${CLIENT_SS_3_CHAIN_KCPTUN_LISTEN_ADDR} --target ${client_udp2raw_host}:${client_udp2raw_port}"
    for key in $(jq -r 'keys_unsorted | .[]' "$kcptun_conf_path"); do if [[ "$key" != "listen" && "$key" != "target" ]]; then local value=$(jq -r --arg k "$key" '.[$k]' "$kcptun_conf_path"); kcp_args+=" --${key} ${value}"; fi; done
    
    local ss_user_info=$(jq -r '.inbounds[0].settings.method + ":" + .inbounds[0].settings.password' "$ss_conf_path" | base64 | tr -d '\n' | sed 's/=*$//')
    local ss_host="127.0.0.1" # 强制本地回环
    local ss_port=$(echo "$CLIENT_SS_3_CHAIN_SS_TARGET" | cut -d: -f2)
    
    # 统一命名格式为 Chain_ss_kcp_... +UDP2RAW
    local sub_link="ss://${ss_user_info}@${ss_host}:${ss_port}#Chain_ss_kcp_${ip}_${id}+UDP2RAW"
    green "$sub_link"; echo
    
    echo
    yellow "[SS+KCPTUN+UDP2RAW] 合并订阅链接 (复制以下整行):"
    green "CHAIN##${sub_link} && KCPTUN://${kcp_args} && UDP2RAW://${client_args_udp2raw}"
    echo
}

# 启动一个新的 3 组件串联实例 (SS+KCP+UDP)
start_new_chain_instance_3() {
    local i=1
    while true; do if [[ ! -f "$XRAY_INSTALL_DIR/xray_s3c${i}.json" ]]; then break; fi; i=$((i + 1)); done
    
    local chain_id="s3c${i}"
    log "启动一个新的 SS+KCP+UDP 串联实例 (全自动)..."
    green "新串联实例将被创建为: ${chain_id}"
    
    # --- Step 1: UDP2RAW ---
    echo; cyan "=== 1. 配置 UDP2RAW (最外层) ==="
    local udp2raw_listen_port=$(read_input "请输入对外监听端口 (UDP2RAW) (留空则随机)" "")
    if [[ -z "$udp2raw_listen_port" ]]; then udp2raw_listen_port=$(find_available_port); green "已自动选择对外端口: $udp2raw_listen_port"; else if check_port_occupied "$udp2raw_listen_port"; then red "端口占用！"; return; fi; fi
    
    local udp2raw_password=$(handle_password_input "udp2raw")
    
    local raw_mode_opts=("faketcp" "udp" "icmp")
    local raw_mode_idx=$(read_input_with_options "请选择 UDP2RAW raw-mode (伪装模式):" "1" "${raw_mode_opts[@]}")
    local raw_mode="${raw_mode_opts[$((raw_mode_idx-1))]}"
    
    local cipher_mode_opts=("aes128cbc" "xor" "none")
    local cipher_mode_idx=$(read_input_with_options "请选择 cipher-mode (加密模式):" "1" "${cipher_mode_opts[@]}")
    local cipher_mode="${cipher_mode_opts[$((cipher_mode_idx-1))]}"
    
    local auth_mode_opts=("hmac_sha1" "md5" "crc32" "simple" "none")
    local auth_mode_idx=$(read_input_with_options "请选择 auth-mode (认证模式):" "1" "${auth_mode_opts[@]}")
    local auth_mode="${auth_mode_opts[$((auth_mode_idx-1))]}"

    # --- Step 2: KCPTUN ---
    echo; cyan "=== 2. 配置 KCPTUN (中间层) ==="
    local kcptun_listen_port=$(find_available_port)
    green "KCPTUN 监听端口已自动分配: $kcptun_listen_port"
    local kcptun_key=$(handle_password_input "kcptun")

    # --- Step 3: Shadowsocks ---
    echo; cyan "=== 3. 配置 Shadowsocks (最内层) ==="
    local ss_listen_port=$(find_available_port)
    green "Shadowsocks 监听端口已自动分配: $ss_listen_port"
    
    # [Change] 先选加密方式
    local ss_method_opts=("2022-blake3-aes-128-gcm" "2022-blake3-aes-256-gcm" "2022-blake3-chacha20-poly1305" "aes-128-gcm" "aes-256-gcm" "chacha20-ietf-poly1305")
    local ss_method_idx=$(read_input_with_options "请选择 Shadowsocks 加密方式:" "2" "${ss_method_opts[@]}")
    local ss_method="${ss_method_opts[$((ss_method_idx-1))]}"
    
    # [Change] 后生成密码 (传入 method 以决定长度)
    local ss_password=$(handle_password_input "shadowsocks" "$ss_method")

    # --- Step 4: WARP ---
    echo; cyan "=== 4. 配置 WARP 分流 ==="
    local enable_warp=$(read_input "是否启用 WARP SOCKS5 分流 [y/N]" "n")
    local warp_config_block=""
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR"
        local warp_port=$(read_input "请输入 WARP SOCKS5 端口" "$DEFAULT_WARP_SOCKS_PORT")
        warp_config_block=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
        warp_config_block=${warp_config_block/__WARP_SOCKS5_ADDR__/$warp_addr}
        warp_config_block=${warp_config_block/__WARP_SOCKS5_PORT__/$warp_port}
        green "已启用 WARP (地址: ${warp_addr}:${warp_port})"
    else
        warp_config_block=$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK
        yellow "已禁用 WARP"
    fi

    # --- 生成配置 ---
    # 1. SS
    local ss_config="$XRAY_SHADOWSOCKS_TCP_UDP_TEMPLATE"
    ss_config="${ss_config//__LISTEN_ADDR__/127.0.0.1}"
    ss_config="${ss_config//__LISTEN_PORT__/${ss_listen_port}}"
    ss_config="${ss_config//__SS_METHOD__/${ss_method}}"
    ss_config="${ss_config//__SS_PASSWORD__/${ss_password}}"
    ss_config=${ss_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
    local ss_conf_path="$XRAY_INSTALL_DIR/xray_${chain_id}.json"
    
    # 2. KCP
    local kcp_config="$KCPTUN_CONFIG_JSON_TEMPLATE"
    kcp_config="${kcp_config//__LISTEN__/127.0.0.1:${kcptun_listen_port}}"
    kcp_config="${kcp_config//__TARGET__/127.0.0.1:${ss_listen_port}}"
    kcp_config="${kcp_config//__KEY__/${kcptun_key}}"
    kcp_config="${kcp_config//__MODE__/$KCPTUN_DEFAULT_MODE}"
    kcp_config="${kcp_config//__MTU__/1350}"
    kcp_config="${kcp_config//__CRYPT__/aes-128}"
    kcp_config="${kcp_config//__SNDWND__/256}"
    kcp_config="${kcp_config//__RCVWND__/2048}"
    kcp_config="${kcp_config//__DATASHARD__/10}"
    kcp_config="${kcp_config//__PARITYSHARD__/3}"
    kcp_config="${kcp_config//__TCP__/false}"
    local kcp_conf_path="$KCPTUN_INSTALL_DIR/kcptun_${chain_id}.json"
    
    # 3. UDP2RAW
    local udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    udp_config="${udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    udp_config="${udp_config//__TARGET_ADDR__/127.0.0.1:${kcptun_listen_port}}"
    udp_config="${udp_config//__PASSWORD__/${udp2raw_password}}"
    udp_config="${udp_config//__RAW_MODE__/${raw_mode}}"
    udp_config="${udp_config//__CIPHER_MODE__/${cipher_mode}}"
    udp_config="${udp_config//__AUTH_MODE__/${auth_mode}}"
    local udp_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${chain_id}.conf"

    log "生成配置文件..."
    deploy_service_instance "ax-xray@${chain_id}.service" "$ss_conf_path" "$ss_config" || return 1
    deploy_service_instance "ax-kcptun@${chain_id}.service" "$kcp_conf_path" "$kcp_config" || return 1
    deploy_service_instance "ax-udp2raw@${chain_id}.service" "$udp_conf_path" "$udp_config" || return 1
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config_3 "$i"
}

# 管理一个已存在的 3 组件串联实例
manage_chain_instance_3() {
    local id_num=$1
    local manage_id="s3c${id_num}"
    
    local service1_full="ax-xray@${manage_id}.service" # SS
    local service2_full="ax-kcptun@${manage_id}.service"        # KCP
    local service3_full="ax-udp2raw@${manage_id}.service"        # UDP2RAW
    
    local conf1_path="$XRAY_INSTALL_DIR/xray_${manage_id}.json"
    local conf2_path="$KCPTUN_INSTALL_DIR/kcptun_${manage_id}.json"
    local conf3_path="$UDP2RAW_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "   管理 SS+KCP+UDP $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status s3_status <<< "$(check_services_status "$service1_full" "$service2_full" "$service3_full")"
        local udp2raw_info=$(get_listen_info_from_conf "$conf3_path")
        
        $color "状态: SS [${s1_status}] + KCP [${s2_status}] + UDP2RAW [${s3_status}] $(dim "$udp2raw_info")"

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 SS (Xray) 日志"; echo "5) 查看 KCPTUN 日志"; echo "6) 查看 UDP2RAW 日志"; echo "7) 编辑 SS (Xray) 配置文件"; echo "8) 编辑 KCPTUN 配置文件"; echo "9) 编辑 UDP2RAW 配置文件"; echo "99) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full" "$service3_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full" "$service3_full";;
            3) view_chain_client_config_3 "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) log "正在实时跟踪 SS (Xray) 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service1_full" -f; eval "$ct";;
            5) log "正在实时跟踪 KCPTUN 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service2_full" -f; eval "$ct";;
            6) log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"; local ct=$(trap -p SIGINT); trap ':' SIGINT; journalctl -u "$service3_full" -f; eval "$ct";;
            7) nano "$conf1_path"; systemctl restart "$service1_full";;
            8) nano "$conf2_path"; systemctl restart "$service2_full";;
            9) nano "$conf3_path"; systemctl restart "$service3_full";;
            99) read -p "确认删除串联实例 ${manage_id}？(默认“否”) [y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full" "$service3_full"; 
                systemctl disable "$service1_full" "$service2_full" "$service3_full" >/dev/null 2>&1; 
                rm -f "$conf1_path" "$conf2_path" "$conf3_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "7" || "$manage_choice" == "8" || "$manage_choice" == "9" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}


# --- 16. [合并] 2 组件串联实例管理 (Hysteria2 / VLESS) ---

# 获取 2 组件串联实例ID列表 (hy2 或 vless)
get_chain_instances() {
    local chain_type=$1
    local instances1="" instances2=""
    if [[ "$chain_type" == "hy2" ]]; then
        instances1=$(ls -1 "$HY2_INSTALL_DIR"/hy2_c*.yaml 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
        instances2=$(ls -1 "$UDP2RAW_INSTALL_DIR"/udp2raw_c*.conf 2>/dev/null | sed -E 's/.*_c([0-9]+).*/\1/')
    else # vless
        instances1=$(ls -1 "$XRAY_INSTALL_DIR"/xray_vc*.json 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
        instances2=$(ls -1 "$UDP2RAW_INSTALL_DIR"/udp2raw_vc*.conf 2>/dev/null | sed -E 's/.*_vc([0-9]+).*/\1/')
    fi
    echo "$instances1 $instances2" | tr ' ' '\n' | sort -un
}

# 查看 2 组件串联实例的客户端配置
view_chain_client_config() {
    local chain_type=$1 id_num=$2
    local id_prefix="" main_conf_path="" client_listen_addr="" title=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"; client_listen_addr="$CLIENT_UDP2RAW_LISTEN_ADDR"
    else
        id_prefix="vc"; title="VLESS_mKCP"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"; client_listen_addr="$CLIENT_VLESS_UDP2RAW_LISTEN_ADDR"
    fi
    local id="${id_prefix}${id_num}"
    local udp2raw_conf="$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf"
    if [[ ! -f "$main_conf_path" || ! -f "$udp2raw_conf" ]]; then red "串联实例 ${id} 的配置文件不完整。"; return; fi
    
    local ip=$(get_public_ip)
    local udp2raw_port=$(get_listen_info_from_conf "$udp2raw_conf" | awk -F':' '{print $NF}')
    local udp2raw_password=$(grep -Po '(?<=-k )[^ ]+' "$udp2raw_conf")
    local raw_mode=$(grep -Po '(?<=--raw-mode )[^ ]+' "$udp2raw_conf")
    local cipher_mode=$(grep -Po '(?<=--cipher-mode )[^ ]+' "$udp2raw_conf")
    local auth_mode=$(grep -Po '(?<=--auth-mode )[^ ]+' "$udp2raw_conf")
    
    local client_args="-c -r ${ip}:${udp2raw_port} -l ${client_listen_addr} -k ${udp2raw_password} --raw-mode ${raw_mode} --cipher-mode ${cipher_mode} --auth-mode ${auth_mode} --seq-mode 4 -a --keep-rule --fix-gro"
    local client_udp2raw_host="127.0.0.1" # 强制本地回环
    local client_udp2raw_port=$(echo "$client_listen_addr" | cut -d: -f2)
    local sub_link=""
    local display_title=""
    local host_label=$ip

    if [[ "$chain_type" == "hy2" ]]; then
        display_title="[hy2+UDP2RAW]"
        local hy2_password=$(grep -Po '(?<=password: ).*' "$main_conf_path" | tr -d '[:space:]')
        
        # 动态提取 SNI
        local cert_path=$(grep -Po '(?<=cert: ).*' "$main_conf_path" | tr -d '[:space:]')
        local sni=""
        local insecure_flag=0
        
        if [[ "$cert_path" == *"$AX_CERT_DIR"* ]]; then
            # 是 ACME 证书
            sni=$(echo "$cert_path" | cut -d'/' -f4)
            insecure_flag=0
        else
            # 自签名
            sni="$HY2_SNI"
            insecure_flag=$HY2_CLIENT_INSECURE
        fi
        
        # 如果有真实域名，UDP2RAW 和 链接备注都使用域名
        local server_addr=$ip
        if [[ "$sni" != "$HY2_SNI" && -n "$sni" ]]; then
            server_addr=$sni
            host_label=$sni
            # 更新 client_args 使用域名
            client_args="${UDP2RAW_CLIENT_BASE_ARGS} -r ${server_addr}:${udp2raw_port} -l ${client_listen_addr} -k ${udp2raw_password}"
        fi
        
        # 更改了节点备注格式：Chain_hy2_... +UDP2RAW
        sub_link="hysteria2://${hy2_password}@${client_udp2raw_host}:${client_udp2raw_port}?sni=${sni}&insecure=${insecure_flag}#Chain_hy2_${host_label}_${id}+UDP2RAW"
    else # vless
        display_title="[VLESS_mKCP+UDP2RAW]"
        local uuid=$(jq -r '.inbounds[0].settings.clients[0].id' "$main_conf_path")
        local seed=$(jq -r '.inbounds[0].streamSettings.kcpSettings.seed' "$main_conf_path")
        local header_type=$(jq -r '.inbounds[0].streamSettings.kcpSettings.header.type' "$main_conf_path")
        
        # 更改了节点备注格式：Chain_vless_kcp_... +UDP2RAW
        sub_link="vless://${uuid}@${client_udp2raw_host}:${client_udp2raw_port}?type=kcp&security=none&headerType=${header_type}&seed=${seed}#Chain_vless_kcp_${host_label}_${id}+UDP2RAW"
    fi

    cyan "--- ${title} 串联实例 ${id} 客户端配置 ---"; echo
    
    yellow "1. ${title} 客户端 (指向本地):"
    green "$sub_link"; echo
    
    yellow "2. UDP2RAW 客户端 (连接公网):"
    green "$client_args"; echo
    
    yellow "$display_title 合并订阅链接 (复制以下整行):"
    green "CHAIN##${sub_link} && UDP2RAW://${client_args}"
    echo
}

# 启动一个新的 2 组件串联实例 (hy2 或 vless)
start_new_chain_instance() {
    local chain_type=$1
    local i=1 id_prefix="" title="" main_conf_dir="" main_conf_template=""
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2+UDP"; main_conf_dir="$HY2_INSTALL_DIR"; main_conf_template="$HYSTERIA2_CONFIG_YAML_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/hy2_c${i}.yaml" ]]; then break; fi; i=$((i + 1)); done
    else # vless
        id_prefix="vc"; title="VLESS_mKCP+UDP"; main_conf_dir="$XRAY_INSTALL_DIR"; main_conf_template="$XRAY_VLESS_MKCP_TEMPLATE"
        while true; do if [[ ! -f "$main_conf_dir/xray_vc${i}.json" ]]; then break; fi; i=$((i + 1)); done
    fi
    
    local chain_id="${id_prefix}${i}"
    log "启动一个新的 ${title} 串联实例 (全自动)..."
    green "新串联实例将被创建为: ${chain_id}"
    local udp2raw_listen_port=$(find_available_port)
    local internal_listen_port=$(find_available_port)
    local udp2raw_password=$(generate_strong_password)
    
    local main_config="$main_conf_template"
    local main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        local hy2_password=$(generate_strong_password)
        
        # --- ACME 证书支持 (串联模式 - 健壮性增强版) ---
        local use_acme=$(read_input "是否使用 ACME (Let's Encrypt) 证书? (否则将使用自签名证书) [Y/n]" "y")
        
        local cert_path="" key_path="" masquerade_url=""
        
        if [[ "$use_acme" == "y" || "$use_acme" == "Y" ]]; then
            local domain_name=$(read_input "请输入您的域名 (DNS 必须指向本机)" "")
            if [[ -z "$domain_name" ]]; then
                red "域名不能为空！已取消创建。"
                return 1
            fi

            # 尝试申请证书，如果失败直接退出
            if ! ax_get_certificate "$domain_name"; then
                red "ACME 证书申请流程失败，已取消创建实例。"
                return 1
            fi
            
            if [ -f "$AX_CERT_DIR/$domain_name/fullchain.cer" ]; then
                green "ACME 验证成功. Hysteria2 将使用 $domain_name"
                cert_path="$AX_CERT_DIR/$domain_name/fullchain.cer"
                key_path="$AX_CERT_DIR/$domain_name/private.key"
                masquerade_url="https://$domain_name"
            else
                red "错误：未找到申请的证书文件，已取消创建实例。"
                return 1
            fi
        else
            # 用户明确选择“否”
            generate_self_signed_cert
            cert_path="$HY2_CERT_PATH"
            key_path="$HY2_KEY_PATH"
            masquerade_url="$HY2_MASQUERADE_URL"
        fi
        # ------------------------------------
        
        main_config="${main_config//__LISTEN__/127.0.0.1:${internal_listen_port}}"
        main_config="${main_config//__CERT_PATH__/${cert_path}}"
        main_config="${main_config//__KEY_PATH__/${key_path}}"
        main_config="${main_config//__PASSWORD__/${hy2_password}}"
        main_config="${main_config//__MASQUERADE_URL__/${masquerade_url}}"
        main_config="${main_config/__UDP_SNIFF_CONFIG__/udpPorts: all}"
        main_conf_path="$main_conf_dir/hy2_${chain_id}.yaml"
    else # vless
        local uuid=$(generate_strong_password)
        local mkcp_seed=$(generate_strong_password)
        main_config=${main_config/__LISTEN_ADDR__/127.0.0.1}
        main_config=${main_config/__LISTEN_PORT__/$internal_listen_port}
        main_config=${main_config/__UUID__/$uuid}
                main_config=${main_config/__MKCP_SEED__/$mkcp_seed}
        # --- [FIX] 自动填充 mKCP 默认参数 ---
        main_config=${main_config/__MTU__/1350}
        main_config=${main_config/__TTI__/20}
        main_config=${main_config/__UPLINK__/5}
        main_config=${main_config/__DOWNLINK__/20}
        main_config=${main_config/__CONGESTION__/false}
        main_config=${main_config/__READ_BUF__/2}
        main_config=${main_config/__WRITE_BUF__/2}
        main_config=${main_config/__HEADER_TYPE__/none}
        main_conf_path="$main_conf_dir/xray_${chain_id}.json"
    fi
    
   # UDP2RAW 关键参数
    local raw_mode_opts=("faketcp" "udp" "icmp")
    local raw_mode_idx=$(read_input_with_options "请选择 UDP2RAW raw-mode (伪装模式):" "1" "${raw_mode_opts[@]}")
    local raw_mode="${raw_mode_opts[$((raw_mode_idx-1))]}"
    
    local cipher_mode_opts=("aes128cbc" "xor" "none")
    local cipher_mode_idx=$(read_input_with_options "请选择 UDP2RAW cipher-mode (加密模式):" "1" "${cipher_mode_opts[@]}")
    local cipher_mode="${cipher_mode_opts[$((cipher_mode_idx-1))]}"
    
    local auth_mode_opts=("hmac_sha1" "md5" "crc32" "simple" "none")
    local auth_mode_idx=$(read_input_with_options "请选择 UDP2RAW auth-mode (认证模式):" "1" "${auth_mode_opts[@]}")
    local auth_mode="${auth_mode_opts[$((auth_mode_idx-1))]}"

    
    # --- [OPT] 汇总显示自动生成的参数 ---
    echo
    cyan "=== 自动生成的配置参数 ==="
    green "对外监听端口 (UDP2RAW): $udp2raw_listen_port"
    green "内部监听端口: $internal_listen_port"
    green "UDP2RAW 密码: $udp2raw_password"
    if [[ "$chain_type" == "hy2" ]]; then
        green "Hysteria2 密码: $hy2_password"
    else
        green "VLESS UUID: $uuid"
        green "mKCP Seed: $mkcp_seed"
    fi
    echo
    local enable_warp=$(read_input "是否启用 WARP SOCKS5 分流 [y/N]" "n")
    local warp_config_block=""
    if [[ "$enable_warp" == "y" || "$enable_warp" == "Y" ]]; then
        local warp_addr="$DEFAULT_WARP_SOCKS_ADDR" # 自动使用默认地址
        local warp_port=$(read_input "请输入 WARP SOCKS5 端口" "$DEFAULT_WARP_SOCKS_PORT")
        
        if [[ "$chain_type" == "hy2" ]]; then
            warp_config_block="${HYSTERIA2_WARP_OUTBOUND_ACL_BLOCK//__WARP_SOCKS5_ADDR__/${warp_addr}:${warp_port}}"
        else # vless
            warp_config_block=$XRAY_WARP_OUTBOUND_AND_ROUTING_BLOCK
            warp_config_block=${warp_config_block/__WARP_SOCKS5_ADDR__/$warp_addr}
            warp_config_block=${warp_config_block/__WARP_SOCKS5_PORT__/$warp_port}
        fi
        green "已启用 WARP SOCKS5 分流 (地址: ${warp_addr}:${warp_port})。"
    else
        if [[ "$chain_type" == "hy2" ]]; then
            warp_config_block=$HYSTERIA2_DIRECT_ACL_BLOCK
        else # vless
            warp_config_block=$XRAY_DIRECT_OUTBOUND_AND_ROUTING_BLOCK
        fi
        yellow "已禁用 WARP SOCKS5 分流。"
    fi
    
    if [[ "$chain_type" == "hy2" ]]; then
        main_config=${main_config/__OUTBOUNDS_AND_ACL__/$warp_config_block}
        main_config=${main_config/__IGNORE_BW__/false}
        deploy_service_instance "ax-hysteria2@${chain_id}.service" "$main_conf_path" "$main_config" || return 1
    else # vless
        main_config=${main_config/__OUTBOUNDS_AND_ROUTING__/$warp_config_block}
        deploy_service_instance "ax-xray@${chain_id}.service" "$main_conf_path" "$main_config" || return 1
    fi
    
    log "生成 UDP2RAW 配置文件: udp2raw_${chain_id}.conf..."; local temp_udp_config="${UDP2RAW_CONFIG_TEMPLATE}"
    temp_udp_config="${temp_udp_config//__LISTEN_ADDR__/0.0.0.0:${udp2raw_listen_port}}"
    temp_udp_config="${temp_udp_config//__TARGET_ADDR__/127.0.0.1:${internal_listen_port}}"
    temp_udp_config="${temp_udp_config//__PASSWORD__/${udp2raw_password}}"
    temp_udp_config="${temp_udp_config//__RAW_MODE__/${raw_mode}}"
    temp_udp_config="${temp_udp_config//__CIPHER_MODE__/${cipher_mode}}"
    temp_udp_config="${temp_udp_config//__AUTH_MODE__/${auth_mode}}"
    
    deploy_service_instance "ax-udp2raw@${chain_id}.service" "$UDP2RAW_INSTALL_DIR/udp2raw_${chain_id}.conf" "$temp_udp_config" || return 1
    
    sleep 1; green "串联实例 ${chain_id} 已启动！"; echo
    view_chain_client_config "$chain_type" "$i"
}

# 管理一个已存在的 2 组件串联实例
manage_chain_instance() {
    local chain_type=$1 id_num=$2
    local id_prefix="" title="" service1_name="" service2_name="" main_conf_path=""
    
    if [[ "$chain_type" == "hy2" ]]; then
        id_prefix="c"; title="Hysteria2"; service1_name="ax-hysteria2"; main_conf_path="$HY2_INSTALL_DIR/hy2_c${id_num}.yaml"
    else # vless
        id_prefix="vc"; title="VLESS_mKCP"; service1_name="ax-xray"; main_conf_path="$XRAY_INSTALL_DIR/xray_vc${id_num}.json"
    fi
    
    local manage_id="${id_prefix}${id_num}"
    service2_name="ax-udp2raw"
    local service1_full="${service1_name}@${manage_id}.service"
    local service2_full="${service2_name}@${manage_id}.service"
    local udp2raw_conf_path="$UDP2RAW_INSTALL_DIR/udp2raw_${manage_id}.conf"
    
    while true; do
        clear; echo "=================================="; echo "      管理${title}串联实例 $(dim "${manage_id}")"; echo "=================================="
        read -r color s1_status s2_status <<< "$(check_services_status "$service1_full" "$service2_full")"
        local udp2raw_info=$(get_listen_info_from_conf "$udp2raw_conf_path")
        
        if [[ "$chain_type" == "hy2" ]]; then
            $color "状态: Hysteria2 [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        else
            $color "状态: VLESS_mKCP [${s1_status}] + UDP2RAW [${s2_status}] $(dim "$udp2raw_info")"
        fi

        echo "----------------------------------"; echo "1) 启动/重启此串联"; echo "2) 停止此串联"; echo "3) 查看客户端配置指南"; echo "4) 查看 ${title} 日志"; echo "5) 查看 UDP2RAW 日志"; echo "6) 编辑 ${title} 配置文件 (高级)"; echo "7) 编辑 UDP2RAW 配置文件 (高级)"; echo "99) 彻底删除此串联"; echo "0) 返回"
        read -p "请选择: " manage_choice
        case $manage_choice in
            1) log "重启串联..."; systemctl restart "$service1_full" "$service2_full";;
            2) log "停止串联..."; systemctl stop "$service1_full" "$service2_full";;
            3) view_chain_client_config "$chain_type" "$id_num"; read -p $'\n按任意键返回...' -n1 -s;;
            4) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 ${title} 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service1_full" -f
                eval "$current_trap"
                ;;
            5) 
                # 修复 Ctrl+C 问题
                log "正在实时跟踪 UDP2RAW 日志... (按 Ctrl+C 仅退出日志)"
                local current_trap=$(trap -p SIGINT)
                trap ':' SIGINT
                journalctl -u "$service2_full" -f
                eval "$current_trap"
                ;;
            6) nano "$main_conf_path"; systemctl restart "$service1_full";;
            7) nano "$udp2raw_conf_path"; systemctl restart "$service2_full";;
            99) read -p "确认删除串联实例 ${manage_id}？(默认“否”) [y/N]: " del_confirm; if [[ "$del_confirm" == "y" ]]; then 
                log "删除串联..."; 
                systemctl stop "$service1_full" "$service2_full"; 
                systemctl disable "$service1_full" "$service2_full" >/dev/null 2>&1; 
                rm -f "$main_conf_path" "$udp2raw_conf_path"; 
                systemctl daemon-reload; green "已删除。"; break; 
                fi;;
            0) break;; *) red "无效输入";;
        esac
        [[ "$manage_choice" == "1" || "$manage_choice" == "2" || "$manage_choice" == "6" || "$manage_choice" == "7" ]] && read -p $'\n按任意键返回...' -n1 -s
    done
}

# 3 组件串联实例的通用管理菜单
chain_manager_menu_3() {
    local title="SS+KCP+UDP 一键串联"
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances_3)
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "ss_3_chain_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的串联实例。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的串联实例"; echo "2) 管理一个已存在的串联实例"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance_3; read -p $'\n按任意键返回...' -n1 -s;;
            2) 
                if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi
                read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num
                # 简单的存在性检查
                if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then 
                    manage_chain_instance_3 "$manage_id_num"
                else 
                    red "无效的实例ID！"; sleep 2
                fi
                ;;
            3) 
                if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi
                local i; for i in $INSTANCES; do view_chain_client_config_3 "$i"; done
                read -p $'\n按任意键返回...' -n1 -s
                ;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# 2 组件串联实例的通用管理菜单
chain_manager_menu() {
    local chain_type=$1
    local title=""
    if [[ "$chain_type" == "hy2" ]]; then
        title="Hysteria2+UDP一键串联"
    else # vless
        title="VLESS_mKCP+UDP一键串联"
    fi
    
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "  安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=$(get_chain_instances "$chain_type")
        if [[ -n "$INSTANCES" ]]; then 
            echo "$(bold "--- 已存在的串联实例 ---")"
            for i in $INSTANCES; do 
                display_instance_status_line "${chain_type}_chain" "$i" "  "
            done
        else 
            yellow "当前没有已创建的串联实例。"
        fi
        
        echo "----------------------------------"; echo "1) 启动一个新的串联实例"; echo "2) 管理一个已存在的串联实例"; echo "3) 查看配置"; echo "0) 返回主菜单"
        read -p "请选择: " choice
        case $choice in
            1) start_new_chain_instance "$chain_type"; read -p $'\n按任意键返回...' -n1 -s;;
            2) if [[ -z "$INSTANCES" ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi; read -p "请输入您想管理的串联实例ID (仅数字) [$(echo $INSTANCES | tr '\n' ' ')]: " manage_id_num; if echo "$INSTANCES" | grep -w -q "$manage_id_num"; then manage_chain_instance "$chain_type" "$manage_id_num"; else red "无效的实例ID！"; sleep 2; fi;;
            3) if [[ -z "$INSTANCES" ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi; local i; for i in $INSTANCES; do view_chain_client_config "$chain_type" $i; done; read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# 独立实例总管理菜单 (循环)
main_manager_loop() {
    local type=$1; local title dir pattern service_prefix type_lowercase
    case $type in 
        hysteria2) title="Hysteria2 (独立)"; dir="$HY2_INSTALL_DIR"; pattern="hy2_*.yaml"; service_prefix="ax-hysteria2"; type_lowercase="hysteria2";;
        udp2raw) title="UDP2RAW (独立)"; dir="$UDP2RAW_INSTALL_DIR"; pattern="udp2raw_*.conf"; service_prefix="ax-udp2raw"; type_lowercase="udp2raw";;
        kcptun) title="KCPTUN (独立)"; dir="$KCPTUN_INSTALL_DIR"; pattern="kcptun_*.json"; service_prefix="ax-kcptun"; type_lowercase="kcptun";;
        xray_reality) title="VLESS+Reality (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_reality";;
        xray_mkcp) title="VLESS+mKCP (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_mkcp";;
        xray_ss) title="Shadowsocks (独立)"; dir="$XRAY_INSTALL_DIR"; pattern="xray_*.json"; service_prefix="ax-xray"; type_lowercase="xray_ss";;
    esac
    while true; do
        trap 'echo -e "\n\n${yellow}操作已取消, 返回上级菜单...${reset}"; sleep 1; break' SIGINT
        clear; echo "=================================="; echo "     安装/管理 $title"; echo "=================================="; echo
        
        local INSTANCES=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#INSTANCES[@]} -gt 0 ]]; then
            echo "$(bold "--- 已存在的实例 ---")"; for i in "${INSTANCES[@]}"; do display_instance_status_line "$type_lowercase" "$i" "  "; done
        else
            yellow "当前没有已创建的 $title 实例。"
        fi

        echo "----------------------------------"; local menu_options=("1) 启动一个新的实例" "2) 管理一个已存在的实例")
        if [[ "$type" == "hysteria2" ]]; then menu_options+=("3) 查看hy2订阅地址");
        elif [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then menu_options+=("3) 查看分享链接");
        elif [[ "$type" == "udp2raw" || "$type" == "kcptun" ]]; then menu_options+=("3) 查看客户端配置"); fi
        menu_options+=("0) 返回主菜单"); for opt in "${menu_options[@]}"; do echo "$opt"; done
        read -p "请选择: " choice
        case $choice in
            1)
                if [[ "$type" == "xray_reality" || "$type" == "xray_mkcp" || "$type" == "xray_ss" ]]; then create_new_xray_instance "$type_lowercase"; else create_new_instance "$type_lowercase"; fi
                read -p $'\n按任意键返回...' -n1 -s;;
            2)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有可管理的实例。"; sleep 2; continue; fi
                local manage_id; read -p "请输入您想管理的实例ID [$(echo "${INSTANCES[@]}")]: " manage_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$manage_id" ]]; then is_valid=true; break; fi; done
                if [[ "$is_valid" == true ]]; then
                    local conf_path
                    case $type in
                        hysteria2) conf_path="$dir/hy2_${manage_id}.yaml";;
                        udp2raw) conf_path="$dir/udp2raw_${manage_id}.conf";;
                        kcptun) conf_path="$dir/kcptun_${manage_id}.json";;
                        xray_reality|xray_mkcp|xray_ss) conf_path="$dir/xray_${manage_id}.json";;
                    esac
                    manage_instance_menu "$type_lowercase" "$manage_id" "${service_prefix}@${manage_id}" "$conf_path"
                else red "无效的实例ID！"; sleep 2; fi;;
            3)
                if [[ ${#INSTANCES[@]} -eq 0 ]]; then yellow "当前没有实例可供查看。"; sleep 2; continue; fi
                if [[ "$type" == "hysteria2" ]]; then view_all_hy2_subscriptions
                else
                    local view_id; read -p "请输入您想查看的实例ID [$(echo "${INSTANCES[@]}")]: " view_id; local is_valid=false; for id in "${INSTANCES[@]}"; do if [[ "$id" == "$view_id" ]]; then is_valid=true; break; fi; done
                    if [[ "$is_valid" == true ]]; then
                        case "$type" in
                            udp2raw) view_udp2raw_client_config "$view_id" ;;
                            kcptun) view_kcptun_client_config "$view_id" ;;
                            xray_reality) cyan "$(generate_xray_reality_link "$view_id")" ;;
                            xray_mkcp) cyan "$(generate_xray_mkcp_link "$view_id")" ;;
                            xray_ss) cyan "$(generate_xray_ss_link "$view_id")" ;;
                        esac
                    else red "无效的实例ID！"; fi
                fi
                read -p $'\n按任意键返回...' -n1 -s;;
            0) break;; *) red "无效输入"; sleep 1;;
        esac
    done; trap - SIGINT
}

# --- 17. 全局操作 (查看全部/重启/更新/卸载) ---

# 显示全局 TLS 证书状态
show_global_tls_status() {
    echo "--- TLS 证书状态 ---"
    
    # 检查 ACME 证书目录
    if [ ! -d "$AX_CERT_DIR" ] || [ -z "$(ls -A $AX_CERT_DIR)" ]; then
        yellow "  未找到 $AX_CERT_DIR 目录, 未管理任何 ACME 证书。"
    else
        # 遍历 $AX_CERT_DIR 下的每个域名目录
        for domain_dir in "$AX_CERT_DIR"/*; do
            if [ -d "$domain_dir" ]; then
                local domain=$(basename "$domain_dir")
                local cert_file="$domain_dir/fullchain.cer"
                local key_file="$domain_dir/private.key"
                
                if [ -f "$cert_file" ] && [ -f "$key_file" ]; then
                    local expiry_date_str
                    local days_remaining="N/A"
                    
                    # 尝试获取到期天数
                    if command -v openssl &>/dev/null; then
                        expiry_date_str=$(openssl x509 -in "$cert_file" -noout -enddate 2>/dev/null | cut -d= -f2)
                        if [ -n "$expiry_date_str" ]; then
                            local expiry_epoch=$(date -d "$expiry_date_str" +%s 2>/dev/null)
                            local now_epoch=$(date +%s)
                            if [ -n "$expiry_epoch" ]; then
                                days_remaining=$(((expiry_epoch - now_epoch) / 86400))
                                days_remaining="(剩余 ${days_remaining} 天)"
                            fi
                        fi
                    fi
                    
                    cyan "[域名] $domain $days_remaining"
                    echo "  公钥 (Cert): $cert_file"
                    echo "  私钥 (Key):  $key_file"
                fi
            fi
        done
    fi
}

# 查看全部实例的客户端配置
view_all_configs() {
    clear; echo "=================================="; echo "        查看全部实例配置"; echo "=================================="; echo
    
    local ss_3_chain_instances=$(get_chain_instances_3); if [[ -n "$ss_3_chain_instances" ]]; then for i in $ss_3_chain_instances; do view_chain_client_config_3 "$i"; echo "----------------------------------"; done; fi
    local hy2_chain_instances=$(get_chain_instances "hy2"); if [[ -n "$hy2_chain_instances" ]]; then for i in $hy2_chain_instances; do view_chain_client_config "hy2" "$i"; echo "----------------------------------"; done; fi
    local vless_chain_instances=$(get_chain_instances "vless"); if [[ -n "$vless_chain_instances" ]]; then for i in $vless_chain_instances; do echo; view_chain_client_config "vless" "$i"; echo "----------------------------------"; done; fi
    
    local standalone_hy2=($(get_standalone_instances "hysteria2")); if [[ ${#standalone_hy2[@]} -gt 0 ]]; then echo; cyan "--- Hysteria2 (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_hy2[@]}"; do green "$(generate_hy2_subscription_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_reality=($(get_standalone_instances "xray_reality")); if [[ ${#standalone_reality[@]} -gt 0 ]]; then echo; cyan "--- VLESS+Reality (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_reality[@]}"; do green "$(generate_xray_reality_link $id)"; done; echo "----------------------------------"; fi
    local standalone_mkcp=($(get_standalone_instances "xray_mkcp")); if [[ ${#standalone_mkcp[@]} -gt 0 ]]; then echo; cyan "--- VLESS+mKCP (独立) 实例订阅链接 ---"; echo 
    for id in "${standalone_mkcp[@]}"; do green "$(generate_xray_mkcp_link $id)"; done; echo "----------------------------------"; fi
    local standalone_ss=($(get_standalone_instances "xray_ss")); if [[ ${#standalone_ss[@]} -gt 0 ]]; then echo; cyan "--- Shadowsocks (独立) 实例订阅链接 ---"; echo
    for id in "${standalone_ss[@]}"; do green "$(generate_xray_ss_link $id)"; done; echo "----------------------------------"; fi
    
    local standalone_udp2raw=($(get_standalone_instances "udp2raw")); if [[ ${#standalone_udp2raw[@]} -gt 0 ]]; then echo; for id in "${standalone_udp2raw[@]}"; do view_udp2raw_client_config "$id"; echo; done; echo "----------------------------------"; fi
    local standalone_kcptun=($(get_standalone_instances "kcptun")); if [[ ${#standalone_kcptun[@]} -gt 0 ]]; then echo; for id in "${standalone_kcptun[@]}"; do view_kcptun_client_config "$id"; echo; done; fi

    if ! is_installed; then yellow "系统中没有任何已配置的实例。"; fi
}

# 重启所有服务
restart_all_services(){ log "正在重启所有正在运行的实例..."; systemctl restart ax-kcptun@*.service ax-udp2raw@*.service hysteria2@*.service ax-xray@*.service 2>/dev/null; green "操作完成！"; sleep 2; }

# 检查并更新所有核心程序
check_for_updates(){ log "检查更新..."; download_kcp_udp_binaries; download_hysteria2_binary; download_xray_binary; log "所有程序已更新到最新版本，重启所有服务以应用..."; restart_all_services; sleep 2;}

# 安装 VPS 一键优化脚本
install_sys_opt() {
    echo "----------------------------------------------------------------"
    log "即将开始下载并运行 VPS 一键优化脚本 (vps_optimizert.sh) ..."
    
    # 运行用户提供的命令
    wget --no-check-certificate -O vps_optimizert.sh "https://raw.githubusercontent.com/halibotee/scripts/main/vps_optimizert.sh" && chmod +x vps_optimizert.sh && ./vps_optimizert.sh
    
    # 检查脚本是否成功下载（作为执行后的一个简单反馈）
    if [ ! -f "vps_optimizert.sh" ]; then
         echo "----------------------------------------------------------------"
         red "错误：下载 vps_optimizert.sh 失败或脚本未正确执行。"
         log "即将返回主菜单..."
         return 1 # 返回错误状态
    fi

    echo "----------------------------------------------------------------"
    green "VPS 一键优化脚本 (vps_optimizert.sh) 执行完毕。"
    log "即将返回主菜单..."
}

# 安装 warp-socket5 脚本
install_warp_yg() {
    echo "----------------------------------------------------------------"
    log "即将开始下载并运行 warp-socket5.sh 脚本..."
    
    # 运行用户提供的命令
    wget --no-check-certificate -O warp-socket5.sh "https://raw.githubusercontent.com/halibotee/scripts/main/warp-socket5.sh" && chmod +x warp-socket5.sh && ./warp-socket5.sh
    
    if [ ! -f "warp-socket5.sh" ]; then
         echo "----------------------------------------------------------------"
         red "错误：下载 warp-socket5.sh 失败或脚本未正确执行。"
         log "即将返回主菜单..."
         return 1 # 返回错误状态
    fi
    
    echo "----------------------------------------------------------------"
    green "warp-socket5.sh 脚本 执行完毕。"
    log "即将返回主菜单..."
}


# 卸载所有 (REFACTORED: 修复软卸载路径)
uninstall_all() {
    read -p "确认要卸载吗？(默认“否”) [y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then 
        yellow "操作已取消。"
        return 1
    fi
    
    read -p "是否要执行彻底清理（删除所有配置文件和证书）？(默认“否”) [y/N]: " nuke_choice
    log "开始卸载流程..."
    log "步骤 1: 停止并禁用所有相关服务..."
    systemctl stop "ax-kcptun@*.service" "ax-udp2raw@*.service" "ax-hysteria2@*.service" "ax-xray@*.service" "hysteria-server@*.service" 2>/dev/null
    systemctl disable "ax-kcptun@*.service" "ax-udp2raw@*.service" "ax-hysteria2@*.service" "ax-xray@*.service" "hysteria-server@*.service" 2>/dev/null
    green "服务已停止并禁用。"
    log "步骤 2: 删除所有 systemd 服务文件..."
    rm -f /etc/systemd/system/ax-kcptun@.service \
          /etc/systemd/system/ax-udp2raw@.service \
          /etc/systemd/system/ax-hysteria2@.service \
          /etc/systemd/system/ax-xray@.service \
          /etc/systemd/system/hysteria-server@.service
    green "Systemd 服务文件已删除。"
    if [[ "$nuke_choice" == "y" || "$nuke_choice" == "Y" ]]; then
        log "删除所有配置文件和证书文件..."
        rm -rf "$KCPTUN_INSTALL_DIR" "$UDP2RAW_INSTALL_DIR" "$HY2_INSTALL_DIR" "$XRAY_INSTALL_DIR" "$AX_CERT_DIR"
        green "核心配置文件和证书文件已删除。"
        log "步骤 4: 删除生成的证书..."
        rm -f /etc/ssl/private/bing.com.crt /etc/ssl/private/bing.com.key
        green "自签名证书已删除。"
    else
        log "仅删除程序文件（保留配置）..."
        rm -f "$KCPTUN_INSTALL_DIR/kcptun_server" "$UDP2RAW_INSTALL_DIR/udp2raw"
        rm -f "$HY2_INSTALL_DIR/hysteria" "$HY2_INSTALL_DIR/geoip.dat" "$HY2_INSTALL_DIR/geosite.dat"
        rm -f "$XRAY_INSTALL_DIR/xray" "$XRAY_INSTALL_DIR/geoip.dat" "$XRAY_INSTALL_DIR/geosite.dat"
        green "程序文件已删除。"
    fi
    log "步骤 5: 清理残留的二进制文件..."
    rm -f /usr/local/bin/hysteria
    green "残留二进制文件已清理。"
    log "步骤 6: 清理临时文件..."
    rm -f /tmp/kcptun.tar.gz /tmp/udp2raw.tar.gz /tmp/xray.zip
    log "步骤 7: 重载 systemd 并清理状态..."
    systemctl daemon-reload; systemctl reset-failed
    green "Systemd 已重载并清理。"
    echo; green "==== 卸载完成！ ===="; yellow "提示：依赖包 (如 curl, openssl, jq) 未被卸载。"; yellow "提示：请手动删除此脚本文件。"; sleep 3
    return 0
}

# --- 18. 脚本入口与初始化  ---

# --- 系统兼容性检查函数 ---
check_system_compatibility() {
    # 检查是否为root用户
    if [[ $EUID -ne 0 ]]; then
        red "错误: 此脚本必须以root用户身份运行"
        exit 1
    fi
    
    # 检查系统是否使用systemd
    if ! command -v systemctl &> /dev/null; then
        red "错误: 此脚本需要systemd支持，但您的系统似乎没有安装systemd"
        exit 1
    fi
    
    # 检查必要的命令是否可用
    local required_commands=("curl" "wget" "jq" "openssl")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        yellow "警告: 以下必要命令在系统中不可用:"
        for cmd in "${missing_commands[@]}"; do
            echo "  - $cmd"
        done
        yellow "将尝试在初始化过程中安装这些依赖"
    fi
}

# 首次运行检查和安装核心程序
initial_check_and_install() {
    # 添加系统兼容性检查
    check_system_compatibility
    
    install_dependencies
    local has_configs=false
    if is_installed; then has_configs=true; fi
    
    # 检查根目录下的文件
    local kcp_udp_ok=true; if [[ ! -f "$KCPTUN_INSTALL_DIR/kcptun_server" || ! -f "$UDP2RAW_INSTALL_DIR/udp2raw" ]]; then kcp_udp_ok=false; fi
    local hy2_ok=true; if [[ ! -f "$HY2_INSTALL_DIR/hysteria" ]]; then hy2_ok=false; fi
    local xray_ok=true; if [[ ! -f "$XRAY_INSTALL_DIR/xray" ]]; then xray_ok=false; fi
    
    if [[ "$has_configs" == true && ( "$kcp_udp_ok" == false || "$hy2_ok" == false || "$xray_ok" == false ) ]]; then
        clear; yellow "检测到已存在的配置文件，但核心程序文件不完整。"; read -p "是否保留配置并仅重新安装核心程序？(默认“是”) [Y/n]: " choice
        if [[ "$choice" != "n" && "$choice" != "N" ]]; then
            log "正在重新安装核心程序..."
            [[ "$kcp_udp_ok" == false ]] && download_kcp_udp_binaries
            [[ "$hy2_ok" == false ]] && download_hysteria2_binary
            [[ "$xray_ok" == false ]] && download_xray_binary
            green "核心程序重装完成。"; sleep 2
        else
            uninstall_all; exit 0
        fi
    elif [[ "$kcp_udp_ok" == false || "$hy2_ok" == false || "$xray_ok" == false ]]; then
        clear; yellow "首次运行或程序不完整，需要下载核心程序文件。"; log "正在自动下载所有核心程序..."
        [[ "$kcp_udp_ok" == false ]] && (download_kcp_udp_binaries || { red "KCP/UDP 下载失败，退出。"; exit 1; })
        [[ "$hy2_ok" == false ]] && (download_hysteria2_binary || { red "Hysteria2 下载失败，退出。"; exit 1; })
        [[ "$xray_ok" == false ]] && (download_xray_binary || { red "Xray-core 下载失败，退出。"; exit 1; })
        green "核心程序准备就绪。"; sleep 2
    fi
    ensure_template_files; sleep 1
}

# 主菜单状态总览 (使用粗体标题)
show_status_summary() {
    local menu_index=21; echo "--- 当前状态 (输入序号可直接管理) ---"; if ! is_installed; then yellow "未安装任何组件。"; return; fi
    
    local ss_3_chain_instances=$(get_chain_instances_3)
    if [[ -n "$ss_3_chain_instances" ]]; then
        echo "$(bold "SS+KCP+UDP 串联实例:")"
        for i in $ss_3_chain_instances; do display_instance_status_line "ss_3_chain_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="ss_3_chain_chain"; menu_index=$((menu_index + 1)); done
    fi
    local hy2_chain_instances=$(get_chain_instances "hy2")
    if [[ -n "$hy2_chain_instances" ]]; then
        echo "$(bold "Hysteria2+UDP 串联实例:")"
        for i in $hy2_chain_instances; do display_instance_status_line "hy2_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="hy2_chain"; menu_index=$((menu_index + 1)); done
    fi
    local vless_chain_instances=$(get_chain_instances "vless")
    if [[ -n "$vless_chain_instances" ]]; then
        echo "$(bold "VLESS_mKCP+UDP 串联实例:")"
        for i in $vless_chain_instances; do display_instance_status_line "vless_chain" "$i" "$menu_index) "; QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="vless_chain"; menu_index=$((menu_index + 1)); done
    fi

    for type in "Hysteria2" "VLESS+Reality" "VLESS+mKCP" "Shadowsocks" "UDP2RAW" "KCPTUN"; do
        local type_lowercase=""
        case "$type" in
            "Hysteria2") type_lowercase="hysteria2";;
            "VLESS+Reality") type_lowercase="xray_reality";;
            "VLESS+mKCP") type_lowercase="xray_mkcp";;
            "Shadowsocks") type_lowercase="xray_ss";;
            "UDP2RAW") type_lowercase="udp2raw";;
            "KCPTUN") type_lowercase="kcptun";;
        esac
        
        local standalone_instances=($(get_standalone_instances "$type_lowercase"))

        if [[ ${#standalone_instances[@]} -gt 0 ]]; then
            echo "$(bold "${type} (独立) 实例:")"
            for i in "${standalone_instances[@]}"; do
                display_instance_status_line "$type_lowercase" "$i" "$menu_index) "
                QUICK_MANAGE_MAP_ID[$menu_index]=$i; QUICK_MANAGE_MAP_TYPE[$menu_index]="$type_lowercase"; menu_index=$((menu_index + 1))
            done
        fi
    done
}

# 分发管理菜单
dispatch_management_menu() {
    local type=$1
    local id=$2
    case "$type" in
        "ss_3_chain_chain") manage_chain_instance_3 "$id" ;;
        "hy2_chain") manage_chain_instance "hy2" "$id" ;;
        "vless_chain") manage_chain_instance "vless" "$id" ;;
        "hysteria2") manage_instance_menu "hysteria2" "$id" "ax-hysteria2@${id}" "$HY2_INSTALL_DIR/hy2_${id}.yaml" ;;
        "xray_reality") manage_instance_menu "xray_reality" "$id" "ax-xray@${id}" "$XRAY_INSTALL_DIR/xray_${id}.json" ;;
        "xray_mkcp") manage_instance_menu "xray_mkcp" "$id" "ax-xray@${id}" "$XRAY_INSTALL_DIR/xray_${id}.json" ;;
        "xray_ss") manage_instance_menu "xray_ss" "$id" "ax-xray@${id}" "$XRAY_INSTALL_DIR/xray_${id}.json" ;;
        "udp2raw") manage_instance_menu "udp2raw" "$id" "ax-udp2raw@${id}" "$UDP2RAW_INSTALL_DIR/udp2raw_${id}.conf" ;;
        "kcptun") manage_instance_menu "kcptun" "$id" "ax-kcptun@${id}" "$KCPTUN_INSTALL_DIR/kcptun_${id}.json" ;;
    esac
}

# 主菜单 
main_menu(){
    declare -A QUICK_MANAGE_MAP_ID; declare -A QUICK_MANAGE_MAP_TYPE
    while true; do
        QUICK_MANAGE_MAP_ID=(); QUICK_MANAGE_MAP_TYPE=()
        trap '' SIGINT
        clear; echo "=================================="; echo "  多合一隧道管理脚本 V$SCRIPT_VERSION"; echo "=================================="
        cyan "--- 串联管理 ---"
        echo " 1) Hysteria2+UDP2RAW 串联"
        echo " 2) VLESS_mKCP+UDP2RAW 串联"
        echo " 3) Shadowsocks+KCP+UDP 串联"
        cyan "--- 独立实例管理 ---"
        echo " 4) Hysteria2"
        echo " 5) VLESS+Reality"
        echo " 6) VLESS+mKCP"
        echo " 7) Shadowsocks"
        cyan "--- 加速管理 ---"
        echo " 8) UDP2RAW"
        echo " 9) KCPTUN"
        echo "----------------------------------"
        cyan "--- 全局操作 ---"
        echo " 10) 查看全部配置"
        echo " 11) 重启全部服务"
        echo " 12) 检查更新程序" 
        cyan "--- 工具管理 ---"
        echo " 13) 一键优化系统"
        echo " 14) 一键开启warp-Socks5"
        echo "----------------------------------"   
        echo " 99) 卸载"
        echo " 0) 退出"
        
        # --- 全局 TLS 状态 (位于 0 和 "当前状态" 之间) ---
        echo "----------------------------------"
        show_global_tls_status
        # --- ACME 状态结束 ---
        
        echo "----------------------------------"
        show_status_summary
        local num_items=${#QUICK_MANAGE_MAP_ID[@]}; local max_index=$((20 + num_items))
        echo "----------------------------------"
        # [MODIFIED] 更改提示符范围
        local prompt="请选择 [0-14, 99"; if [[ $num_items -gt 0 ]]; then prompt+=", 21-${max_index}]"; else prompt+="]"; fi
        read -p "$prompt： " choice
        
        if [[ -n "${QUICK_MANAGE_MAP_ID[$choice]}" ]]; then
            local real_id="${QUICK_MANAGE_MAP_ID[$choice]}"; local type="${QUICK_MANAGE_MAP_TYPE[$choice]}"
            dispatch_management_menu "$type" "$real_id"
            continue
        fi
        
        case $choice in
            1) chain_manager_menu "hy2" ;;
            2) chain_manager_menu "vless" ;;
            3) chain_manager_menu_3 ;;
            4) main_manager_loop "hysteria2" ;; 
            5) main_manager_loop "xray_reality" ;;
            6) main_manager_loop "xray_mkcp" ;; 
            7) main_manager_loop "xray_ss" ;;
            8) main_manager_loop "udp2raw" ;;
            9) main_manager_loop "kcptun" ;;
            10) view_all_configs; read -p $'\n按任意键返回...' -n1 -s;;
            11) restart_all_services ;;
            12) check_for_updates; read -p "按任意键继续..." -n1 -s ;;
            13) clear; install_sys_opt; read -p $'\n按任意键返回...' -n1 -s ;;
            14) clear; install_warp_yg; read -p $'\n按任意键返回...' -n1 -s ;;
            99) uninstall_all; if [[ $? -eq 0 ]]; then exit 0; fi ;;
            0) trap - SIGINT; exit 0 ;; 
            *) red "无效选择!"; sleep 1 ;;
        esac
    done
}

# --- 19. 脚本执行入口 ---
# 捕获 Ctrl+C 信号，以便在脚本主体执行期间优雅退出
trap 'echo -e "\n\n${yellow}操作被中断，退出脚本。${reset}"; trap - SIGINT; exit 1' SIGINT
# 初始化检查和安装
initial_check_and_install
# 显示主菜单
main_menu
